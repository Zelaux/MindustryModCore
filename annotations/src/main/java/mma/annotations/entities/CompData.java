package mma.annotations.entities;

import arc.struct.ObjectMap;

class CompData {

    static final ObjectMap<String, String> compMap;

    static final String groupDefs;

    public static arc.struct.ObjectMap<String, String[]> indexerDefs;

    static {
        compMap = new ObjectMap<>();
        compMap.put("AnnotationConfigComponents",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import mma.annotations.ModAnnotations;\r\n", "\r\n", "public class AnnotationConfigComponents {\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface BlockUnitc extends mindustry.gen.BlockUnitc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Boundedc extends mindustry.gen.Boundedc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Builderc extends mindustry.gen.Builderc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Buildingc extends mindustry.gen.Buildingc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface BuildingTetherc extends mindustry.gen.BuildingTetherc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Bulletc extends mindustry.gen.Bulletc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Childc extends mindustry.gen.Childc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Crawlc extends mindustry.gen.Crawlc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Damagec extends mindustry.gen.Damagec {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Decalc extends mindustry.gen.Decalc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Drawc extends mindustry.gen.Drawc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface EffectStatec extends mindustry.gen.EffectStatec {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface ElevationMovec extends mindustry.gen.ElevationMovec {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Entityc extends mindustry.gen.Entityc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Firec extends mindustry.gen.Firec {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Flyingc extends mindustry.gen.Flyingc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Healthc extends mindustry.gen.Healthc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Hitboxc extends mindustry.gen.Hitboxc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Itemsc extends mindustry.gen.Itemsc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface LaunchCorec extends mindustry.gen.LaunchCorec {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Legsc extends mindustry.gen.Legsc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Mechc extends mindustry.gen.Mechc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Minerc extends mindustry.gen.Minerc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Ownerc extends mindustry.gen.Ownerc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Payloadc extends mindustry.gen.Payloadc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Physicsc extends mindustry.gen.Physicsc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Playerc extends mindustry.gen.Playerc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Posc extends mindustry.gen.Posc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface PowerGraphUpdaterc extends mindustry.gen.PowerGraphUpdaterc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Puddlec extends mindustry.gen.Puddlec {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Rotc extends mindustry.gen.Rotc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Shieldc extends mindustry.gen.Shieldc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Shielderc extends mindustry.gen.Shielderc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Statusc extends mindustry.gen.Statusc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Syncc extends mindustry.gen.Syncc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Tankc extends mindustry.gen.Tankc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Teamc extends mindustry.gen.Teamc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Timedc extends mindustry.gen.Timedc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface TimedKillc extends mindustry.gen.TimedKillc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Timerc extends mindustry.gen.Timerc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Unitc extends mindustry.gen.Unitc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface UnitTetherc extends mindustry.gen.UnitTetherc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Velc extends mindustry.gen.Velc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface WaterMovec extends mindustry.gen.WaterMovec {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface Weaponsc extends mindustry.gen.Weaponsc {\r\n", "  }\r\n", "\r\n", "  @ModAnnotations.EntitySuperClass()\r\n", "  interface WorldLabelc extends mindustry.gen.WorldLabelc {\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("BlockUnitComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.graphics.g2d.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class BlockUnitComp implements Unitc {\r\n", "\r\n", "  @Import\r\n", "  Team team;\r\n", "\r\n", "  @ReadOnly\r\n", "  transient Building tile;\r\n", "\r\n", "  public void tile(Building tile) {\r\n", "    this.tile = tile;\r\n", "    // sets up block stats\r\n", "    maxHealth(tile.block.health);\r\n", "    health(tile.health);\r\n", "    hitSize(tile.block.size * tilesize * 0.7f);\r\n", "    set(tile);\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void add() {\r\n", "    if (tile == null) {\r\n", "      throw new RuntimeException(\"Do not add BlockUnit entities to the game, they will simply crash. Internal use only.\");\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    if (tile != null) {\r\n", "      team = tile.team;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public TextureRegion icon() {\r\n", "    return tile.block.fullIcon;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void killed() {\r\n", "    tile.kill();\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  public void damage(float v, boolean b) {\r\n", "    tile.damage(v, b);\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  public boolean dead() {\r\n", "    return tile == null || tile.dead();\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  public boolean isValid() {\r\n", "    return tile != null && tile.isValid();\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  public void team(Team team) {\r\n", "    if (tile != null && this.team != team) {\r\n", "      this.team = team;\r\n", "      if (tile.team != team) {\r\n", "        tile.changeTeam(team);\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("BoundedComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.math.*;\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.type.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class BoundedComp implements Velc, Posc, Healthc, Flyingc {\r\n", "\r\n", "  static final float warpDst = 30f;\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  @Import\r\n", "  float x, y;\r\n", "\r\n", "  @Import\r\n", "  Team team;\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    if (!type.bounded)\r\n", "      return;\r\n", "    float bot = 0f, left = 0f, top = world.unitHeight(), right = world.unitWidth();\r\n", "    // TODO hidden map rules only apply to player teams? should they?\r\n", "    if (state.rules.limitMapArea && !team.isAI()) {\r\n", "      bot = state.rules.limitY * tilesize;\r\n", "      left = state.rules.limitX * tilesize;\r\n", "      top = state.rules.limitHeight * tilesize + bot;\r\n", "      right = state.rules.limitWidth * tilesize + left;\r\n", "    }\r\n", "    if (!net.client() || isLocal()) {\r\n", "      float dx = 0f, dy = 0f;\r\n", "      // repel unit out of bounds\r\n", "      if (x < left)\r\n", "        dx += (-(x - left) / warpDst);\r\n", "      if (y < bot)\r\n", "        dy += (-(y - bot) / warpDst);\r\n", "      if (x > right)\r\n", "        dx -= (x - right) / warpDst;\r\n", "      if (y > top)\r\n", "        dy -= (y - top) / warpDst;\r\n", "      velAddNet(dx * Time.delta, dy * Time.delta);\r\n", "    }\r\n", "    // clamp position if not flying\r\n", "    if (isGrounded()) {\r\n", "      x = Mathf.clamp(x, left, right - tilesize);\r\n", "      y = Mathf.clamp(y, bot, top - tilesize);\r\n", "    }\r\n", "    // kill when out of bounds\r\n", "    if (x < -finalWorldBounds + left || y < -finalWorldBounds + bot || x >= right + finalWorldBounds || y >= top + finalWorldBounds) {\r\n", "      kill();\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("BuilderComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.*;\r\n", "import arc.func.*;\r\n", "import arc.graphics.*;\r\n", "import arc.graphics.g2d.*;\r\n", "import arc.math.*;\r\n", "import arc.struct.Queue;\r\n", "import arc.util.*;\r\n", "import mindustry.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.entities.units.*;\r\n", "import mindustry.game.EventType.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.graphics.*;\r\n", "import mindustry.type.*;\r\n", "import mindustry.world.*;\r\n", "import mindustry.world.blocks.*;\r\n", "import mindustry.world.blocks.ConstructBlock.*;\r\n", "import java.util.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class BuilderComp implements Posc, Statusc, Teamc, Rotc {\r\n", "\r\n", "  @Import\r\n", "  float x, y, rotation, buildSpeedMultiplier;\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  @Import\r\n", "  Team team;\r\n", "\r\n", "  @SyncLocal\r\n", "  Queue<BuildPlan> plans = new Queue<>(1);\r\n", "\r\n", "  @SyncLocal\r\n", "  boolean updateBuilding = true;\r\n", "\r\n", "  private transient float buildCounter;\r\n", "\r\n", "  private transient BuildPlan lastActive;\r\n", "\r\n", "  private transient int lastSize;\r\n", "\r\n", "  transient float buildAlpha = 0f;\r\n", "\r\n", "  public boolean canBuild() {\r\n", "    return type.buildSpeed > 0 && buildSpeedMultiplier > 0;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    updateBuildLogic();\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void afterRead() {\r\n", "    // why would this happen?\r\n", "    if (plans == null) {\r\n", "      plans = new Queue<>(1);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void validatePlans() {\r\n", "    if (plans.size > 0) {\r\n", "      Iterator<BuildPlan> it = plans.iterator();\r\n", "      while (it.hasNext()) {\r\n", "        BuildPlan plan = it.next();\r\n", "        Tile tile = world.tile(plan.x, plan.y);\r\n", "        if (tile == null || (plan.breaking && tile.block() == Blocks.air) || (!plan.breaking && ((tile.build != null && tile.build.rotation == plan.rotation) || !plan.block.rotate) && (tile.block() == plan.block || (plan.block != null && (plan.block.isOverlay() && plan.block == tile.overlay() || (plan.block.isFloor() && plan.block == tile.floor())))))) {\r\n", "          it.remove();\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void updateBuildLogic() {\r\n", "    if (type.buildSpeed <= 0f)\r\n", "      return;\r\n", "    if (!headless) {\r\n", "      // visual activity update\r\n", "      if (lastActive != null && buildAlpha <= 0.01f) {\r\n", "        lastActive = null;\r\n", "      }\r\n", "      buildAlpha = Mathf.lerpDelta(buildAlpha, activelyBuilding() ? 1f : 0f, 0.15f);\r\n", "    }\r\n", "    // validate regardless of whether building is enabled.\r\n", "    if (!updateBuilding || !canBuild()) {\r\n", "      validatePlans();\r\n", "      return;\r\n", "    }\r\n", "    float finalPlaceDst = state.rules.infiniteResources ? Float.MAX_VALUE : type.buildRange;\r\n", "    boolean infinite = state.rules.infiniteResources || team().rules().infiniteResources;\r\n", "    buildCounter += Time.delta;\r\n", "    if (Float.isNaN(buildCounter) || Float.isInfinite(buildCounter))\r\n", "      buildCounter = 0f;\r\n", "    buildCounter = Math.min(buildCounter, 10f);\r\n", "    // random attempt to fix a freeze that only occurs on Android\r\n", "    int maxPerFrame = 10, count = 0;\r\n", "    while (buildCounter >= 1 && count++ < maxPerFrame) {\r\n", "      buildCounter -= 1f;\r\n", "      validatePlans();\r\n", "      var core = core();\r\n", "      // nothing to build.\r\n", "      if (buildPlan() == null)\r\n", "        return;\r\n", "      // find the next build plan\r\n", "      if (plans.size > 1) {\r\n", "        int total = 0;\r\n", "        int size = plans.size;\r\n", "        BuildPlan plan;\r\n", "        while ((!within((plan = buildPlan()).tile(), finalPlaceDst) || shouldSkip(plan, core)) && total < size) {\r\n", "          plans.removeFirst();\r\n", "          plans.addLast(plan);\r\n", "          total++;\r\n", "        }\r\n", "      }\r\n", "      BuildPlan current = buildPlan();\r\n", "      Tile tile = current.tile();\r\n", "      lastActive = current;\r\n", "      buildAlpha = 1f;\r\n", "      if (current.breaking)\r\n", "        lastSize = tile.block().size;\r\n", "      if (!within(tile, finalPlaceDst))\r\n", "        continue;\r\n", "      if (!headless) {\r\n", "        Vars.control.sound.loop(Sounds.build, tile, 0.15f);\r\n", "      }\r\n", "      if (!(tile.build instanceof ConstructBuild cb)) {\r\n", "        if (!current.initialized && !current.breaking && Build.validPlace(current.block, team, current.x, current.y, current.rotation)) {\r\n", "          boolean hasAll = infinite || current.isRotation(team) || !Structs.contains(current.block.requirements, i -> core != null && !core.items.has(i.item, Math.min(Mathf.round(i.amount * state.rules.buildCostMultiplier), 1)));\r\n", "          if (hasAll) {\r\n", "            Call.beginPlace(self(), current.block, team, current.x, current.y, current.rotation);\r\n", "          } else {\r\n", "            current.stuck = true;\r\n", "          }\r\n", "        } else if (!current.initialized && current.breaking && Build.validBreak(team, current.x, current.y)) {\r\n", "          Call.beginBreak(self(), team, current.x, current.y);\r\n", "        } else {\r\n", "          plans.removeFirst();\r\n", "          continue;\r\n", "        }\r\n", "      } else if ((tile.team() != team && tile.team() != Team.derelict) || (!current.breaking && (cb.current != current.block || cb.tile != current.tile()))) {\r\n", "        plans.removeFirst();\r\n", "        continue;\r\n", "      }\r\n", "      if (tile.build instanceof ConstructBuild && !current.initialized) {\r\n", "        Events.fire(new BuildSelectEvent(tile, team, self(), current.breaking));\r\n", "        current.initialized = true;\r\n", "      }\r\n", "      // if there is no core to build with or no build entity, stop building!\r\n", "      if ((core == null && !infinite) || !(tile.build instanceof ConstructBuild entity)) {\r\n", "        continue;\r\n", "      }\r\n", "      float bs = 1f / entity.buildCost * type.buildSpeed * buildSpeedMultiplier * state.rules.buildSpeed(team);\r\n", "      // otherwise, update it.\r\n", "      if (current.breaking) {\r\n", "        entity.deconstruct(self(), core, bs);\r\n", "      } else {\r\n", "        entity.construct(self(), core, bs, current.config);\r\n", "      }\r\n", "      current.stuck = Mathf.equal(current.progress, entity.progress);\r\n", "      current.progress = entity.progress;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Draw all current build plans. Does not draw the beam effect, only the positions.\r\n", "   */\r\n", "  void drawBuildPlans() {\r\n", "    Boolf<BuildPlan> skip = plan -> plan.progress > 0.01f || (buildPlan() == plan && plan.initialized && (within(plan.x * tilesize, plan.y * tilesize, type.buildRange) || state.isEditor()));\r\n", "    for (int i = 0; i < 2; i++) {\r\n", "      for (BuildPlan plan : plans) {\r\n", "        if (skip.get(plan))\r\n", "          continue;\r\n", "        if (i == 0) {\r\n", "          drawPlan(plan, 1f);\r\n", "        } else {\r\n", "          drawPlanTop(plan, 1f);\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "    Draw.reset();\r\n", "  }\r\n", "\r\n", "  void drawPlan(BuildPlan plan, float alpha) {\r\n", "    plan.animScale = 1f;\r\n", "    if (plan.breaking) {\r\n", "      control.input.drawBreaking(plan);\r\n", "    } else {\r\n", "      plan.block.drawPlan(plan, control.input.allPlans(), Build.validPlace(plan.block, team, plan.x, plan.y, plan.rotation) || control.input.planMatches(plan), alpha);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  void drawPlanTop(BuildPlan plan, float alpha) {\r\n", "    if (!plan.breaking) {\r\n", "      Draw.reset();\r\n", "      Draw.mixcol(Color.white, 0.24f + Mathf.absin(Time.globalTime, 6f, 0.28f));\r\n", "      Draw.alpha(alpha);\r\n", "      plan.block.drawPlanConfigTop(plan, plans);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return whether this plan should be skipped, in favor of the next one.\r\n", "   */\r\n", "  boolean shouldSkip(BuildPlan plan, @Nullable Building core) {\r\n", "    // plans that you have at least *started* are considered\r\n", "    if (state.rules.infiniteResources || team.rules().infiniteResources || plan.breaking || core == null || plan.isRotation(team) || (isBuilding() && !within(plans.last(), type.buildRange)))\r\n", "      return false;\r\n", "    return (plan.stuck && !core.items.has(plan.block.requirements)) || (Structs.contains(plan.block.requirements, i -> !core.items.has(i.item, Math.min(i.amount, 15)) && Mathf.round(i.amount * state.rules.buildCostMultiplier) > 0) && !plan.initialized);\r\n", "  }\r\n", "\r\n", "  void removeBuild(int x, int y, boolean breaking) {\r\n", "    // remove matching plan\r\n", "    int idx = plans.indexOf(req -> req.breaking == breaking && req.x == x && req.y == y);\r\n", "    if (idx != -1) {\r\n", "      plans.removeIndex(idx);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Return whether this builder's place queue contains items.\r\n", "   */\r\n", "  boolean isBuilding() {\r\n", "    return plans.size != 0;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Clears the placement queue.\r\n", "   */\r\n", "  void clearBuilding() {\r\n", "    plans.clear();\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Add another build plans to the tail of the queue, if it doesn't exist there yet.\r\n", "   */\r\n", "  void addBuild(BuildPlan place) {\r\n", "    addBuild(place, true);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Add another build plans to the queue, if it doesn't exist there yet.\r\n", "   */\r\n", "  void addBuild(BuildPlan place, boolean tail) {\r\n", "    if (!canBuild())\r\n", "      return;\r\n", "    BuildPlan replace = null;\r\n", "    for (BuildPlan plan : plans) {\r\n", "      if (plan.x == place.x && plan.y == place.y) {\r\n", "        replace = plan;\r\n", "        break;\r\n", "      }\r\n", "    }\r\n", "    if (replace != null) {\r\n", "      plans.remove(replace);\r\n", "    }\r\n", "    Tile tile = world.tile(place.x, place.y);\r\n", "    if (tile != null && tile.build instanceof ConstructBuild cons) {\r\n", "      place.progress = cons.progress;\r\n", "    }\r\n", "    if (tail) {\r\n", "      plans.addLast(place);\r\n", "    } else {\r\n", "      plans.addFirst(place);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  boolean activelyBuilding() {\r\n", "    // not actively building when not near the build plan\r\n", "    if (isBuilding()) {\r\n", "      var plan = buildPlan();\r\n", "      if (!state.isEditor() && plan != null && !within(plan, state.rules.infiniteResources ? Float.MAX_VALUE : type.buildRange)) {\r\n", "        return false;\r\n", "      }\r\n", "    }\r\n", "    return isBuilding() && updateBuilding;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return  the build plan currently active, or the one at the top of the queue.\r\n", "   */\r\n", "  @Nullable\r\n", "  BuildPlan buildPlan() {\r\n", "    return plans.size == 0 ? null : plans.first();\r\n", "  }\r\n", "\r\n", "  public void draw() {\r\n", "    drawBuilding();\r\n", "  }\r\n", "\r\n", "  public void drawBuilding() {\r\n", "    // TODO make this more generic so it works with builder \"weapons\"\r\n", "    boolean active = activelyBuilding();\r\n", "    if (!active && lastActive == null)\r\n", "      return;\r\n", "    Draw.z(Layer.flyingUnit);\r\n", "    BuildPlan plan = active ? buildPlan() : lastActive;\r\n", "    Tile tile = plan.tile();\r\n", "    var core = team.core();\r\n", "    if (tile == null || !within(plan, state.rules.infiniteResources ? Float.MAX_VALUE : type.buildRange)) {\r\n", "      return;\r\n", "    }\r\n", "    // draw remote plans.\r\n", "    if (core != null && active && !isLocal() && !(tile.block() instanceof ConstructBlock)) {\r\n", "      Draw.z(Layer.plans - 1f);\r\n", "      drawPlan(plan, 0.5f);\r\n", "      drawPlanTop(plan, 0.5f);\r\n", "      Draw.z(Layer.flyingUnit);\r\n", "    }\r\n", "    if (type.drawBuildBeam) {\r\n", "      float focusLen = type.buildBeamOffset + Mathf.absin(Time.time, 3f, 0.6f);\r\n", "      float px = x + Angles.trnsx(rotation, focusLen);\r\n", "      float py = y + Angles.trnsy(rotation, focusLen);\r\n", "      drawBuildingBeam(px, py);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void drawBuildingBeam(float px, float py) {\r\n", "    boolean active = activelyBuilding();\r\n", "    if (!active && lastActive == null)\r\n", "      return;\r\n", "    Draw.z(Layer.flyingUnit);\r\n", "    BuildPlan plan = active ? buildPlan() : lastActive;\r\n", "    Tile tile = world.tile(plan.x, plan.y);\r\n", "    if (tile == null || !within(plan, state.rules.infiniteResources ? Float.MAX_VALUE : type.buildRange)) {\r\n", "      return;\r\n", "    }\r\n", "    int size = plan.breaking ? active ? tile.block().size : lastSize : plan.block.size;\r\n", "    float tx = plan.drawx(), ty = plan.drawy();\r\n", "    Lines.stroke(1f, plan.breaking ? Pal.remove : Pal.accent);\r\n", "    Draw.z(Layer.buildBeam);\r\n", "    Draw.alpha(buildAlpha);\r\n", "    if (!active && !(tile.build instanceof ConstructBuild)) {\r\n", "      Fill.square(plan.drawx(), plan.drawy(), size * tilesize / 2f);\r\n", "    }\r\n", "    Drawf.buildBeam(px, py, tx, ty, Vars.tilesize * size / 2f);\r\n", "    Fill.square(px, py, 1.8f + Mathf.absin(Time.time, 2.2f, 1.1f), rotation + 45);\r\n", "    Draw.reset();\r\n", "    Draw.z(Layer.flyingUnit);\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("BuildingComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.*;\r\n", "import arc.Graphics.*;\r\n", "import arc.Graphics.Cursor.*;\r\n", "import arc.func.*;\r\n", "import arc.graphics.*;\r\n", "import arc.graphics.g2d.*;\r\n", "import arc.math.*;\r\n", "import arc.math.geom.*;\r\n", "import arc.math.geom.QuadTree.*;\r\n", "import arc.scene.ui.*;\r\n", "import arc.scene.ui.layout.*;\r\n", "import arc.struct.*;\r\n", "import arc.util.*;\r\n", "import arc.util.io.*;\r\n", "import mindustry.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.audio.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.core.*;\r\n", "import mindustry.ctype.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.game.EventType.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.game.Teams.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.graphics.*;\r\n", "import mindustry.logic.*;\r\n", "import mindustry.type.*;\r\n", "import mindustry.ui.*;\r\n", "import mindustry.world.*;\r\n", "import mindustry.world.blocks.ConstructBlock.*;\r\n", "import mindustry.world.blocks.*;\r\n", "import mindustry.world.blocks.environment.*;\r\n", "import mindustry.world.blocks.heat.*;\r\n", "import mindustry.world.blocks.heat.HeatConductor.*;\r\n", "import mindustry.world.blocks.logic.LogicBlock.*;\r\n", "import mindustry.world.blocks.payloads.*;\r\n", "import mindustry.world.blocks.power.*;\r\n", "import mindustry.world.consumers.*;\r\n", "import mindustry.world.meta.*;\r\n", "import mindustry.world.modules.*;\r\n", "import java.util.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { Buildingc.class }, isFinal = false, genio = false, serialize = false)\r\n", "@Component(base = true)\r\n", "abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc, Timerc, QuadTreeObject, Displayable, Sized, Senseable, Controllable, Settable {\r\n", "\r\n", "  // region vars and initialization\r\n", "  static final float timeToSleep = 60f * 1, recentDamageTime = 60f * 5f;\r\n", "\r\n", "  static final ObjectSet<Building> tmpTiles = new ObjectSet<>();\r\n", "\r\n", "  static final Seq<Building> tempBuilds = new Seq<>();\r\n", "\r\n", "  static final BuildTeamChangeEvent teamChangeEvent = new BuildTeamChangeEvent();\r\n", "\r\n", "  static final BuildDamageEvent bulletDamageEvent = new BuildDamageEvent();\r\n", "\r\n", "  static int sleepingEntities = 0;\r\n", "\r\n", "  @Import\r\n", "  float x, y, health, maxHealth;\r\n", "\r\n", "  @Import\r\n", "  Team team;\r\n", "\r\n", "  transient Tile tile;\r\n", "\r\n", "  transient Block block;\r\n", "\r\n", "  transient Seq<Building> proximity = new Seq<>(6);\r\n", "\r\n", "  transient int cdump;\r\n", "\r\n", "  transient int rotation;\r\n", "\r\n", "  transient float payloadRotation;\r\n", "\r\n", "  transient String lastAccessed;\r\n", "\r\n", "  // used only by the indexer\r\n", "  transient boolean wasDamaged;\r\n", "\r\n", "  transient float visualLiquid;\r\n", "\r\n", "  /**\r\n", "   * TODO Each bit corresponds to a team ID. Only 64 are supported. Does not work on servers.\r\n", "   */\r\n", "  transient long visibleFlags;\r\n", "\r\n", "  // used only by the block renderer when fog is on (TODO replace with discovered check?)\r\n", "  transient boolean wasVisible;\r\n", "\r\n", "  transient boolean enabled = true;\r\n", "\r\n", "  @Nullable\r\n", "  transient Building lastDisabler;\r\n", "\r\n", "  @Nullable\r\n", "  PowerModule power;\r\n", "\r\n", "  @Nullable\r\n", "  ItemModule items;\r\n", "\r\n", "  @Nullable\r\n", "  LiquidModule liquids;\r\n", "\r\n", "  /**\r\n", "   * Base efficiency. Takes the minimum value of all consumers.\r\n", "   */\r\n", "  transient float efficiency;\r\n", "\r\n", "  /**\r\n", "   * Same as efficiency, but for optional consumers only.\r\n", "   */\r\n", "  transient float optionalEfficiency;\r\n", "\r\n", "  /**\r\n", "   * The efficiency this block *would* have if shouldConsume() returned true.\r\n", "   */\r\n", "  transient float potentialEfficiency;\r\n", "\r\n", "  transient float healSuppressionTime = -1f;\r\n", "\r\n", "  transient float lastHealTime = -120f * 10f;\r\n", "\r\n", "  private transient float lastDamageTime = -recentDamageTime;\r\n", "\r\n", "  private transient float timeScale = 1f, timeScaleDuration;\r\n", "\r\n", "  private transient float dumpAccum;\r\n", "\r\n", "  @Nullable\r\n", "  private transient SoundLoop sound;\r\n", "\r\n", "  private transient boolean sleeping;\r\n", "\r\n", "  private transient float sleepTime;\r\n", "\r\n", "  private transient boolean initialized;\r\n", "\r\n", "  /**\r\n", "   * Sets this tile entity data to this and adds it if necessary.\r\n", "   */\r\n", "  public Building init(Tile tile, Team team, boolean shouldAdd, int rotation) {\r\n", "    if (!initialized) {\r\n", "      create(tile.block(), team);\r\n", "    } else {\r\n", "      if (block.hasPower) {\r\n", "        power.init = false;\r\n", "        // reinit power graph\r\n", "        new PowerGraph().add(self());\r\n", "      }\r\n", "    }\r\n", "    proximity.clear();\r\n", "    this.rotation = rotation;\r\n", "    this.tile = tile;\r\n", "    set(tile.drawx(), tile.drawy());\r\n", "    if (shouldAdd) {\r\n", "      add();\r\n", "    }\r\n", "    created();\r\n", "    return self();\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Sets up all the necessary variables, but does not add this entity anywhere.\r\n", "   */\r\n", "  public Building create(Block block, Team team) {\r\n", "    this.block = block;\r\n", "    this.team = team;\r\n", "    if (block.loopSound != Sounds.none) {\r\n", "      sound = new SoundLoop(block.loopSound, block.loopSoundVolume);\r\n", "    }\r\n", "    health = block.health;\r\n", "    maxHealth(block.health);\r\n", "    timer(new Interval(block.timers));\r\n", "    if (block.hasItems)\r\n", "      items = new ItemModule();\r\n", "    if (block.hasLiquids)\r\n", "      liquids = new LiquidModule();\r\n", "    if (block.hasPower) {\r\n", "      power = new PowerModule();\r\n", "      power.graph.add(self());\r\n", "    }\r\n", "    initialized = true;\r\n", "    return self();\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void add() {\r\n", "    if (power != null) {\r\n", "      power.graph.checkAdd();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public int tileX() {\r\n", "    return tile.x;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public int tileY() {\r\n", "    return tile.y;\r\n", "  }\r\n", "\r\n", "  // endregion\r\n", "  // region io\r\n", "  public final void writeBase(Writes write) {\r\n", "    boolean writeVisibility = state.rules.fog && visibleFlags != 0;\r\n", "    write.f(health);\r\n", "    write.b(rotation | 0b10000000);\r\n", "    write.b(team.id);\r\n", "    // version\r\n", "    write.b(writeVisibility ? 4 : 3);\r\n", "    write.b(enabled ? 1 : 0);\r\n", "    // write presence of items/power/liquids/cons, so removing/adding them does not corrupt future saves.\r\n", "    write.b(moduleBitmask());\r\n", "    if (items != null)\r\n", "      items.write(write);\r\n", "    if (power != null)\r\n", "      power.write(write);\r\n", "    if (liquids != null)\r\n", "      liquids.write(write);\r\n", "    // efficiency is written as two bytes to save space\r\n", "    write.b((byte) (Mathf.clamp(efficiency) * 255f));\r\n", "    write.b((byte) (Mathf.clamp(optionalEfficiency) * 255f));\r\n", "    // only write visibility when necessary, saving 8 bytes - implies new version\r\n", "    if (writeVisibility) {\r\n", "      write.l(visibleFlags);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public final void readBase(Reads read) {\r\n", "    // cap health by block health in case of nerfs\r\n", "    health = Math.min(read.f(), block.health);\r\n", "    byte rot = read.b();\r\n", "    team = Team.get(read.b());\r\n", "    rotation = rot & 0b01111111;\r\n", "    int moduleBits = moduleBitmask();\r\n", "    boolean legacy = true;\r\n", "    byte version = 0;\r\n", "    // new version\r\n", "    if ((rot & 0b10000000) != 0) {\r\n", "      // version of entity save\r\n", "      version = read.b();\r\n", "      if (version >= 1) {\r\n", "        byte on = read.b();\r\n", "        this.enabled = on == 1;\r\n", "      }\r\n", "      // get which modules should actually be read; this was added in version 2\r\n", "      if (version >= 2) {\r\n", "        moduleBits = read.b();\r\n", "      }\r\n", "      legacy = false;\r\n", "    }\r\n", "    if ((moduleBits & 1) != 0)\r\n", "      (items == null ? new ItemModule() : items).read(read, legacy);\r\n", "    if ((moduleBits & 2) != 0)\r\n", "      (power == null ? new PowerModule() : power).read(read, legacy);\r\n", "    if ((moduleBits & 4) != 0)\r\n", "      (liquids == null ? new LiquidModule() : liquids).read(read, legacy);\r\n", "    // unnecessary consume module read in version 2 and below\r\n", "    if (version <= 2)\r\n", "      read.bool();\r\n", "    // version 3 has efficiency numbers instead of bools\r\n", "    if (version >= 3) {\r\n", "      efficiency = potentialEfficiency = read.ub() / 255f;\r\n", "      optionalEfficiency = read.ub() / 255f;\r\n", "    }\r\n", "    // version 4 (and only 4 at the moment) has visibility flags\r\n", "    if (version == 4) {\r\n", "      visibleFlags = read.l();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public int moduleBitmask() {\r\n", "    return (items != null ? 1 : 0) | (power != null ? 2 : 0) | (liquids != null ? 4 : 0) | 8;\r\n", "  }\r\n", "\r\n", "  public void writeAll(Writes write) {\r\n", "    writeBase(write);\r\n", "    write(write);\r\n", "  }\r\n", "\r\n", "  public void readAll(Reads read, byte revision) {\r\n", "    readBase(read);\r\n", "    read(read, revision);\r\n", "  }\r\n", "\r\n", "  @CallSuper\r\n", "  public void write(Writes write) {\r\n", "    // overriden by subclasses!\r\n", "  }\r\n", "\r\n", "  @CallSuper\r\n", "  public void read(Reads read, byte revision) {\r\n", "    // overriden by subclasses!\r\n", "  }\r\n", "\r\n", "  // endregion\r\n", "  // region utility methods\r\n", "  public boolean isDiscovered(Team viewer) {\r\n", "    if (state.rules.limitMapArea && world.getDarkness(tile.x, tile.y) >= 3) {\r\n", "      return false;\r\n", "    }\r\n", "    if (viewer == null || !state.rules.staticFog || !state.rules.fog) {\r\n", "      return true;\r\n", "    }\r\n", "    if (block.size <= 2) {\r\n", "      return fogControl.isDiscovered(viewer, tile.x, tile.y);\r\n", "    } else {\r\n", "      int s = block.size / 2;\r\n", "      return fogControl.isDiscovered(viewer, tile.x, tile.y) || fogControl.isDiscovered(viewer, tile.x - s, tile.y - s) || fogControl.isDiscovered(viewer, tile.x - s, tile.y + s) || fogControl.isDiscovered(viewer, tile.x + s, tile.y + s) || fogControl.isDiscovered(viewer, tile.x + s, tile.y - s);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void addPlan(boolean checkPrevious) {\r\n", "    addPlan(checkPrevious, false);\r\n", "  }\r\n", "\r\n", "  public void addPlan(boolean checkPrevious, boolean ignoreConditions) {\r\n", "    if (!ignoreConditions && (!block.rebuildable || (team == state.rules.defaultTeam && state.isCampaign() && !block.isVisible())))\r\n", "      return;\r\n", "    Object overrideConfig = null;\r\n", "    Block toAdd = this.block;\r\n", "    if (self() instanceof ConstructBuild entity) {\r\n", "      // update block to reflect the fact that something was being constructed\r\n", "      if (entity.current != null && entity.current.synthetic() && entity.wasConstructing) {\r\n", "        toAdd = entity.current;\r\n", "        overrideConfig = entity.lastConfig;\r\n", "      } else {\r\n", "        // otherwise this was a deconstruction that was interrupted, don't want to rebuild that\r\n", "        return;\r\n", "      }\r\n", "    }\r\n", "    TeamData data = team.data();\r\n", "    if (checkPrevious) {\r\n", "      // remove existing blocks that have been placed here.\r\n", "      // painful O(n) iteration + copy\r\n", "      for (int i = 0; i < data.plans.size; i++) {\r\n", "        BlockPlan b = data.plans.get(i);\r\n", "        if (b.x == tile.x && b.y == tile.y) {\r\n", "          data.plans.removeIndex(i);\r\n", "          break;\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "    data.plans.addFirst(new BlockPlan(tile.x, tile.y, (short) rotation, toAdd.id, overrideConfig == null ? config() : overrideConfig));\r\n", "  }\r\n", "\r\n", "  @Nullable\r\n", "  public Tile findClosestEdge(Position to, Boolf<Tile> solid) {\r\n", "    Tile best = null;\r\n", "    float mindst = 0f;\r\n", "    for (var point : Edges.getEdges(block.size)) {\r\n", "      Tile other = Vars.world.tile(tile.x + point.x, tile.y + point.y);\r\n", "      if (other != null && !solid.get(other) && (best == null || to.dst2(other) < mindst)) {\r\n", "        best = other;\r\n", "        mindst = other.dst2(other);\r\n", "      }\r\n", "    }\r\n", "    return best;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Configure with the current, local player.\r\n", "   */\r\n", "  public void configure(Object value) {\r\n", "    // save last used config\r\n", "    block.lastConfig = value;\r\n", "    Call.tileConfig(player, self(), value);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Configure from a server.\r\n", "   */\r\n", "  public void configureAny(Object value) {\r\n", "    Call.tileConfig(null, self(), value);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Deselect this tile from configuration.\r\n", "   */\r\n", "  public void deselect() {\r\n", "    if (!headless && control.input.config.getSelected() == self()) {\r\n", "      control.input.config.hideConfig();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called clientside when the client taps a block to config.\r\n", "   * @return whether the configuration UI should be shown.\r\n", "   */\r\n", "  public boolean configTapped() {\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  public float calculateHeat(float[] sideHeat) {\r\n", "    return calculateHeat(sideHeat, null);\r\n", "  }\r\n", "\r\n", "  public float calculateHeat(float[] sideHeat, @Nullable IntSet cameFrom) {\r\n", "    Arrays.fill(sideHeat, 0f);\r\n", "    if (cameFrom != null)\r\n", "      cameFrom.clear();\r\n", "    float heat = 0f;\r\n", "    for (var edge : block.getEdges()) {\r\n", "      Building build = nearby(edge.x, edge.y);\r\n", "      if (build != null && build.team == team && build instanceof HeatBlock heater) {\r\n", "        // massive hack but I don't really care anymore\r\n", "        if (heater instanceof HeatConductorBuild cond) {\r\n", "          cond.updateHeat();\r\n", "        }\r\n", "        boolean split = build.block instanceof HeatConductor cond && cond.splitHeat;\r\n", "        // non-routers must face us, routers must face away - next to a redirector, they're forced to face away due to cycles anyway\r\n", "        if (!build.block.rotate || (!split && (relativeTo(build) + 2) % 4 == build.rotation) || (split && relativeTo(build) != build.rotation)) {\r\n", "          // TODO hacky\r\n", "          // if there's a cycle, ignore its heat\r\n", "          if (!(build instanceof HeatConductorBuild hc && hc.cameFrom.contains(id()))) {\r\n", "            // heat is distributed across building size\r\n", "            float add = heater.heat() / build.block.size;\r\n", "            if (split) {\r\n", "              // heat routers split heat across 3 surfaces\r\n", "              add /= 3f;\r\n", "            }\r\n", "            sideHeat[Mathf.mod(relativeTo(build), 4)] += add;\r\n", "            heat += add;\r\n", "          }\r\n", "          // register traversed cycles\r\n", "          if (cameFrom != null) {\r\n", "            cameFrom.add(build.id);\r\n", "            if (build instanceof HeatConductorBuild hc) {\r\n", "              cameFrom.addAll(hc.cameFrom);\r\n", "            }\r\n", "          }\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "    return heat;\r\n", "  }\r\n", "\r\n", "  public void applyBoost(float intensity, float duration) {\r\n", "    // do not refresh time scale when getting a weaker intensity\r\n", "    if (intensity >= this.timeScale - 0.001f) {\r\n", "      timeScaleDuration = Math.max(timeScaleDuration, duration);\r\n", "    }\r\n", "    timeScale = Math.max(timeScale, intensity);\r\n", "  }\r\n", "\r\n", "  public void applySlowdown(float intensity, float duration) {\r\n", "    // do not refresh time scale when getting a weaker intensity\r\n", "    if (intensity <= this.timeScale - 0.001f) {\r\n", "      timeScaleDuration = Math.max(timeScaleDuration, duration);\r\n", "    }\r\n", "    timeScale = Math.min(timeScale, intensity);\r\n", "  }\r\n", "\r\n", "  public void applyHealSuppression(float amount) {\r\n", "    healSuppressionTime = Math.max(healSuppressionTime, Time.time + amount);\r\n", "  }\r\n", "\r\n", "  public boolean isHealSuppressed() {\r\n", "    return block.suppressable && Time.time <= healSuppressionTime;\r\n", "  }\r\n", "\r\n", "  public void recentlyHealed() {\r\n", "    lastHealTime = Time.time;\r\n", "  }\r\n", "\r\n", "  public boolean wasRecentlyHealed(float duration) {\r\n", "    return lastHealTime + duration >= Time.time;\r\n", "  }\r\n", "\r\n", "  public boolean wasRecentlyDamaged() {\r\n", "    return lastDamageTime + recentDamageTime >= Time.time;\r\n", "  }\r\n", "\r\n", "  public Building nearby(int dx, int dy) {\r\n", "    return world.build(tile.x + dx, tile.y + dy);\r\n", "  }\r\n", "\r\n", "  public Building nearby(int rotation) {\r\n", "    switch(rotation) {\r\n", "      case 0:\r\n", "        return world.build(tile.x + 1, tile.y);\r\n", "      case 1:\r\n", "        return world.build(tile.x, tile.y + 1);\r\n", "      case 2:\r\n", "        return world.build(tile.x - 1, tile.y);\r\n", "      case 3:\r\n", "        return world.build(tile.x, tile.y - 1);\r\n", "      default:\r\n", "        return null;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public byte relativeTo(Tile tile) {\r\n", "    return relativeTo(tile.x, tile.y);\r\n", "  }\r\n", "\r\n", "  public byte relativeTo(Building build) {\r\n", "    if (Math.abs(x - build.x) > Math.abs(y - build.y)) {\r\n", "      if (x <= build.x - 1)\r\n", "        return 0;\r\n", "      if (x >= build.x + 1)\r\n", "        return 2;\r\n", "    } else {\r\n", "      if (y <= build.y - 1)\r\n", "        return 1;\r\n", "      if (y >= build.y + 1)\r\n", "        return 3;\r\n", "    }\r\n", "    return -1;\r\n", "  }\r\n", "\r\n", "  public byte relativeToEdge(Tile other) {\r\n", "    return relativeTo(Edges.getFacingEdge(other, tile));\r\n", "  }\r\n", "\r\n", "  public byte relativeTo(int cx, int cy) {\r\n", "    return tile.absoluteRelativeTo(cx, cy);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Multiblock front.\r\n", "   */\r\n", "  @Nullable\r\n", "  public Building front() {\r\n", "    int trns = block.size / 2 + 1;\r\n", "    return nearby(Geometry.d4(rotation).x * trns, Geometry.d4(rotation).y * trns);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Multiblock back.\r\n", "   */\r\n", "  @Nullable\r\n", "  public Building back() {\r\n", "    int trns = block.size / 2 + 1;\r\n", "    return nearby(Geometry.d4(rotation + 2).x * trns, Geometry.d4(rotation + 2).y * trns);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Multiblock left.\r\n", "   */\r\n", "  @Nullable\r\n", "  public Building left() {\r\n", "    int trns = block.size / 2 + 1;\r\n", "    return nearby(Geometry.d4(rotation + 1).x * trns, Geometry.d4(rotation + 1).y * trns);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Multiblock right.\r\n", "   */\r\n", "  @Nullable\r\n", "  public Building right() {\r\n", "    int trns = block.size / 2 + 1;\r\n", "    return nearby(Geometry.d4(rotation + 3).x * trns, Geometry.d4(rotation + 3).y * trns);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Any class that overrides this method and changes the value must call Vars.fogControl.forceUpdate(team).\r\n", "   */\r\n", "  public float fogRadius() {\r\n", "    return block.fogRadius;\r\n", "  }\r\n", "\r\n", "  public int pos() {\r\n", "    return tile.pos();\r\n", "  }\r\n", "\r\n", "  public float rotdeg() {\r\n", "    return rotation * 90;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return preferred rotation of main texture region to be drawn\r\n", "   */\r\n", "  public float drawrot() {\r\n", "    return block.rotate && block.rotateDraw ? rotation * 90 : 0f;\r\n", "  }\r\n", "\r\n", "  public Floor floor() {\r\n", "    return tile.floor();\r\n", "  }\r\n", "\r\n", "  public boolean interactable(Team team) {\r\n", "    return state.teams.canInteract(team, team());\r\n", "  }\r\n", "\r\n", "  public float timeScale() {\r\n", "    return timeScale;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return the building's 'warmup', a smooth value from 0 to 1.\r\n", "   * usually used for crafters and things that need to spin up before reaching full efficiency.\r\n", "   * many blocks will just return 0.\r\n", "   */\r\n", "  public float warmup() {\r\n", "    return 0f;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return total time this block has been producing something; non-crafter blocks usually return Time.time.\r\n", "   */\r\n", "  public float totalProgress() {\r\n", "    return Time.time;\r\n", "  }\r\n", "\r\n", "  public float progress() {\r\n", "    return 0f;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return whether this block is allowed to update based on team/environment\r\n", "   */\r\n", "  public boolean allowUpdate() {\r\n", "    return // check if outside map limit\r\n", "    team != Team.derelict && block.supportsEnv(state.rules.env) && (!state.rules.limitMapArea || !state.rules.disableOutsideArea || Rect.contains(state.rules.limitX, state.rules.limitY, state.rules.limitWidth, state.rules.limitHeight, tile.x, tile.y));\r\n", "  }\r\n", "\r\n", "  public BlockStatus status() {\r\n", "    if (!enabled) {\r\n", "      return BlockStatus.logicDisable;\r\n", "    }\r\n", "    if (!shouldConsume()) {\r\n", "      return BlockStatus.noOutput;\r\n", "    }\r\n", "    if (efficiency <= 0 || !productionValid()) {\r\n", "      return BlockStatus.noInput;\r\n", "    }\r\n", "    return ((state.tick / 30f) % 1f) < efficiency ? BlockStatus.active : BlockStatus.noInput;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Call when nothing is happening to the entity. This increments the internal sleep timer.\r\n", "   */\r\n", "  public void sleep() {\r\n", "    sleepTime += Time.delta;\r\n", "    if (!sleeping && sleepTime >= timeToSleep) {\r\n", "      remove();\r\n", "      sleeping = true;\r\n", "      sleepingEntities++;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Call when this entity is updating. This wakes it up.\r\n", "   */\r\n", "  public void noSleep() {\r\n", "    sleepTime = 0f;\r\n", "    if (sleeping) {\r\n", "      add();\r\n", "      sleeping = false;\r\n", "      sleepingEntities--;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Returns the version of this Building IO code.\r\n", "   */\r\n", "  public byte version() {\r\n", "    return 0;\r\n", "  }\r\n", "\r\n", "  // endregion\r\n", "  // region handler methods\r\n", "  /**\r\n", "   * @return whether the player can select (but not actually control) this building.\r\n", "   */\r\n", "  public boolean canControlSelect(Unit player) {\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when a player control-selects this building - not called for ControlBlock subclasses.\r\n", "   */\r\n", "  public void onControlSelect(Unit player) {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when this building receives a position command. Requires a commandable block.\r\n", "   */\r\n", "  public void onCommand(Vec2 target) {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return the position that this block points to for commands, or null.\r\n", "   */\r\n", "  @Nullable\r\n", "  public Vec2 getCommandPosition() {\r\n", "    return null;\r\n", "  }\r\n", "\r\n", "  public void handleUnitPayload(Unit unit, Cons<Payload> grabber) {\r\n", "    Fx.spawn.at(unit);\r\n", "    if (unit.isPlayer()) {\r\n", "      unit.getPlayer().clearUnit();\r\n", "    }\r\n", "    unit.remove();\r\n", "    // needs new ID as it is now a payload\r\n", "    if (net.client()) {\r\n", "      unit.id = EntityGroup.nextId();\r\n", "    } else {\r\n", "      // server-side, this needs to be delayed until next frame because otherwise the packets sent out right after this event would have the wrong unit ID, leading to ghosts\r\n", "      Core.app.post(() -> unit.id = EntityGroup.nextId());\r\n", "    }\r\n", "    grabber.get(new UnitPayload(unit));\r\n", "    Fx.unitDrop.at(unit);\r\n", "  }\r\n", "\r\n", "  public boolean canWithdraw() {\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  public boolean canUnload() {\r\n", "    return block.unloadable;\r\n", "  }\r\n", "\r\n", "  public boolean canResupply() {\r\n", "    return block.allowResupply;\r\n", "  }\r\n", "\r\n", "  public boolean payloadCheck(int conveyorRotation) {\r\n", "    return block.rotate && (rotation + 2) % 4 == conveyorRotation;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when an unloader takes an item.\r\n", "   */\r\n", "  public void itemTaken(Item item) {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when this block is dropped as a payload.\r\n", "   */\r\n", "  public void dropped() {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * This is for logic blocks.\r\n", "   */\r\n", "  public void handleString(Object value) {\r\n", "  }\r\n", "\r\n", "  public void created() {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return whether this block is currently \"active\" and should be consuming requirements.\r\n", "   */\r\n", "  public boolean shouldConsume() {\r\n", "    return enabled;\r\n", "  }\r\n", "\r\n", "  public boolean productionValid() {\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return whether this building is currently \"burning\" a trigger consumer (an item) - if true, valid() on those will return true.\r\n", "   */\r\n", "  public boolean consumeTriggerValid() {\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  public float getPowerProduction() {\r\n", "    return 0f;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Returns the amount of items this block can accept.\r\n", "   */\r\n", "  public int acceptStack(Item item, int amount, Teamc source) {\r\n", "    if (acceptItem(self(), item) && block.hasItems && (source == null || source.team() == team)) {\r\n", "      return Math.min(getMaximumAccepted(item) - items.get(item), amount);\r\n", "    } else {\r\n", "      return 0;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public int getMaximumAccepted(Item item) {\r\n", "    return block.itemCapacity;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Remove a stack from this inventory, and return the amount removed.\r\n", "   */\r\n", "  public int removeStack(Item item, int amount) {\r\n", "    if (items == null)\r\n", "      return 0;\r\n", "    amount = Math.min(amount, items.get(item));\r\n", "    noSleep();\r\n", "    items.remove(item, amount);\r\n", "    return amount;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Handle a stack input.\r\n", "   */\r\n", "  public void handleStack(Item item, int amount, @Nullable Teamc source) {\r\n", "    noSleep();\r\n", "    items.add(item, amount);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Returns offset for stack placement.\r\n", "   */\r\n", "  public void getStackOffset(Item item, Vec2 trns) {\r\n", "  }\r\n", "\r\n", "  public boolean acceptPayload(Building source, Payload payload) {\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  public void handlePayload(Building source, Payload payload) {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Tries moving a payload forwards.\r\n", "   * @param todump payload to dump.\r\n", "   * @return whether the payload was moved successfully\r\n", "   */\r\n", "  public boolean movePayload(Payload todump) {\r\n", "    int trns = block.size / 2 + 1;\r\n", "    Tile next = tile.nearby(Geometry.d4(rotation).x * trns, Geometry.d4(rotation).y * trns);\r\n", "    if (next != null && next.build != null && next.build.team == team && next.build.acceptPayload(self(), todump)) {\r\n", "      next.build.handlePayload(self(), todump);\r\n", "      return true;\r\n", "    }\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Tries dumping a payload to any adjacent block.\r\n", "   * @param todump payload to dump.\r\n", "   * @return whether the payload was moved successfully\r\n", "   */\r\n", "  public boolean dumpPayload(Payload todump) {\r\n", "    if (proximity.size == 0)\r\n", "      return false;\r\n", "    int dump = this.cdump;\r\n", "    for (int i = 0; i < proximity.size; i++) {\r\n", "      Building other = proximity.get((i + dump) % proximity.size);\r\n", "      if (other.acceptPayload(self(), todump)) {\r\n", "        other.handlePayload(self(), todump);\r\n", "        incrementDump(proximity.size);\r\n", "        return true;\r\n", "      }\r\n", "      incrementDump(proximity.size);\r\n", "    }\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  public void handleItem(Building source, Item item) {\r\n", "    items.add(item, 1);\r\n", "  }\r\n", "\r\n", "  public boolean acceptItem(Building source, Item item) {\r\n", "    return block.consumesItem(item) && items.get(item) < getMaximumAccepted(item);\r\n", "  }\r\n", "\r\n", "  public boolean acceptLiquid(Building source, Liquid liquid) {\r\n", "    return block.hasLiquids && block.consumesLiquid(liquid);\r\n", "  }\r\n", "\r\n", "  public void handleLiquid(Building source, Liquid liquid, float amount) {\r\n", "    liquids.add(liquid, amount);\r\n", "  }\r\n", "\r\n", "  // TODO entire liquid system is awful\r\n", "  public void dumpLiquid(Liquid liquid) {\r\n", "    dumpLiquid(liquid, 2f);\r\n", "  }\r\n", "\r\n", "  public void dumpLiquid(Liquid liquid, float scaling) {\r\n", "    dumpLiquid(liquid, scaling, -1);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @param outputDir output liquid direction relative to rotation, or -1 to use any direction.\r\n", "   */\r\n", "  public void dumpLiquid(Liquid liquid, float scaling, int outputDir) {\r\n", "    int dump = this.cdump;\r\n", "    if (liquids.get(liquid) <= 0.0001f)\r\n", "      return;\r\n", "    if (!net.client() && state.isCampaign() && team == state.rules.defaultTeam)\r\n", "      liquid.unlock();\r\n", "    for (int i = 0; i < proximity.size; i++) {\r\n", "      incrementDump(proximity.size);\r\n", "      Building other = proximity.get((i + dump) % proximity.size);\r\n", "      if (outputDir != -1 && (outputDir + rotation) % 4 != relativeTo(other))\r\n", "        continue;\r\n", "      other = other.getLiquidDestination(self(), liquid);\r\n", "      if (other != null && other.block.hasLiquids && canDumpLiquid(other, liquid) && other.liquids != null) {\r\n", "        float ofract = other.liquids.get(liquid) / other.block.liquidCapacity;\r\n", "        float fract = liquids.get(liquid) / block.liquidCapacity;\r\n", "        if (ofract < fract)\r\n", "          transferLiquid(other, (fract - ofract) * block.liquidCapacity / scaling, liquid);\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public boolean canDumpLiquid(Building to, Liquid liquid) {\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  public void transferLiquid(Building next, float amount, Liquid liquid) {\r\n", "    float flow = Math.min(next.block.liquidCapacity - next.liquids.get(liquid), amount);\r\n", "    if (next.acceptLiquid(self(), liquid)) {\r\n", "      next.handleLiquid(self(), liquid, flow);\r\n", "      liquids.remove(liquid, flow);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public float moveLiquidForward(boolean leaks, Liquid liquid) {\r\n", "    Tile next = tile.nearby(rotation);\r\n", "    if (next == null)\r\n", "      return 0;\r\n", "    if (next.build != null) {\r\n", "      return moveLiquid(next.build, liquid);\r\n", "    } else if (leaks && !next.block().solid && !next.block().hasLiquids) {\r\n", "      float leakAmount = liquids.get(liquid) / 1.5f;\r\n", "      Puddles.deposit(next, tile, liquid, leakAmount, true, true);\r\n", "      liquids.remove(liquid, leakAmount);\r\n", "    }\r\n", "    return 0;\r\n", "  }\r\n", "\r\n", "  public float moveLiquid(Building next, Liquid liquid) {\r\n", "    if (next == null)\r\n", "      return 0;\r\n", "    next = next.getLiquidDestination(self(), liquid);\r\n", "    if (next.team == team && next.block.hasLiquids && liquids.get(liquid) > 0f) {\r\n", "      float ofract = next.liquids.get(liquid) / next.block.liquidCapacity;\r\n", "      float fract = liquids.get(liquid) / block.liquidCapacity * block.liquidPressure;\r\n", "      float flow = Math.min(Mathf.clamp((fract - ofract)) * (block.liquidCapacity), liquids.get(liquid));\r\n", "      flow = Math.min(flow, next.block.liquidCapacity - next.liquids.get(liquid));\r\n", "      if (flow > 0f && ofract <= fract && next.acceptLiquid(self(), liquid)) {\r\n", "        next.handleLiquid(self(), liquid, flow);\r\n", "        liquids.remove(liquid, flow);\r\n", "        return flow;\r\n", "        // handle reactions between different liquid types ▼\r\n", "      } else if (!next.block.consumesLiquid(liquid) && next.liquids.currentAmount() / next.block.liquidCapacity > 0.1f && fract > 0.1f) {\r\n", "        // TODO !IMPORTANT! uses current(), which is 1) wrong for multi-liquid blocks and 2) causes unwanted reactions, e.g. hydrogen + slag in pump\r\n", "        // TODO these are incorrect effect positions\r\n", "        float fx = (x + next.x) / 2f, fy = (y + next.y) / 2f;\r\n", "        Liquid other = next.liquids.current();\r\n", "        if (other.blockReactive && liquid.blockReactive) {\r\n", "          // TODO liquid reaction handler for extensibility\r\n", "          if ((other.flammability > 0.3f && liquid.temperature > 0.7f) || (liquid.flammability > 0.3f && other.temperature > 0.7f)) {\r\n", "            damageContinuous(1);\r\n", "            next.damageContinuous(1);\r\n", "            if (Mathf.chanceDelta(0.1)) {\r\n", "              Fx.fire.at(fx, fy);\r\n", "            }\r\n", "          } else if ((liquid.temperature > 0.7f && other.temperature < 0.55f) || (other.temperature > 0.7f && liquid.temperature < 0.55f)) {\r\n", "            liquids.remove(liquid, Math.min(liquids.get(liquid), 0.7f * Time.delta));\r\n", "            if (Mathf.chanceDelta(0.2f)) {\r\n", "              Fx.steam.at(fx, fy);\r\n", "            }\r\n", "          }\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "    return 0;\r\n", "  }\r\n", "\r\n", "  public Building getLiquidDestination(Building from, Liquid liquid) {\r\n", "    return self();\r\n", "  }\r\n", "\r\n", "  @Nullable\r\n", "  public Payload getPayload() {\r\n", "    return null;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Tries to take the payload. Returns null if no payload is present.\r\n", "   */\r\n", "  @Nullable\r\n", "  public Payload takePayload() {\r\n", "    return null;\r\n", "  }\r\n", "\r\n", "  @Nullable\r\n", "  public PayloadSeq getPayloads() {\r\n", "    return null;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Tries to put this item into a nearby container, if there are no available\r\n", "   * containers, it gets added to the block's inventory.\r\n", "   */\r\n", "  public void offload(Item item) {\r\n", "    produced(item, 1);\r\n", "    int dump = this.cdump;\r\n", "    for (int i = 0; i < proximity.size; i++) {\r\n", "      incrementDump(proximity.size);\r\n", "      Building other = proximity.get((i + dump) % proximity.size);\r\n", "      if (other.acceptItem(self(), item) && canDump(other, item)) {\r\n", "        other.handleItem(self(), item);\r\n", "        return;\r\n", "      }\r\n", "    }\r\n", "    handleItem(self(), item);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Tries to put this item into a nearby container. Returns success. Unlike #offload(), this method does not change the block inventory.\r\n", "   */\r\n", "  public boolean put(Item item) {\r\n", "    int dump = this.cdump;\r\n", "    for (int i = 0; i < proximity.size; i++) {\r\n", "      incrementDump(proximity.size);\r\n", "      Building other = proximity.get((i + dump) % proximity.size);\r\n", "      if (other.acceptItem(self(), item) && canDump(other, item)) {\r\n", "        other.handleItem(self(), item);\r\n", "        return true;\r\n", "      }\r\n", "    }\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  public void produced(Item item) {\r\n", "    produced(item, 1);\r\n", "  }\r\n", "\r\n", "  public void produced(Item item, int amount) {\r\n", "    if (Vars.state.rules.sector != null && team == state.rules.defaultTeam) {\r\n", "      Vars.state.rules.sector.info.handleProduction(item, amount);\r\n", "      if (!net.client())\r\n", "        item.unlock();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Dumps any item with an accumulator. May dump multiple times per frame. Use with care.\r\n", "   */\r\n", "  public boolean dumpAccumulate() {\r\n", "    return dumpAccumulate(null);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Dumps any item with an accumulator. May dump multiple times per frame. Use with care.\r\n", "   */\r\n", "  public boolean dumpAccumulate(Item item) {\r\n", "    boolean res = false;\r\n", "    dumpAccum += delta();\r\n", "    while (dumpAccum >= 1f) {\r\n", "      res |= dump(item);\r\n", "      dumpAccum -= 1f;\r\n", "    }\r\n", "    return res;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Try dumping any item near the building.\r\n", "   */\r\n", "  public boolean dump() {\r\n", "    return dump(null);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Try dumping a specific item near the building.\r\n", "   * @param todump Item to dump. Can be null to dump anything.\r\n", "   */\r\n", "  public boolean dump(Item todump) {\r\n", "    if (!block.hasItems || items.total() == 0 || proximity.size == 0 || (todump != null && !items.has(todump)))\r\n", "      return false;\r\n", "    int dump = this.cdump;\r\n", "    var allItems = content.items();\r\n", "    int itemSize = allItems.size;\r\n", "    Object[] itemArray = allItems.items;\r\n", "    for (int i = 0; i < proximity.size; i++) {\r\n", "      Building other = proximity.get((i + dump) % proximity.size);\r\n", "      if (todump == null) {\r\n", "        for (int ii = 0; ii < itemSize; ii++) {\r\n", "          if (!items.has(ii))\r\n", "            continue;\r\n", "          Item item = (Item) itemArray[ii];\r\n", "          if (other.acceptItem(self(), item) && canDump(other, item)) {\r\n", "            other.handleItem(self(), item);\r\n", "            items.remove(item, 1);\r\n", "            incrementDump(proximity.size);\r\n", "            return true;\r\n", "          }\r\n", "        }\r\n", "      } else {\r\n", "        if (other.acceptItem(self(), todump) && canDump(other, todump)) {\r\n", "          other.handleItem(self(), todump);\r\n", "          items.remove(todump, 1);\r\n", "          incrementDump(proximity.size);\r\n", "          return true;\r\n", "        }\r\n", "      }\r\n", "      incrementDump(proximity.size);\r\n", "    }\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  public void incrementDump(int prox) {\r\n", "    cdump = ((cdump + 1) % prox);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Used for dumping items.\r\n", "   */\r\n", "  public boolean canDump(Building to, Item item) {\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Try offloading an item to a nearby container in its facing direction. Returns true if success.\r\n", "   */\r\n", "  public boolean moveForward(Item item) {\r\n", "    Building other = front();\r\n", "    if (other != null && other.team == team && other.acceptItem(self(), item)) {\r\n", "      other.handleItem(self(), item);\r\n", "      return true;\r\n", "    }\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called shortly before this building is removed.\r\n", "   */\r\n", "  public void onProximityRemoved() {\r\n", "    if (power != null) {\r\n", "      powerGraphRemoved();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called after this building is created in the world. May be called multiple times, or when adjacent buildings change.\r\n", "   */\r\n", "  public void onProximityAdded() {\r\n", "    if (power != null) {\r\n", "      updatePowerGraph();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when anything adjacent to this building is placed/removed, including itself.\r\n", "   */\r\n", "  public void onProximityUpdate() {\r\n", "    noSleep();\r\n", "  }\r\n", "\r\n", "  public void updatePowerGraph() {\r\n", "    for (Building other : getPowerConnections(tempBuilds)) {\r\n", "      if (other.power != null) {\r\n", "        other.power.graph.addGraph(power.graph);\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void powerGraphRemoved() {\r\n", "    if (power == null)\r\n", "      return;\r\n", "    power.graph.remove(self());\r\n", "    for (int i = 0; i < power.links.size; i++) {\r\n", "      Tile other = world.tile(power.links.get(i));\r\n", "      if (other != null && other.build != null && other.build.power != null) {\r\n", "        other.build.power.links.removeValue(pos());\r\n", "      }\r\n", "    }\r\n", "    power.links.clear();\r\n", "  }\r\n", "\r\n", "  public boolean conductsTo(Building other) {\r\n", "    return !block.insulated;\r\n", "  }\r\n", "\r\n", "  public Seq<Building> getPowerConnections(Seq<Building> out) {\r\n", "    out.clear();\r\n", "    if (power == null)\r\n", "      return out;\r\n", "    for (Building other : proximity) {\r\n", "      if (other != null && other.power != null && other.team == team && !(block.consumesPower && other.block.consumesPower && !block.outputsPower && !other.block.outputsPower && !block.conductivePower && !other.block.conductivePower) && conductsTo(other) && other.conductsTo(self()) && !power.links.contains(other.pos())) {\r\n", "        out.add(other);\r\n", "      }\r\n", "    }\r\n", "    for (int i = 0; i < power.links.size; i++) {\r\n", "      Tile link = world.tile(power.links.get(i));\r\n", "      if (link != null && link.build != null && link.build.power != null && link.build.team == team)\r\n", "        out.add(link.build);\r\n", "    }\r\n", "    return out;\r\n", "  }\r\n", "\r\n", "  public float getProgressIncrease(float baseTime) {\r\n", "    return 1f / baseTime * edelta();\r\n", "  }\r\n", "\r\n", "  public float getDisplayEfficiency() {\r\n", "    return getProgressIncrease(1f) / edelta();\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return whether this block should play its active sound.\r\n", "   */\r\n", "  public boolean shouldActiveSound() {\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return volume cale of active sound.\r\n", "   */\r\n", "  public float activeSoundVolume() {\r\n", "    return 1f;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return whether this block should play its idle sound.\r\n", "   */\r\n", "  public boolean shouldAmbientSound() {\r\n", "    return shouldConsume();\r\n", "  }\r\n", "\r\n", "  public void drawStatus() {\r\n", "    if (block.enableDrawStatus && block.consumers.length > 0) {\r\n", "      float multiplier = block.size > 1 ? 1 : 0.64f;\r\n", "      float brcx = x + (block.size * tilesize / 2f) - (tilesize * multiplier / 2f);\r\n", "      float brcy = y - (block.size * tilesize / 2f) + (tilesize * multiplier / 2f);\r\n", "      Draw.z(Layer.power + 1);\r\n", "      Draw.color(Pal.gray);\r\n", "      Fill.square(brcx, brcy, 2.5f * multiplier, 45);\r\n", "      Draw.color(status().color);\r\n", "      Fill.square(brcx, brcy, 1.5f * multiplier, 45);\r\n", "      Draw.color();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void drawCracks() {\r\n", "    if (!block.drawCracks || !damaged() || block.size > BlockRenderer.maxCrackSize)\r\n", "      return;\r\n", "    int id = pos();\r\n", "    TextureRegion region = renderer.blocks.cracks[block.size - 1][Mathf.clamp((int) ((1f - healthf()) * BlockRenderer.crackRegions), 0, BlockRenderer.crackRegions - 1)];\r\n", "    Draw.colorl(0.2f, 0.1f + (1f - healthf()) * 0.6f);\r\n", "    // TODO could be random, flipped, pseudorandom, etc\r\n", "    Draw.rect(region, x, y, (id % 4) * 90);\r\n", "    Draw.color();\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Draw the block overlay that is shown when a cursor is over the block.\r\n", "   */\r\n", "  public void drawSelect() {\r\n", "    block.drawOverlay(x, y, rotation);\r\n", "  }\r\n", "\r\n", "  public void drawDisabled() {\r\n", "    Draw.color(Color.scarlet);\r\n", "    Draw.alpha(0.8f);\r\n", "    float size = 6f;\r\n", "    Draw.rect(Icon.cancel.getRegion(), x, y, size, size);\r\n", "    Draw.reset();\r\n", "  }\r\n", "\r\n", "  public void draw() {\r\n", "    if (block.variants == 0 || block.variantRegions == null) {\r\n", "      Draw.rect(block.region, x, y, drawrot());\r\n", "    } else {\r\n", "      Draw.rect(block.variantRegions[Mathf.randomSeed(tile.pos(), 0, Math.max(0, block.variantRegions.length - 1))], x, y, drawrot());\r\n", "    }\r\n", "    drawTeamTop();\r\n", "  }\r\n", "\r\n", "  public void payloadDraw() {\r\n", "    draw();\r\n", "  }\r\n", "\r\n", "  public void drawTeamTop() {\r\n", "    if (block.teamRegion.found()) {\r\n", "      if (block.teamRegions[team.id] == block.teamRegion)\r\n", "        Draw.color(team.color);\r\n", "      Draw.rect(block.teamRegions[team.id], x, y);\r\n", "      Draw.color();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void drawLight() {\r\n", "    Liquid liq = block.hasLiquids && block.lightLiquid == null ? liquids.current() : block.lightLiquid;\r\n", "    if (block.hasLiquids && block.drawLiquidLight && liq.lightColor.a > 0.001f) {\r\n", "      // yes, I am updating in draw()... but this is purely visual anyway, better have it here than in update() where it wastes time\r\n", "      visualLiquid = Mathf.lerpDelta(visualLiquid, liquids.get(liq) >= 0.01f ? 1f : 0f, 0.06f);\r\n", "      drawLiquidLight(liq, visualLiquid);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void drawLiquidLight(Liquid liquid, float amount) {\r\n", "    if (amount > 0.01f) {\r\n", "      Color color = liquid.lightColor;\r\n", "      float fract = 1f;\r\n", "      float opacity = color.a * fract;\r\n", "      if (opacity > 0.001f) {\r\n", "        Drawf.light(x, y, block.size * 30f * fract, color, opacity * amount);\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void drawTeam() {\r\n", "    Draw.color(team.color);\r\n", "    Draw.rect(\"block-border\", x - block.size * tilesize / 2f + 4, y - block.size * tilesize / 2f + 4);\r\n", "    Draw.color();\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return whether a building has regen/healing suppressed; if so, spawns particles on it.\r\n", "   */\r\n", "  public boolean checkSuppression() {\r\n", "    if (isHealSuppressed()) {\r\n", "      if (Mathf.chanceDelta(0.03)) {\r\n", "        Fx.regenSuppressParticle.at(x + Mathf.range(block.size * tilesize / 2f - 1f), y + Mathf.range(block.size * tilesize / 2f - 1f));\r\n", "      }\r\n", "      return true;\r\n", "    }\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called after the block is placed by this client.\r\n", "   */\r\n", "  @CallSuper\r\n", "  public void playerPlaced(Object config) {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called after the block is placed by anyone.\r\n", "   */\r\n", "  @CallSuper\r\n", "  public void placed() {\r\n", "    if (net.client())\r\n", "      return;\r\n", "    if ((block.consumesPower || block.outputsPower) && block.hasPower && block.connectedPower) {\r\n", "      PowerNode.getNodeLinks(tile, block, team, other -> {\r\n", "        if (!other.power.links.contains(pos())) {\r\n", "          other.configureAny(pos());\r\n", "        }\r\n", "      });\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return whether this building is in a payload\r\n", "   */\r\n", "  public boolean isPayload() {\r\n", "    return tile == emptyTile;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when a block is placed over some other blocks. This seq will always have at least one item.\r\n", "   * Should load some previous state, if necessary.\r\n", "   */\r\n", "  public void overwrote(Seq<Building> previous) {\r\n", "  }\r\n", "\r\n", "  public void onRemoved() {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called every frame a unit is on this\r\n", "   */\r\n", "  public void unitOn(Unit unit) {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when a unit that spawned at this tile is removed.\r\n", "   */\r\n", "  public void unitRemoved(Unit unit) {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when arbitrary configuration is applied to a tile.\r\n", "   */\r\n", "  public void configured(@Nullable Unit builder, @Nullable Object value) {\r\n", "    // null is of type void.class; anonymous classes use their superclass.\r\n", "    Class<?> type = value == null ? void.class : value.getClass().isAnonymousClass() ? value.getClass().getSuperclass() : value.getClass();\r\n", "    if (value instanceof Item)\r\n", "      type = Item.class;\r\n", "    if (value instanceof Block)\r\n", "      type = Block.class;\r\n", "    if (value instanceof Liquid)\r\n", "      type = Liquid.class;\r\n", "    if (value instanceof UnitType)\r\n", "      type = UnitType.class;\r\n", "    if (builder != null && builder.isPlayer()) {\r\n", "      lastAccessed = builder.getPlayer().coloredName();\r\n", "    }\r\n", "    if (block.configurations.containsKey(type)) {\r\n", "      block.configurations.get(type).get(this, value);\r\n", "    } else if (value instanceof Building build) {\r\n", "      // copy config of another building\r\n", "      var conf = build.config();\r\n", "      if (conf != null && !(conf instanceof Building)) {\r\n", "        configured(builder, conf);\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when the block is tapped by the local player.\r\n", "   */\r\n", "  public void tapped() {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called *after* the tile has been removed.\r\n", "   */\r\n", "  public void afterDestroyed() {\r\n", "    if (block.destroyBullet != null) {\r\n", "      // I really do not like that the bullet will not destroy derelict\r\n", "      // but I can't do anything about it without using a random team\r\n", "      // which may or may not cause issues with servers and js\r\n", "      block.destroyBullet.create(this, Team.derelict, x, y, 0);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return the cap for item amount calculations, used when this block explodes.\r\n", "   */\r\n", "  public int explosionItemCap() {\r\n", "    return block.itemCapacity;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when the block is destroyed. The tile is still intact at this stage.\r\n", "   */\r\n", "  public void onDestroyed() {\r\n", "    float explosiveness = block.baseExplosiveness;\r\n", "    float flammability = 0f;\r\n", "    float power = 0f;\r\n", "    if (block.hasItems) {\r\n", "      for (Item item : content.items()) {\r\n", "        int amount = Math.min(items.get(item), explosionItemCap());\r\n", "        explosiveness += item.explosiveness * amount;\r\n", "        flammability += item.flammability * amount;\r\n", "        power += item.charge * Mathf.pow(amount, 1.1f) * 150f;\r\n", "      }\r\n", "    }\r\n", "    if (block.hasLiquids) {\r\n", "      flammability += liquids.sum((liquid, amount) -> liquid.flammability * amount / 2f);\r\n", "      explosiveness += liquids.sum((liquid, amount) -> liquid.explosiveness * amount / 2f);\r\n", "    }\r\n", "    if (block.consPower != null && block.consPower.buffered) {\r\n", "      power += this.power.status * block.consPower.capacity;\r\n", "    }\r\n", "    if (block.hasLiquids && state.rules.damageExplosions) {\r\n", "      liquids.each((liquid, amount) -> {\r\n", "        float splash = Mathf.clamp(amount / 4f, 0f, 10f);\r\n", "        for (int i = 0; i < Mathf.clamp(amount / 5, 0, 30); i++) {\r\n", "          Time.run(i / 2f, () -> {\r\n", "            Tile other = world.tileWorld(x + Mathf.range(block.size * tilesize / 2), y + Mathf.range(block.size * tilesize / 2));\r\n", "            if (other != null) {\r\n", "              Puddles.deposit(other, liquid, splash);\r\n", "            }\r\n", "          });\r\n", "        }\r\n", "      });\r\n", "    }\r\n", "    Damage.dynamicExplosion(x, y, flammability, explosiveness * 3.5f, power, tilesize * block.size / 2f, state.rules.damageExplosions, block.destroyEffect);\r\n", "    if (block.createRubble && !floor().solid && !floor().isLiquid) {\r\n", "      Effect.rubble(x, y, block.size);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public String getDisplayName() {\r\n", "    // derelict team icon currently doesn't display\r\n", "    return team == Team.derelict ? block.localizedName + \"\\n\" + Core.bundle.get(\"block.derelict\") : block.localizedName + (team == player.team() || team.emoji.isEmpty() ? \"\" : \" \" + team.emoji);\r\n", "  }\r\n", "\r\n", "  public TextureRegion getDisplayIcon() {\r\n", "    return block.uiIcon;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return the item module to use for flow rate calculations\r\n", "   */\r\n", "  public ItemModule flowItems() {\r\n", "    return items;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void display(Table table) {\r\n", "    // display the block stuff\r\n", "    // TODO duplicated code?\r\n", "    table.table(t -> {\r\n", "      t.left();\r\n", "      t.add(new Image(block.getDisplayIcon(tile))).size(8 * 4);\r\n", "      t.labelWrap(block.getDisplayName(tile)).left().width(190f).padLeft(5);\r\n", "    }).growX().left();\r\n", "    table.row();\r\n", "    // only display everything else if the team is the same\r\n", "    if (team == player.team()) {\r\n", "      table.table(bars -> {\r\n", "        bars.defaults().growX().height(18f).pad(4);\r\n", "        displayBars(bars);\r\n", "      }).growX();\r\n", "      table.row();\r\n", "      table.table(this::displayConsumption).growX();\r\n", "      boolean displayFlow = (block.category == Category.distribution || block.category == Category.liquid) && block.displayFlow;\r\n", "      if (displayFlow) {\r\n", "        String ps = \" \" + StatUnit.perSecond.localized();\r\n", "        var flowItems = flowItems();\r\n", "        if (flowItems != null) {\r\n", "          table.row();\r\n", "          table.left();\r\n", "          table.table(l -> {\r\n", "            Bits current = new Bits();\r\n", "            Runnable rebuild = () -> {\r\n", "              l.clearChildren();\r\n", "              l.left();\r\n", "              for (Item item : content.items()) {\r\n", "                if (flowItems.hasFlowItem(item)) {\r\n", "                  l.image(item.uiIcon).scaling(Scaling.fit).padRight(3f);\r\n", "                  l.label(() -> flowItems.getFlowRate(item) < 0 ? \"...\" : Strings.fixed(flowItems.getFlowRate(item), 1) + ps).color(Color.lightGray);\r\n", "                  l.row();\r\n", "                }\r\n", "              }\r\n", "            };\r\n", "            rebuild.run();\r\n", "            l.update(() -> {\r\n", "              for (Item item : content.items()) {\r\n", "                if (flowItems.hasFlowItem(item) && !current.get(item.id)) {\r\n", "                  current.set(item.id);\r\n", "                  rebuild.run();\r\n", "                }\r\n", "              }\r\n", "            });\r\n", "          }).left();\r\n", "        }\r\n", "        if (liquids != null) {\r\n", "          table.row();\r\n", "          table.left();\r\n", "          table.table(l -> {\r\n", "            Bits current = new Bits();\r\n", "            Runnable rebuild = () -> {\r\n", "              l.clearChildren();\r\n", "              l.left();\r\n", "              for (var liquid : content.liquids()) {\r\n", "                if (liquids.hasFlowLiquid(liquid)) {\r\n", "                  l.image(liquid.uiIcon).scaling(Scaling.fit).size(32f).padRight(3f);\r\n", "                  l.label(() -> liquids.getFlowRate(liquid) < 0 ? \"...\" : Strings.fixed(liquids.getFlowRate(liquid), 1) + ps).color(Color.lightGray);\r\n", "                  l.row();\r\n", "                }\r\n", "              }\r\n", "            };\r\n", "            rebuild.run();\r\n", "            l.update(() -> {\r\n", "              for (var liquid : content.liquids()) {\r\n", "                if (liquids.hasFlowLiquid(liquid) && !current.get(liquid.id)) {\r\n", "                  current.set(liquid.id);\r\n", "                  rebuild.run();\r\n", "                }\r\n", "              }\r\n", "            });\r\n", "          }).left();\r\n", "        }\r\n", "      }\r\n", "      if (net.active() && lastAccessed != null) {\r\n", "        table.row();\r\n", "        table.add(Core.bundle.format(\"lastaccessed\", lastAccessed)).growX().wrap().left();\r\n", "      }\r\n", "      table.marginBottom(-5);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void displayConsumption(Table table) {\r\n", "    table.left();\r\n", "    for (Consume cons : block.consumers) {\r\n", "      if (cons.optional && cons.booster)\r\n", "        continue;\r\n", "      cons.build(self(), table);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void displayBars(Table table) {\r\n", "    for (Func<Building, Bar> bar : block.listBars()) {\r\n", "      var result = bar.get(self());\r\n", "      if (result == null)\r\n", "        continue;\r\n", "      table.add(result).growX();\r\n", "      table.row();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when this block is tapped to build a UI on the table.\r\n", "   * configurable must be true for this to be called.\r\n", "   */\r\n", "  public void buildConfiguration(Table table) {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Update table alignment after configuring.\r\n", "   */\r\n", "  public void updateTableAlign(Table table) {\r\n", "    Vec2 pos = Core.input.mouseScreen(x, y - block.size * tilesize / 2f - 1);\r\n", "    table.setPosition(pos.x, pos.y, Align.top);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Returns whether a hand cursor should be shown over this block.\r\n", "   */\r\n", "  public Cursor getCursor() {\r\n", "    return block.configurable && interactable(player.team()) ? SystemCursor.hand : SystemCursor.arrow;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when another tile is tapped while this building is selected.\r\n", "   * @return whether this block should be deselected.\r\n", "   */\r\n", "  public boolean onConfigureBuildTapped(Building other) {\r\n", "    if (block.clearOnDoubleTap) {\r\n", "      if (self() == other) {\r\n", "        deselect();\r\n", "        configure(null);\r\n", "        return false;\r\n", "      }\r\n", "      return true;\r\n", "    }\r\n", "    return self() != other;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when a position is tapped while this building is selected.\r\n", "   *\r\n", "   * @return whether the tap event is consumed - if true, the player will not start shooting or interact with things under the cursor.\r\n", "   */\r\n", "  public boolean onConfigureTapped(float x, float y) {\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called when this block's config menu is closed.\r\n", "   */\r\n", "  public void onConfigureClosed() {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Returns whether this config menu should show when the specified player taps it.\r\n", "   */\r\n", "  public boolean shouldShowConfigure(Player player) {\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Whether this configuration should be hidden now. Called every frame the config is open.\r\n", "   */\r\n", "  public boolean shouldHideConfigure(Player player) {\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  public void drawConfigure() {\r\n", "    Draw.color(Pal.accent);\r\n", "    Lines.stroke(1f);\r\n", "    Lines.square(x, y, block.size * tilesize / 2f + 1f);\r\n", "    Draw.reset();\r\n", "  }\r\n", "\r\n", "  public boolean checkSolid() {\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  public float handleDamage(float amount) {\r\n", "    return amount;\r\n", "  }\r\n", "\r\n", "  public boolean absorbLasers() {\r\n", "    return block.absorbLasers;\r\n", "  }\r\n", "\r\n", "  public boolean isInsulated() {\r\n", "    return block.insulated;\r\n", "  }\r\n", "\r\n", "  public boolean collide(Bullet other) {\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Handle a bullet collision.\r\n", "   * @return whether the bullet should be removed.\r\n", "   */\r\n", "  public boolean collision(Bullet other) {\r\n", "    boolean wasDead = health <= 0;\r\n", "    float damage = other.damage() * other.type().buildingDamageMultiplier;\r\n", "    if (!other.type.pierceArmor) {\r\n", "      damage = Damage.applyArmor(damage, block.armor);\r\n", "    }\r\n", "    damage(other.team, damage);\r\n", "    Events.fire(bulletDamageEvent.set(self(), other));\r\n", "    if (health <= 0 && !wasDead) {\r\n", "      Events.fire(new BuildingBulletDestroyEvent(self(), other));\r\n", "    }\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Used to handle damage from splash damage for certain types of blocks.\r\n", "   */\r\n", "  public void damage(@Nullable Team source, float damage) {\r\n", "    damage(damage);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Handles splash damage with a bullet source.\r\n", "   */\r\n", "  public void damage(Bullet bullet, Team source, float damage) {\r\n", "    damage(source, damage);\r\n", "    Events.fire(bulletDamageEvent.set(self(), bullet));\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Changes this building's team in a safe manner.\r\n", "   */\r\n", "  public void changeTeam(Team next) {\r\n", "    if (this.team == next)\r\n", "      return;\r\n", "    Team last = this.team;\r\n", "    boolean was = isValid();\r\n", "    if (was)\r\n", "      indexer.removeIndex(tile);\r\n", "    this.team = next;\r\n", "    if (was) {\r\n", "      indexer.addIndex(tile);\r\n", "      Events.fire(teamChangeEvent.set(last, self()));\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public boolean canPickup() {\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called right before this building is picked up.\r\n", "   */\r\n", "  public void pickedUp() {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called right after this building is picked up.\r\n", "   */\r\n", "  public void afterPickedUp() {\r\n", "    if (power != null) {\r\n", "      // TODO can lead to ghost graphs?\r\n", "      power.graph = new PowerGraph();\r\n", "      power.links.clear();\r\n", "      if (block.consPower != null && !block.consPower.buffered) {\r\n", "        power.status = 0f;\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void removeFromProximity() {\r\n", "    onProximityRemoved();\r\n", "    tmpTiles.clear();\r\n", "    Point2[] nearby = Edges.getEdges(block.size);\r\n", "    for (Point2 point : nearby) {\r\n", "      Building other = world.build(tile.x + point.x, tile.y + point.y);\r\n", "      // remove this tile from all nearby tile's proximities\r\n", "      if (other != null) {\r\n", "        tmpTiles.add(other);\r\n", "      }\r\n", "    }\r\n", "    for (Building other : tmpTiles) {\r\n", "      other.proximity.remove(self(), true);\r\n", "      other.onProximityUpdate();\r\n", "    }\r\n", "    proximity.clear();\r\n", "  }\r\n", "\r\n", "  public void updateProximity() {\r\n", "    tmpTiles.clear();\r\n", "    proximity.clear();\r\n", "    Point2[] nearby = Edges.getEdges(block.size);\r\n", "    for (Point2 point : nearby) {\r\n", "      Building other = world.build(tile.x + point.x, tile.y + point.y);\r\n", "      if (other == null || other.team != team)\r\n", "        continue;\r\n", "      other.proximity.addUnique(self());\r\n", "      tmpTiles.add(other);\r\n", "    }\r\n", "    // using a set to prevent duplicates\r\n", "    for (Building tile : tmpTiles) {\r\n", "      proximity.add(tile);\r\n", "    }\r\n", "    onProximityAdded();\r\n", "    onProximityUpdate();\r\n", "    for (Building other : tmpTiles) {\r\n", "      other.onProximityUpdate();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void consume() {\r\n", "    for (Consume cons : block.consumers) {\r\n", "      cons.trigger(self());\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public boolean canConsume() {\r\n", "    return potentialEfficiency > 0;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Scaled delta.\r\n", "   */\r\n", "  public float delta() {\r\n", "    return Time.delta * timeScale;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Efficiency * delta.\r\n", "   */\r\n", "  public float edelta() {\r\n", "    return efficiency * delta();\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Called after efficiency is updated but before consumers are updated. Use to apply your own multiplier.\r\n", "   */\r\n", "  public void updateEfficiencyMultiplier() {\r\n", "    float scale = efficiencyScale();\r\n", "    efficiency *= scale;\r\n", "    optionalEfficiency *= scale;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Calculate your own efficiency multiplier. By default, this is applied in updateEfficiencyMultiplier.\r\n", "   */\r\n", "  public float efficiencyScale() {\r\n", "    return 1f;\r\n", "  }\r\n", "\r\n", "  public void updateConsumption() {\r\n", "    // everything is valid when cheating\r\n", "    if (!block.hasConsumers || cheating()) {\r\n", "      potentialEfficiency = enabled && productionValid() ? 1f : 0f;\r\n", "      efficiency = optionalEfficiency = shouldConsume() ? potentialEfficiency : 0f;\r\n", "      updateEfficiencyMultiplier();\r\n", "      return;\r\n", "    }\r\n", "    // disabled -> nothing works\r\n", "    if (!enabled) {\r\n", "      potentialEfficiency = efficiency = optionalEfficiency = 0f;\r\n", "      return;\r\n", "    }\r\n", "    boolean update = shouldConsume() && productionValid();\r\n", "    float minEfficiency = 1f;\r\n", "    // assume efficiency is 1 for the calculations below\r\n", "    efficiency = optionalEfficiency = 1f;\r\n", "    // first pass: get the minimum efficiency of any consumer\r\n", "    for (var cons : block.nonOptionalConsumers) {\r\n", "      minEfficiency = Math.min(minEfficiency, cons.efficiency(self()));\r\n", "    }\r\n", "    // same for optionals\r\n", "    for (var cons : block.optionalConsumers) {\r\n", "      optionalEfficiency = Math.min(optionalEfficiency, cons.efficiency(self()));\r\n", "    }\r\n", "    // efficiency is now this minimum value\r\n", "    efficiency = minEfficiency;\r\n", "    optionalEfficiency = Math.min(optionalEfficiency, minEfficiency);\r\n", "    // assign \"potential\"\r\n", "    potentialEfficiency = efficiency;\r\n", "    // no updating means zero efficiency\r\n", "    if (!update) {\r\n", "      efficiency = optionalEfficiency = 0f;\r\n", "    }\r\n", "    updateEfficiencyMultiplier();\r\n", "    // second pass: update every consumer based on efficiency\r\n", "    if (update && efficiency > 0) {\r\n", "      for (var cons : block.updateConsumers) {\r\n", "        cons.update(self());\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void updatePayload(@Nullable Unit unitHolder, @Nullable Building buildingHolder) {\r\n", "    update();\r\n", "  }\r\n", "\r\n", "  public void updateTile() {\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return ambient sound volume scale.\r\n", "   */\r\n", "  public float ambientVolume() {\r\n", "    return efficiency;\r\n", "  }\r\n", "\r\n", "  // endregion\r\n", "  // region overrides\r\n", "  /**\r\n", "   * Tile configuration. Defaults to null. Used for block rebuilding.\r\n", "   */\r\n", "  @Nullable\r\n", "  public Object config() {\r\n", "    return null;\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public boolean isValid() {\r\n", "    return tile.build == self() && !dead();\r\n", "  }\r\n", "\r\n", "  @MethodPriority(100)\r\n", "  @Override\r\n", "  public void heal() {\r\n", "    healthChanged();\r\n", "  }\r\n", "\r\n", "  @MethodPriority(100)\r\n", "  @Override\r\n", "  public void heal(float amount) {\r\n", "    healthChanged();\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public float hitSize() {\r\n", "    return tile.block().size * tilesize;\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public void kill() {\r\n", "    Call.buildDestroyed(self());\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public void damage(float damage) {\r\n", "    if (dead())\r\n", "      return;\r\n", "    float dm = state.rules.blockHealth(team);\r\n", "    lastDamageTime = Time.time;\r\n", "    if (Mathf.zero(dm)) {\r\n", "      damage = health + 1;\r\n", "    } else {\r\n", "      damage /= dm;\r\n", "    }\r\n", "    // TODO handle this better on the client.\r\n", "    if (!net.client()) {\r\n", "      health -= handleDamage(damage);\r\n", "    }\r\n", "    healthChanged();\r\n", "    if (health <= 0) {\r\n", "      Call.buildDestroyed(self());\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void healthChanged() {\r\n", "    // server-side, health updates are batched.\r\n", "    if (net.server()) {\r\n", "      netServer.buildHealthUpdate(self());\r\n", "    }\r\n", "    indexer.notifyHealthChanged(self());\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public double sense(LAccess sensor) {\r\n", "    switch(sensor) {\r\n", "      case x:\r\n", "        return World.conv(x);\r\n", "      case y:\r\n", "        return World.conv(y);\r\n", "      case color:\r\n", "        return Color.toDoubleBits(team.color.r, team.color.g, team.color.b, 1f);\r\n", "      case dead:\r\n", "        return !isValid() ? 1 : 0;\r\n", "      case team:\r\n", "        return team.id;\r\n", "      case health:\r\n", "        return health;\r\n", "      case maxHealth:\r\n", "        return maxHealth;\r\n", "      case efficiency:\r\n", "        return efficiency;\r\n", "      case timescale:\r\n", "        return timeScale;\r\n", "      case range:\r\n", "        return this instanceof Ranged r ? r.range() / tilesize : 0;\r\n", "      case rotation:\r\n", "        return rotation;\r\n", "      case totalItems:\r\n", "        return items == null ? 0 : items.total();\r\n", "      // totalLiquids is inherently bad design, but unfortunately it is useful for conduits/tanks\r\n", "      case totalLiquids:\r\n", "        return liquids == null ? 0 : liquids.currentAmount();\r\n", "      case totalPower:\r\n", "        return power == null || block.consPower == null ? 0 : power.status * (block.consPower.buffered ? block.consPower.capacity : 1f);\r\n", "      case itemCapacity:\r\n", "        return block.hasItems ? block.itemCapacity : 0;\r\n", "      case liquidCapacity:\r\n", "        return block.hasLiquids ? block.liquidCapacity : 0;\r\n", "      case powerCapacity:\r\n", "        return block.consPower != null ? block.consPower.capacity : 0f;\r\n", "      case powerNetIn:\r\n", "        return power == null ? 0 : power.graph.getLastScaledPowerIn() * 60;\r\n", "      case powerNetOut:\r\n", "        return power == null ? 0 : power.graph.getLastScaledPowerOut() * 60;\r\n", "      case powerNetStored:\r\n", "        return power == null ? 0 : power.graph.getLastPowerStored();\r\n", "      case powerNetCapacity:\r\n", "        return power == null ? 0 : power.graph.getLastCapacity();\r\n", "      case enabled:\r\n", "        return enabled ? 1 : 0;\r\n", "      case controlled:\r\n", "        return this instanceof ControlBlock c && c.isControlled() ? GlobalVars.ctrlPlayer : 0;\r\n", "      case payloadCount:\r\n", "        return getPayload() != null ? 1 : 0;\r\n", "      case size:\r\n", "        return block.size;\r\n", "      // gets converted to null in logic\r\n", "      default:\r\n", "        return Float.NaN;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public Object senseObject(LAccess sensor) {\r\n", "    switch(sensor) {\r\n", "      case type:\r\n", "        return block;\r\n", "      case firstItem:\r\n", "        return items == null ? null : items.first();\r\n", "      case config:\r\n", "        return block.configSenseable() ? config() : null;\r\n", "      case payloadType:\r\n", "        return getPayload() instanceof UnitPayload p1 ? p1.unit.type : getPayload() instanceof BuildPayload p2 ? p2.block() : null;\r\n", "      default:\r\n", "        return noSensed;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public double sense(Content content) {\r\n", "    if (content instanceof Item i && items != null)\r\n", "      return items.get(i);\r\n", "    if (content instanceof Liquid l && liquids != null)\r\n", "      return liquids.get(l);\r\n", "    // invalid sense\r\n", "    return Float.NaN;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void control(LAccess type, double p1, double p2, double p3, double p4) {\r\n", "    if (type == LAccess.enabled) {\r\n", "      enabled = !Mathf.zero((float) p1);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void control(LAccess type, Object p1, double p2, double p3, double p4) {\r\n", "    // don't execute configure instructions that copy logic building configures; this can cause extreme lag\r\n", "    if (type == LAccess.config && block.logicConfigurable && !(p1 instanceof LogicBuild)) {\r\n", "      // change config only if it's new\r\n", "      configured(null, p1);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void setProp(LAccess prop, double value) {\r\n", "    switch(prop) {\r\n", "      case health:\r\n", "        {\r\n", "          health = (float) Mathf.clamp(value, 0, maxHealth);\r\n", "          healthChanged();\r\n", "        }\r\n", "      case team:\r\n", "        {\r\n", "          Team team = Team.get((int) value);\r\n", "          if (this.team != team) {\r\n", "            changeTeam(team);\r\n", "          }\r\n", "        }\r\n", "      case totalPower:\r\n", "        {\r\n", "          if (power != null && block.consPower != null && block.consPower.buffered) {\r\n", "            power.status = Mathf.clamp((float) (value / block.consPower.capacity));\r\n", "          }\r\n", "        }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void setProp(LAccess prop, Object value) {\r\n", "    switch(prop) {\r\n", "      case team:\r\n", "        {\r\n", "          if (value instanceof Team team && this.team != team) {\r\n", "            changeTeam(team);\r\n", "          }\r\n", "        }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void setProp(UnlockableContent content, double value) {\r\n", "    if (content instanceof Item item && items != null) {\r\n", "      int amount = (int) value;\r\n", "      if (items.get(item) != amount) {\r\n", "        if (items.get(item) < amount) {\r\n", "          handleStack(item, acceptStack(item, amount - items.get(item), null), null);\r\n", "        } else if (amount >= 0) {\r\n", "          removeStack(item, items.get(item) - amount);\r\n", "        }\r\n", "      }\r\n", "    } else if (content instanceof Liquid liquid && liquids != null) {\r\n", "      float amount = Mathf.clamp((float) value, 0f, block.liquidCapacity);\r\n", "      // decreasing amount is always allowed\r\n", "      if (amount < liquids.get(liquid) || (acceptLiquid(self(), liquid) && (liquids.current() == liquid || liquids.currentAmount() <= 0.1f))) {\r\n", "        liquids.set(liquid, amount);\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public boolean inFogTo(Team viewer) {\r\n", "    if (team == viewer || !state.rules.fog)\r\n", "      return false;\r\n", "    int size = block.size, of = block.sizeOffset, tx = tile.x, ty = tile.y;\r\n", "    if (!isDiscovered(viewer))\r\n", "      return true;\r\n", "    for (int x = 0; x < size; x++) {\r\n", "      for (int y = 0; y < size; y++) {\r\n", "        if (fogControl.isVisibleTile(viewer, tx + x + of, ty + y + of)) {\r\n", "          return false;\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void remove() {\r\n", "    if (sound != null) {\r\n", "      sound.stop();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void killed() {\r\n", "    Events.fire(new BlockDestroyEvent(tile));\r\n", "    block.destroySound.at(tile);\r\n", "    onDestroyed();\r\n", "    if (tile != emptyTile) {\r\n", "      tile.remove();\r\n", "    }\r\n", "    remove();\r\n", "    afterDestroyed();\r\n", "  }\r\n", "\r\n", "  @Final\r\n", "  @Replace\r\n", "  @Override\r\n", "  public void update() {\r\n", "    // TODO should just avoid updating buildings instead\r\n", "    if (state.isEditor())\r\n", "      return;\r\n", "    // TODO refactor to timestamp-based system?\r\n", "    if ((timeScaleDuration -= Time.delta) <= 0f || !block.canOverdrive) {\r\n", "      timeScale = 1f;\r\n", "    }\r\n", "    if (!allowUpdate()) {\r\n", "      enabled = false;\r\n", "    }\r\n", "    if (!headless && !wasVisible && state.rules.fog && !inFogTo(player.team())) {\r\n", "      visibleFlags |= (1L << player.team().id);\r\n", "      wasVisible = true;\r\n", "      renderer.blocks.updateShadow(self());\r\n", "      renderer.minimap.update(tile);\r\n", "    }\r\n", "    // TODO separate system for sound? AudioSource, etc\r\n", "    if (!headless) {\r\n", "      if (sound != null) {\r\n", "        sound.update(x, y, shouldActiveSound(), activeSoundVolume());\r\n", "      }\r\n", "      if (block.ambientSound != Sounds.none && shouldAmbientSound()) {\r\n", "        control.sound.loop(block.ambientSound, self(), block.ambientSoundVolume * ambientVolume());\r\n", "      }\r\n", "    }\r\n", "    updateConsumption();\r\n", "    // TODO just handle per-block instead\r\n", "    if (enabled || !block.noUpdateDisabled) {\r\n", "      updateTile();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void hitbox(Rect out) {\r\n", "    out.setCentered(x, y, block.size * tilesize, block.size * tilesize);\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public String toString() {\r\n", "    return \"Building#\" + id() + \"[\" + tileX() + \",\" + tileY() + \"]:\" + block;\r\n", "  }\r\n", "  // endregion\r\n", "}\r\n" }));
        compMap.put("BuildingTetherComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.type.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "/**\r\n", " * A unit that depends on a building's existence; if that building is removed, it despawns.\r\n", " */\r\n", "@Component\r\n", "abstract class BuildingTetherComp implements Unitc {\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  @Import\r\n", "  Team team;\r\n", "\r\n", "  @Nullable\r\n", "  public Building building;\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    if (building == null || !building.isValid() || building.team != team) {\r\n", "      Call.unitDespawn(self());\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("BulletComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.func.*;\r\n", "import arc.graphics.g2d.*;\r\n", "import arc.math.*;\r\n", "import arc.math.geom.*;\r\n", "import arc.struct.*;\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.core.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.entities.bullet.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.game.Teams.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.graphics.*;\r\n", "import mindustry.world.*;\r\n", "import mindustry.world.blocks.environment.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { Bulletc.class }, pooled = true, serialize = false)\r\n", "@Component(base = true)\r\n", "abstract class BulletComp implements Timedc, Damagec, Hitboxc, Teamc, Posc, Drawc, Shielderc, Ownerc, Velc, Bulletc, Timerc {\r\n", "\r\n", "  @Import\r\n", "  Team team;\r\n", "\r\n", "  @Import\r\n", "  Entityc owner;\r\n", "\r\n", "  @Import\r\n", "  float x, y, damage, lastX, lastY, time, lifetime;\r\n", "\r\n", "  @Import\r\n", "  Vec2 vel;\r\n", "\r\n", "  IntSeq collided = new IntSeq(6);\r\n", "\r\n", "  BulletType type;\r\n", "\r\n", "  Object data;\r\n", "\r\n", "  float fdata;\r\n", "\r\n", "  @ReadOnly\r\n", "  private float rotation;\r\n", "\r\n", "  // setting this variable to true prevents lifetime from decreasing for a frame.\r\n", "  transient boolean keepAlive;\r\n", "\r\n", "  @Nullable\r\n", "  transient Tile aimTile;\r\n", "\r\n", "  transient float aimX, aimY;\r\n", "\r\n", "  transient float originX, originY;\r\n", "\r\n", "  @Nullable\r\n", "  transient Mover mover;\r\n", "\r\n", "  transient boolean absorbed, hit;\r\n", "\r\n", "  @Nullable\r\n", "  transient Trail trail;\r\n", "\r\n", "  @Override\r\n", "  public void getCollisions(Cons<QuadTree> consumer) {\r\n", "    Seq<TeamData> data = state.teams.present;\r\n", "    for (int i = 0; i < data.size; i++) {\r\n", "      if (data.items[i].team != team) {\r\n", "        consumer.get(data.items[i].tree());\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  // bullets always considered local\r\n", "  @Override\r\n", "  @Replace\r\n", "  public boolean isLocal() {\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void add() {\r\n", "    type.init(self());\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void remove() {\r\n", "    if (Groups.isClearing)\r\n", "      return;\r\n", "    // 'despawned' only counts when the bullet is killed externally or reaches the end of life\r\n", "    if (!hit) {\r\n", "      type.despawned(self());\r\n", "    }\r\n", "    type.removed(self());\r\n", "    collided.clear();\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public float damageMultiplier() {\r\n", "    return type.damageMultiplier(self());\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void absorb() {\r\n", "    absorbed = true;\r\n", "    remove();\r\n", "  }\r\n", "\r\n", "  public boolean hasCollided(int id) {\r\n", "    return collided.size != 0 && collided.contains(id);\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  public float clipSize() {\r\n", "    return type.drawSize;\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public boolean collides(Hitboxc other) {\r\n", "    return // prevent multiple collisions\r\n", "    type.collides && (other instanceof Teamc t && t.team() != team) && !(other instanceof Flyingc f && !f.checkTarget(type.collidesAir, type.collidesGround)) && !(type.pierce && hasCollided(other.id()));\r\n", "  }\r\n", "\r\n", "  @MethodPriority(100)\r\n", "  @Override\r\n", "  public void collision(Hitboxc other, float x, float y) {\r\n", "    type.hit(self(), x, y);\r\n", "    // must be last.\r\n", "    if (!type.pierce) {\r\n", "      hit = true;\r\n", "      remove();\r\n", "    } else {\r\n", "      collided.add(other.id());\r\n", "    }\r\n", "    type.hitEntity(self(), other, other instanceof Healthc h ? h.health() : 0f);\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    if (mover != null) {\r\n", "      mover.move(self());\r\n", "    }\r\n", "    type.update(self());\r\n", "    if (type.collidesTiles && type.collides && type.collidesGround) {\r\n", "      tileRaycast(World.toTile(lastX), World.toTile(lastY), tileX(), tileY());\r\n", "    }\r\n", "    if (type.removeAfterPierce && type.pierceCap != -1 && collided.size >= type.pierceCap) {\r\n", "      hit = true;\r\n", "      remove();\r\n", "    }\r\n", "    if (keepAlive) {\r\n", "      time -= Time.delta;\r\n", "      keepAlive = false;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void moveRelative(float x, float y) {\r\n", "    float rot = rotation();\r\n", "    this.x += Angles.trnsx(rot, x * Time.delta, y * Time.delta);\r\n", "    this.y += Angles.trnsy(rot, x * Time.delta, y * Time.delta);\r\n", "  }\r\n", "\r\n", "  public void turn(float x, float y) {\r\n", "    float ang = vel.angle();\r\n", "    vel.add(Angles.trnsx(ang, x * Time.delta, y * Time.delta), Angles.trnsy(ang, x * Time.delta, y * Time.delta)).limit(type.speed);\r\n", "  }\r\n", "\r\n", "  public boolean checkUnderBuild(Building build, float x, float y) {\r\n", "    return (// direct hit on correct tile\r\n", "    // same team has no 'under build' mechanics\r\n", "    !build.block.underBullets || // a piercing bullet overshot the aim tile, it's fine to hit things now\r\n", "    (aimTile != null && aimTile.build == build) || // there was nothing to aim at\r\n", "    (build.team == team) || (type.pierce && aimTile != null && Mathf.dst(x, y, originX, originY) > aimTile.dst(originX, originY) + 2f) || (aimX == -1f && aimY == -1f));\r\n", "  }\r\n", "\r\n", "  // copy-paste of World#raycastEach, inlined for lambda capture performance.\r\n", "  @Override\r\n", "  public void tileRaycast(int x1, int y1, int x2, int y2) {\r\n", "    int x = x1, dx = Math.abs(x2 - x), sx = x < x2 ? 1 : -1;\r\n", "    int y = y1, dy = Math.abs(y2 - y), sy = y < y2 ? 1 : -1;\r\n", "    int e2, err = dx - dy;\r\n", "    int ww = world.width(), wh = world.height();\r\n", "    while (x >= 0 && y >= 0 && x < ww && y < wh) {\r\n", "      Building build = world.build(x, y);\r\n", "      if (type.collideFloor || type.collideTerrain) {\r\n", "        Tile tile = world.tile(x, y);\r\n", "        if (type.collideFloor && (tile == null || tile.floor().hasSurface() || tile.block() != Blocks.air) || type.collideTerrain && tile != null && tile.block() instanceof StaticWall) {\r\n", "          remove();\r\n", "          hit = true;\r\n", "          return;\r\n", "        }\r\n", "      }\r\n", "      if (build != null && isAdded() && checkUnderBuild(build, x, y) && build.collide(self()) && type.testCollision(self(), build) && !build.dead() && (type.collidesTeam || build.team != team) && !(type.pierceBuilding && hasCollided(build.id))) {\r\n", "        boolean remove = false;\r\n", "        float health = build.health;\r\n", "        if (build.team != team) {\r\n", "          remove = build.collision(self());\r\n", "        }\r\n", "        if (remove || type.collidesTeam) {\r\n", "          if (Mathf.dst2(lastX, lastY, x * tilesize, y * tilesize) < Mathf.dst2(lastX, lastY, this.x, this.y)) {\r\n", "            this.x = x * tilesize;\r\n", "            this.y = y * tilesize;\r\n", "          }\r\n", "          if (!type.pierceBuilding) {\r\n", "            hit = true;\r\n", "            remove();\r\n", "          } else {\r\n", "            collided.add(build.id);\r\n", "          }\r\n", "        }\r\n", "        type.hitTile(self(), build, x * tilesize, y * tilesize, health, true);\r\n", "        // stop raycasting when building is hit\r\n", "        if (type.pierceBuilding)\r\n", "          return;\r\n", "      }\r\n", "      if (x == x2 && y == y2)\r\n", "        break;\r\n", "      e2 = 2 * err;\r\n", "      if (e2 > -dy) {\r\n", "        err -= dy;\r\n", "        x += sx;\r\n", "      }\r\n", "      if (e2 < dx) {\r\n", "        err += dx;\r\n", "        y += sy;\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void draw() {\r\n", "    Draw.z(type.layer);\r\n", "    type.draw(self());\r\n", "    type.drawLight(self());\r\n", "    Draw.reset();\r\n", "  }\r\n", "\r\n", "  public void initVel(float angle, float amount) {\r\n", "    vel.trns(angle, amount);\r\n", "    rotation = angle;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Sets the bullet's rotation in degrees.\r\n", "   */\r\n", "  @Override\r\n", "  public void rotation(float angle) {\r\n", "    vel.setAngle(rotation = angle);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return the bullet's rotation.\r\n", "   */\r\n", "  @Override\r\n", "  public float rotation() {\r\n", "    return vel.isZero(0.001f) ? rotation : vel.angle();\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("ChildComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.math.*;\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class ChildComp implements Posc, Rotc {\r\n", "\r\n", "  @Import\r\n", "  float x, y, rotation;\r\n", "\r\n", "  @Nullable\r\n", "  Posc parent;\r\n", "\r\n", "  boolean rotWithParent;\r\n", "\r\n", "  float offsetX, offsetY, offsetPos, offsetRot;\r\n", "\r\n", "  @Override\r\n", "  public void add() {\r\n", "    if (parent != null) {\r\n", "      offsetX = x - parent.getX();\r\n", "      offsetY = y - parent.getY();\r\n", "      if (rotWithParent && parent instanceof Rotc r) {\r\n", "        offsetPos = -r.rotation();\r\n", "        offsetRot = rotation - r.rotation();\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    if (parent != null) {\r\n", "      if (rotWithParent && parent instanceof Rotc r) {\r\n", "        x = parent.getX() + Angles.trnsx(r.rotation() + offsetPos, offsetX, offsetY);\r\n", "        y = parent.getY() + Angles.trnsy(r.rotation() + offsetPos, offsetX, offsetY);\r\n", "        rotation = r.rotation() + offsetRot;\r\n", "      } else {\r\n", "        x = parent.getX() + offsetX;\r\n", "        y = parent.getY() + offsetY;\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("CrawlComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.math.*;\r\n", "import arc.math.geom.*;\r\n", "import arc.util.*;\r\n", "import mindustry.*;\r\n", "import mindustry.ai.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.entities.EntityCollisions.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.type.*;\r\n", "import mindustry.world.*;\r\n", "import mindustry.world.blocks.environment.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class CrawlComp implements Posc, Rotc, Hitboxc, Unitc {\r\n", "\r\n", "  @Import\r\n", "  float x, y, speedMultiplier, rotation, hitSize;\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  @Import\r\n", "  Team team;\r\n", "\r\n", "  @Import\r\n", "  Vec2 vel;\r\n", "\r\n", "  transient Floor lastDeepFloor;\r\n", "\r\n", "  transient float lastCrawlSlowdown = 1f;\r\n", "\r\n", "  transient float segmentRot, crawlTime = Mathf.random(100f);\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public SolidPred solidity() {\r\n", "    return EntityCollisions::legsSolid;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public int pathType() {\r\n", "    return Pathfinder.costLegs;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public float floorSpeedMultiplier() {\r\n", "    Floor on = isFlying() ? Blocks.air.asFloor() : floorOn();\r\n", "    // TODO take into account extra blocks\r\n", "    return (on.isDeep() ? 0.45f : on.speedMultiplier) * speedMultiplier * lastCrawlSlowdown;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void add() {\r\n", "    // reset segment rotation on add\r\n", "    segmentRot = rotation;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public Floor drownFloor() {\r\n", "    return lastDeepFloor;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    if (moving()) {\r\n", "      segmentRot = Angles.moveToward(segmentRot, rotation, type.segmentRotSpeed);\r\n", "      int radius = (int) Math.max(0, hitSize / tilesize * 2f);\r\n", "      int count = 0, solids = 0, deeps = 0;\r\n", "      lastDeepFloor = null;\r\n", "      // calculate tiles under this unit, and apply slowdown + particle effects\r\n", "      for (int cx = -radius; cx <= radius; cx++) {\r\n", "        for (int cy = -radius; cy <= radius; cy++) {\r\n", "          if (cx * cx + cy * cy <= radius) {\r\n", "            count++;\r\n", "            Tile t = Vars.world.tileWorld(x + cx * tilesize, y + cy * tilesize);\r\n", "            if (t != null) {\r\n", "              if (t.solid()) {\r\n", "                solids++;\r\n", "              }\r\n", "              if (t.floor().isDeep()) {\r\n", "                deeps++;\r\n", "                lastDeepFloor = t.floor();\r\n", "              }\r\n", "              // TODO area damage to units\r\n", "              if (t.build != null && t.build.team != team) {\r\n", "                t.build.damage(team, type.crushDamage * Time.delta * state.rules.unitDamage(team));\r\n", "              }\r\n", "              if (Mathf.chanceDelta(0.025)) {\r\n", "                Fx.crawlDust.at(t.worldx(), t.worldy(), t.floor().mapColor);\r\n", "              }\r\n", "            } else {\r\n", "              solids++;\r\n", "            }\r\n", "          }\r\n", "        }\r\n", "      }\r\n", "      // when most blocks under this unit cannot be drowned in, do not drown\r\n", "      if ((float) deeps / count < 0.75f) {\r\n", "        lastDeepFloor = null;\r\n", "      }\r\n", "      lastCrawlSlowdown = Mathf.lerp(1f, type.crawlSlowdown, Mathf.clamp((float) solids / count / type.crawlSlowdownFrac));\r\n", "    }\r\n", "    segmentRot = Angles.clampRange(segmentRot, rotation, type.segmentMaxRot);\r\n", "    crawlTime += vel.len();\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("DamageComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class DamageComp {\r\n", "\r\n", "  float damage;\r\n", "}\r\n" }));
        compMap.put("DecalComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.graphics.*;\r\n", "import arc.graphics.g2d.*;\r\n", "import arc.math.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.graphics.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { Decalc.class }, pooled = true, serialize = false)\r\n", "@Component(base = true)\r\n", "abstract class DecalComp implements Drawc, Timedc, Rotc, Posc {\r\n", "\r\n", "  @Import\r\n", "  float x, y, rotation;\r\n", "\r\n", "  Color color = new Color(1, 1, 1, 1);\r\n", "\r\n", "  TextureRegion region;\r\n", "\r\n", "  @Override\r\n", "  public void draw() {\r\n", "    Draw.z(Layer.scorch);\r\n", "    Draw.mixcol(color, color.a);\r\n", "    Draw.alpha(1f - Mathf.curve(fin(), 0.98f));\r\n", "    Draw.rect(region, x, y, rotation);\r\n", "    Draw.reset();\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  public float clipSize() {\r\n", "    return region.width * 2;\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("DrawComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class DrawComp implements Posc {\r\n", "\r\n", "  float clipSize() {\r\n", "    return Float.MAX_VALUE;\r\n", "  }\r\n", "\r\n", "  void draw() {\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("EffectStateComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.graphics.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { EffectStatec.class, Childc.class }, pooled = true, serialize = false)\r\n", "@Component(base = true)\r\n", "abstract class EffectStateComp implements Posc, Drawc, Timedc, Rotc, Childc {\r\n", "\r\n", "  @Import\r\n", "  float time, lifetime, rotation, x, y;\r\n", "\r\n", "  @Import\r\n", "  int id;\r\n", "\r\n", "  Color color = new Color(Color.white);\r\n", "\r\n", "  Effect effect;\r\n", "\r\n", "  Object data;\r\n", "\r\n", "  @Override\r\n", "  public void draw() {\r\n", "    lifetime = effect.render(id, color, time, lifetime, rotation, x, y, data);\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  public float clipSize() {\r\n", "    return effect.clip;\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("ElevationMoveComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.entities.EntityCollisions.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class ElevationMoveComp implements Velc, Posc, Flyingc, Hitboxc {\r\n", "\r\n", "  @Import\r\n", "  float x, y;\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public SolidPred solidity() {\r\n", "    return isFlying() ? null : EntityCollisions::solid;\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("EntityComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.util.io.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "@BaseComponent\r\n", "abstract class EntityComp {\r\n", "\r\n", "  private transient boolean added;\r\n", "\r\n", "  transient int id = EntityGroup.nextId();\r\n", "\r\n", "  boolean isAdded() {\r\n", "    return added;\r\n", "  }\r\n", "\r\n", "  void update() {\r\n", "  }\r\n", "\r\n", "  void remove() {\r\n", "    added = false;\r\n", "  }\r\n", "\r\n", "  void add() {\r\n", "    added = true;\r\n", "  }\r\n", "\r\n", "  boolean isLocal() {\r\n", "    return ((Object) this) == player || ((Object) this) instanceof Unitc u && u.controller() == player;\r\n", "  }\r\n", "\r\n", "  boolean isRemote() {\r\n", "    return ((Object) this) instanceof Unitc u && u.isPlayer() && !isLocal();\r\n", "  }\r\n", "\r\n", "  boolean isNull() {\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Replaced with `this` after code generation.\r\n", "   */\r\n", "  <T extends Entityc> T self() {\r\n", "    return (T) this;\r\n", "  }\r\n", "\r\n", "  <T> T as() {\r\n", "    return (T) this;\r\n", "  }\r\n", "\r\n", "  @InternalImpl\r\n", "  abstract int classId();\r\n", "\r\n", "  @InternalImpl\r\n", "  abstract boolean serialize();\r\n", "\r\n", "  @MethodPriority(1)\r\n", "  void read(Reads read) {\r\n", "    afterRead();\r\n", "  }\r\n", "\r\n", "  void write(Writes write) {\r\n", "  }\r\n", "\r\n", "  void afterRead() {\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("FireComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.*;\r\n", "import arc.graphics.g2d.*;\r\n", "import arc.math.*;\r\n", "import arc.math.geom.*;\r\n", "import arc.util.*;\r\n", "import mindustry.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.graphics.*;\r\n", "import mindustry.world.*;\r\n", "import mindustry.world.meta.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { Firec.class }, pooled = true)\r\n", "@Component(base = true)\r\n", "abstract class FireComp implements Timedc, Posc, Syncc, Drawc {\r\n", "\r\n", "  public static final int frames = 40, duration = 90;\r\n", "\r\n", "  private static final float spreadDelay = 22f, fireballDelay = 40f, ticksPerFrame = (float) duration / frames, warmupDuration = 20f, damageDelay = 40f, tileDamage = 1.8f, unitDamage = 3f;\r\n", "\r\n", "  public static final TextureRegion[] regions = new TextureRegion[frames];\r\n", "\r\n", "  @Import\r\n", "  float time, lifetime, x, y;\r\n", "\r\n", "  Tile tile;\r\n", "\r\n", "  private transient float puddleFlammability, damageTimer = Mathf.random(40f), spreadTimer = Mathf.random(spreadDelay), fireballTimer = Mathf.random(fireballDelay), warmup = 0f, animation = Mathf.random(frames - 1);\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    animation += Time.delta / ticksPerFrame;\r\n", "    warmup += Time.delta;\r\n", "    animation %= frames;\r\n", "    if (!headless) {\r\n", "      control.sound.loop(Sounds.fire, this, 0.07f);\r\n", "    }\r\n", "    // faster updates -> disappears more quickly\r\n", "    float speedMultiplier = 1f + Math.max(state.envAttrs.get(Attribute.water) * 10f, 0);\r\n", "    time = Mathf.clamp(time + Time.delta * speedMultiplier, 0, lifetime);\r\n", "    if (Vars.net.client()) {\r\n", "      return;\r\n", "    }\r\n", "    if (time >= lifetime || tile == null || Float.isNaN(lifetime)) {\r\n", "      remove();\r\n", "      return;\r\n", "    }\r\n", "    Building entity = tile.build;\r\n", "    boolean damage = entity != null;\r\n", "    float flammability = tile.getFlammability() + puddleFlammability;\r\n", "    if (!damage && flammability <= 0) {\r\n", "      time += Time.delta * 8;\r\n", "    }\r\n", "    if (damage) {\r\n", "      lifetime += Mathf.clamp(flammability / 8f, 0f, 0.6f) * Time.delta;\r\n", "    }\r\n", "    if (flammability > 1f && (spreadTimer += Time.delta * Mathf.clamp(flammability / 5f, 0.3f, 2f)) >= spreadDelay) {\r\n", "      spreadTimer = 0f;\r\n", "      Point2 p = Geometry.d4[Mathf.random(3)];\r\n", "      Tile other = world.tile(tile.x + p.x, tile.y + p.y);\r\n", "      Fires.create(other);\r\n", "    }\r\n", "    if (flammability > 0 && (fireballTimer += Time.delta * Mathf.clamp(flammability / 10f, 0f, 0.5f)) >= fireballDelay) {\r\n", "      fireballTimer = 0f;\r\n", "      Bullets.fireball.createNet(Team.derelict, x, y, Mathf.random(360f), -1f, 1, 1);\r\n", "    }\r\n", "    // apply damage to nearby units & building\r\n", "    if ((damageTimer += Time.delta) >= damageDelay) {\r\n", "      damageTimer = 0f;\r\n", "      Puddlec p = Puddles.get(tile);\r\n", "      puddleFlammability = p != null ? p.getFlammability() / 3f : 0;\r\n", "      if (damage) {\r\n", "        entity.damage(tileDamage);\r\n", "      }\r\n", "      Damage.damageUnits(null, tile.worldx(), tile.worldy(), tilesize, unitDamage, unit -> !unit.isFlying() && !unit.isImmune(StatusEffects.burning), unit -> unit.apply(StatusEffects.burning, 60 * 5));\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void draw() {\r\n", "    if (regions[0] == null) {\r\n", "      for (int i = 0; i < frames; i++) {\r\n", "        regions[i] = Core.atlas.find(\"fire\" + i);\r\n", "      }\r\n", "    }\r\n", "    Draw.color(1f, 1f, 1f, Mathf.clamp(warmup / warmupDuration));\r\n", "    Draw.z(Layer.effect);\r\n", "    Draw.rect(regions[Math.min((int) animation, regions.length - 1)], x + Mathf.randomSeedRange((int) y, 2), y + Mathf.randomSeedRange((int) x, 2));\r\n", "    Draw.reset();\r\n", "    Drawf.light(x, y, 50f + Mathf.absin(5f, 5f), Pal.lightFlame, 0.6f * Mathf.clamp(warmup / warmupDuration));\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public float clipSize() {\r\n", "    return 25;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void remove() {\r\n", "    Fx.fireRemove.at(x, y, animation);\r\n", "    Fires.remove(tile);\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void afterRead() {\r\n", "    Fires.register(self());\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void afterSync() {\r\n", "    Fires.register(self());\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("FlyingComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.*;\r\n", "import arc.math.*;\r\n", "import arc.math.geom.*;\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.game.EventType.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.type.*;\r\n", "import mindustry.world.blocks.environment.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class FlyingComp implements Posc, Velc, Healthc, Hitboxc {\r\n", "\r\n", "  private static final Vec2 tmp1 = new Vec2(), tmp2 = new Vec2();\r\n", "\r\n", "  @Import\r\n", "  float x, y, speedMultiplier, hitSize;\r\n", "\r\n", "  @Import\r\n", "  Vec2 vel;\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  @SyncLocal\r\n", "  float elevation;\r\n", "\r\n", "  private transient boolean wasFlying;\r\n", "\r\n", "  transient boolean hovering;\r\n", "\r\n", "  transient float drownTime;\r\n", "\r\n", "  transient float splashTimer;\r\n", "\r\n", "  @Nullable\r\n", "  transient Floor lastDrownFloor;\r\n", "\r\n", "  boolean checkTarget(boolean targetAir, boolean targetGround) {\r\n", "    return (isGrounded() && targetGround) || (isFlying() && targetAir);\r\n", "  }\r\n", "\r\n", "  boolean isGrounded() {\r\n", "    return elevation < 0.001f;\r\n", "  }\r\n", "\r\n", "  boolean isFlying() {\r\n", "    return elevation >= 0.09f;\r\n", "  }\r\n", "\r\n", "  boolean canDrown() {\r\n", "    return isGrounded() && !hovering;\r\n", "  }\r\n", "\r\n", "  @Nullable\r\n", "  Floor drownFloor() {\r\n", "    return canDrown() ? floorOn() : null;\r\n", "  }\r\n", "\r\n", "  boolean emitWalkSound() {\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  void landed() {\r\n", "  }\r\n", "\r\n", "  void wobble() {\r\n", "    x += Mathf.sin(Time.time + (id() % 10) * 12, 25f, 0.05f) * Time.delta * elevation;\r\n", "    y += Mathf.cos(Time.time + (id() % 10) * 12, 25f, 0.05f) * Time.delta * elevation;\r\n", "  }\r\n", "\r\n", "  void moveAt(Vec2 vector, float acceleration) {\r\n", "    // target vector\r\n", "    Vec2 t = tmp1.set(vector);\r\n", "    // delta vector\r\n", "    tmp2.set(t).sub(vel).limit(acceleration * vector.len() * Time.delta);\r\n", "    vel.add(tmp2);\r\n", "  }\r\n", "\r\n", "  float floorSpeedMultiplier() {\r\n", "    Floor on = isFlying() || hovering ? Blocks.air.asFloor() : floorOn();\r\n", "    return on.speedMultiplier * speedMultiplier;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    Floor floor = floorOn();\r\n", "    if (isFlying() != wasFlying) {\r\n", "      if (wasFlying) {\r\n", "        if (tileOn() != null) {\r\n", "          Fx.unitLand.at(x, y, floorOn().isLiquid ? 1f : 0.5f, tileOn().floor().mapColor);\r\n", "        }\r\n", "      }\r\n", "      wasFlying = isFlying();\r\n", "    }\r\n", "    if (!hovering && isGrounded()) {\r\n", "      if ((splashTimer += Mathf.dst(deltaX(), deltaY())) >= (7f + hitSize() / 8f)) {\r\n", "        floor.walkEffect.at(x, y, hitSize() / 8f, floor.mapColor);\r\n", "        splashTimer = 0f;\r\n", "        if (emitWalkSound()) {\r\n", "          floor.walkSound.at(x, y, Mathf.random(floor.walkSoundPitchMin, floor.walkSoundPitchMax), floor.walkSoundVolume);\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "    updateDrowning();\r\n", "  }\r\n", "\r\n", "  public void updateDrowning() {\r\n", "    Floor floor = drownFloor();\r\n", "    if (floor != null && floor.isLiquid && floor.drownTime > 0) {\r\n", "      lastDrownFloor = floor;\r\n", "      drownTime += Time.delta / floor.drownTime / type.drownTimeMultiplier;\r\n", "      if (Mathf.chanceDelta(0.05f)) {\r\n", "        floor.drownUpdateEffect.at(x, y, hitSize, floor.mapColor);\r\n", "      }\r\n", "      if (drownTime >= 0.999f && !net.client()) {\r\n", "        kill();\r\n", "        Events.fire(new UnitDrownEvent(self()));\r\n", "      }\r\n", "    } else {\r\n", "      drownTime -= Time.delta / 50f;\r\n", "    }\r\n", "    drownTime = Mathf.clamp(drownTime);\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("HealthComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class HealthComp implements Entityc, Posc {\r\n", "\r\n", "  static final float hitDuration = 9f;\r\n", "\r\n", "  float health;\r\n", "\r\n", "  transient float hitTime;\r\n", "\r\n", "  transient float maxHealth = 1f;\r\n", "\r\n", "  transient boolean dead;\r\n", "\r\n", "  boolean isValid() {\r\n", "    return !dead && isAdded();\r\n", "  }\r\n", "\r\n", "  float healthf() {\r\n", "    return health / maxHealth;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    hitTime -= Time.delta / hitDuration;\r\n", "  }\r\n", "\r\n", "  void killed() {\r\n", "    // implement by other components\r\n", "  }\r\n", "\r\n", "  void kill() {\r\n", "    if (dead)\r\n", "      return;\r\n", "    health = Math.min(health, 0);\r\n", "    dead = true;\r\n", "    killed();\r\n", "    remove();\r\n", "  }\r\n", "\r\n", "  void heal() {\r\n", "    dead = false;\r\n", "    health = maxHealth;\r\n", "  }\r\n", "\r\n", "  boolean damaged() {\r\n", "    return health < maxHealth - 0.001f;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Damage and pierce armor.\r\n", "   */\r\n", "  void damagePierce(float amount, boolean withEffect) {\r\n", "    damage(amount, withEffect);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Damage and pierce armor.\r\n", "   */\r\n", "  void damagePierce(float amount) {\r\n", "    damagePierce(amount, true);\r\n", "  }\r\n", "\r\n", "  void damage(float amount) {\r\n", "    health -= amount;\r\n", "    hitTime = 1f;\r\n", "    if (health <= 0 && !dead) {\r\n", "      kill();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  void damage(float amount, boolean withEffect) {\r\n", "    float pre = hitTime;\r\n", "    damage(amount);\r\n", "    if (!withEffect) {\r\n", "      hitTime = pre;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  void damageContinuous(float amount) {\r\n", "    damage(amount * Time.delta, hitTime <= -10 + hitDuration);\r\n", "  }\r\n", "\r\n", "  void damageContinuousPierce(float amount) {\r\n", "    damagePierce(amount * Time.delta, hitTime <= -20 + hitDuration);\r\n", "  }\r\n", "\r\n", "  void clampHealth() {\r\n", "    health = Math.min(health, maxHealth);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Heals by a flat amount.\r\n", "   */\r\n", "  void heal(float amount) {\r\n", "    health += amount;\r\n", "    clampHealth();\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Heals by a 0-1 fraction of max health.\r\n", "   */\r\n", "  void healFract(float amount) {\r\n", "    heal(amount * maxHealth);\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("HitboxComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.func.*;\r\n", "import arc.math.*;\r\n", "import arc.math.geom.*;\r\n", "import arc.math.geom.QuadTree.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class HitboxComp implements Posc, Sized, QuadTreeObject {\r\n", "\r\n", "  @Import\r\n", "  float x, y;\r\n", "\r\n", "  transient float lastX, lastY, deltaX, deltaY, hitSize;\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void add() {\r\n", "    updateLastPosition();\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void afterRead() {\r\n", "    updateLastPosition();\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public float hitSize() {\r\n", "    return hitSize;\r\n", "  }\r\n", "\r\n", "  void getCollisions(Cons<QuadTree> consumer) {\r\n", "  }\r\n", "\r\n", "  void updateLastPosition() {\r\n", "    deltaX = x - lastX;\r\n", "    deltaY = y - lastY;\r\n", "    lastX = x;\r\n", "    lastY = y;\r\n", "  }\r\n", "\r\n", "  void collision(Hitboxc other, float x, float y) {\r\n", "  }\r\n", "\r\n", "  float deltaLen() {\r\n", "    return Mathf.len(deltaX, deltaY);\r\n", "  }\r\n", "\r\n", "  float deltaAngle() {\r\n", "    return Mathf.angle(deltaX, deltaY);\r\n", "  }\r\n", "\r\n", "  boolean collides(Hitboxc other) {\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void hitbox(Rect rect) {\r\n", "    rect.setCentered(x, y, hitSize, hitSize);\r\n", "  }\r\n", "\r\n", "  public void hitboxTile(Rect rect) {\r\n", "    // tile hitboxes are never bigger than a tile, otherwise units get stuck\r\n", "    float size = Math.min(hitSize * 0.66f, 7.9f);\r\n", "    // TODO: better / more accurate version is\r\n", "    // float size = hitSize * 0.85f;\r\n", "    // - for tanks?\r\n", "    rect.setCentered(x, y, size, size);\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("ItemsComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.math.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.type.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class ItemsComp implements Posc {\r\n", "\r\n", "  ItemStack stack = new ItemStack();\r\n", "\r\n", "  transient float itemTime;\r\n", "\r\n", "  abstract int itemCapacity();\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    stack.amount = Mathf.clamp(stack.amount, 0, itemCapacity());\r\n", "    itemTime = Mathf.lerpDelta(itemTime, Mathf.num(hasItem()), 0.05f);\r\n", "  }\r\n", "\r\n", "  Item item() {\r\n", "    return stack.item;\r\n", "  }\r\n", "\r\n", "  void clearItem() {\r\n", "    stack.amount = 0;\r\n", "  }\r\n", "\r\n", "  boolean acceptsItem(Item item) {\r\n", "    return !hasItem() || item == stack.item && stack.amount + 1 <= itemCapacity();\r\n", "  }\r\n", "\r\n", "  boolean hasItem() {\r\n", "    return stack.amount > 0;\r\n", "  }\r\n", "\r\n", "  void addItem(Item item) {\r\n", "    addItem(item, 1);\r\n", "  }\r\n", "\r\n", "  void addItem(Item item, int amount) {\r\n", "    stack.amount = stack.item == item ? stack.amount + amount : amount;\r\n", "    stack.item = item;\r\n", "    stack.amount = Mathf.clamp(stack.amount, 0, itemCapacity());\r\n", "  }\r\n", "\r\n", "  int maxAccepted(Item item) {\r\n", "    return stack.item != item && stack.amount > 0 ? 0 : itemCapacity() - stack.amount;\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("LaunchCoreComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.graphics.g2d.*;\r\n", "import arc.math.*;\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.graphics.*;\r\n", "import mindustry.world.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = LaunchCorec.class, serialize = false)\r\n", "@Component\r\n", "abstract class LaunchCoreComp implements Drawc, Timedc {\r\n", "\r\n", "  @Import\r\n", "  float x, y;\r\n", "\r\n", "  transient Interval in = new Interval();\r\n", "\r\n", "  Block block;\r\n", "\r\n", "  @Override\r\n", "  public void draw() {\r\n", "    float alpha = fout(Interp.pow5Out);\r\n", "    float scale = (1f - alpha) * 1.4f + 1f;\r\n", "    float cx = cx(), cy = cy();\r\n", "    float rotation = fin() * (140f + Mathf.randomSeedRange(id(), 50f));\r\n", "    Draw.z(Layer.effect + 0.001f);\r\n", "    Draw.color(Pal.engine);\r\n", "    float rad = 0.2f + fslope();\r\n", "    float rscl = (block.size - 1) * 0.85f;\r\n", "    Fill.light(cx, cy, 10, 25f * (rad + scale - 1f) * rscl, Tmp.c2.set(Pal.engine).a(alpha), Tmp.c1.set(Pal.engine).a(0f));\r\n", "    Draw.alpha(alpha);\r\n", "    for (int i = 0; i < 4; i++) {\r\n", "      Drawf.tri(cx, cy, 6f * rscl, 40f * (rad + scale - 1f) * rscl, i * 90f + rotation);\r\n", "    }\r\n", "    Draw.color();\r\n", "    Draw.z(Layer.weather - 1);\r\n", "    TextureRegion region = block.fullIcon;\r\n", "    scale *= region.scl();\r\n", "    float rw = region.width * scale, rh = region.height * scale;\r\n", "    Draw.alpha(alpha);\r\n", "    Draw.rect(region, cx, cy, rw, rh, rotation - 45);\r\n", "    Tmp.v1.trns(225f, fin(Interp.pow3In) * 250f);\r\n", "    Draw.z(Layer.flyingUnit + 1);\r\n", "    Draw.color(0, 0, 0, 0.22f * alpha);\r\n", "    Draw.rect(region, cx + Tmp.v1.x, cy + Tmp.v1.y, rw, rh, rotation - 45);\r\n", "    Draw.reset();\r\n", "  }\r\n", "\r\n", "  float cx() {\r\n", "    return x + fin(Interp.pow2In) * (12f + Mathf.randomSeedRange(id() + 3, 4f));\r\n", "  }\r\n", "\r\n", "  float cy() {\r\n", "    return y + fin(Interp.pow5In) * (100f + Mathf.randomSeedRange(id() + 2, 30f));\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    float r = 4f;\r\n", "    if (in.get(3f - fin() * 2f)) {\r\n", "      Fx.rocketSmokeLarge.at(cx() + Mathf.range(r), cy() + Mathf.range(r), fin());\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("LegsComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.math.*;\r\n", "import arc.math.geom.*;\r\n", "import arc.util.*;\r\n", "import mindustry.*;\r\n", "import mindustry.ai.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.entities.EntityCollisions.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.graphics.*;\r\n", "import mindustry.type.*;\r\n", "import mindustry.world.blocks.environment.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class LegsComp implements Posc, Rotc, Hitboxc, Flyingc, Unitc {\r\n", "\r\n", "  private static final Vec2 straightVec = new Vec2();\r\n", "\r\n", "  @Import\r\n", "  float x, y, rotation, speedMultiplier;\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  @Import\r\n", "  Team team;\r\n", "\r\n", "  transient Leg[] legs = {};\r\n", "\r\n", "  transient float totalLength;\r\n", "\r\n", "  transient float moveSpace;\r\n", "\r\n", "  transient float baseRotation;\r\n", "\r\n", "  transient Floor lastDeepFloor;\r\n", "\r\n", "  transient Vec2 curMoveOffset = new Vec2();\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public SolidPred solidity() {\r\n", "    return type.allowLegStep ? EntityCollisions::legsSolid : EntityCollisions::solid;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public int pathType() {\r\n", "    return type.allowLegStep ? Pathfinder.costLegs : Pathfinder.costGround;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public Floor drownFloor() {\r\n", "    return lastDeepFloor;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void add() {\r\n", "    resetLegs();\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void unloaded() {\r\n", "    resetLegs(1f);\r\n", "  }\r\n", "\r\n", "  @MethodPriority(-1)\r\n", "  @Override\r\n", "  public void destroy() {\r\n", "    if (!isAdded() || Vars.headless)\r\n", "      return;\r\n", "    float legExplodeRad = type.legRegion.height / 4f / 1.45f;\r\n", "    // create effects for legs being destroyed\r\n", "    for (int i = 0; i < legs.length; i++) {\r\n", "      Leg l = legs[i];\r\n", "      Vec2 base = legOffset(Tmp.v1, i).add(x, y);\r\n", "      Tmp.v2.set(l.base).sub(l.joint).inv().setLength(type.legExtension);\r\n", "      for (Vec2 vec : new Vec2[] { base, l.joint, l.base }) {\r\n", "        Damage.dynamicExplosion(vec.x, vec.y, 0f, 0f, 0f, legExplodeRad, state.rules.damageExplosions, false, team, type.deathExplosionEffect);\r\n", "      }\r\n", "      Fx.legDestroy.at(base.x, base.y, 0f, new LegDestroyData(base.cpy(), l.joint, type.legRegion));\r\n", "      Fx.legDestroy.at(l.joint.x, l.joint.y, 0f, new LegDestroyData(l.joint.cpy().add(Tmp.v2), l.base, type.legBaseRegion));\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void resetLegs() {\r\n", "    resetLegs(type.legLength);\r\n", "  }\r\n", "\r\n", "  public void resetLegs(float legLength) {\r\n", "    int count = type.legCount;\r\n", "    this.legs = new Leg[count];\r\n", "    if (type.lockLegBase) {\r\n", "      baseRotation = rotation;\r\n", "    }\r\n", "    for (int i = 0; i < legs.length; i++) {\r\n", "      Leg l = new Leg();\r\n", "      float dstRot = legAngle(i);\r\n", "      Vec2 baseOffset = legOffset(Tmp.v5, i).add(x, y);\r\n", "      l.joint.trns(dstRot, legLength / 2f).add(baseOffset);\r\n", "      l.base.trns(dstRot, legLength).add(baseOffset);\r\n", "      legs[i] = l;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    if (Mathf.dst(deltaX(), deltaY()) > 0.001f) {\r\n", "      baseRotation = Angles.moveToward(baseRotation, Mathf.angle(deltaX(), deltaY()), type.rotateSpeed);\r\n", "    }\r\n", "    if (type.lockLegBase) {\r\n", "      baseRotation = rotation;\r\n", "    }\r\n", "    float legLength = type.legLength;\r\n", "    // set up initial leg positions\r\n", "    if (legs.length != type.legCount) {\r\n", "      resetLegs();\r\n", "    }\r\n", "    float moveSpeed = type.legSpeed;\r\n", "    int div = Math.max(legs.length / type.legGroupSize, 2);\r\n", "    moveSpace = legLength / 1.6f / (div / 2f) * type.legMoveSpace;\r\n", "    // TODO should move legs even when still, based on speed. also, to prevent \"slipping\", make sure legs move when they are too far from their destination\r\n", "    totalLength += type.legContinuousMove ? type.speed * speedMultiplier * Time.delta : Mathf.dst(deltaX(), deltaY());\r\n", "    float trns = moveSpace * 0.85f * type.legForwardScl;\r\n", "    // rotation + offset vector\r\n", "    boolean moving = moving();\r\n", "    Vec2 moveOffset = !moving ? Tmp.v4.setZero() : Tmp.v4.trns(Angles.angle(deltaX(), deltaY()), trns);\r\n", "    // make it smooth, not jumpy\r\n", "    moveOffset = curMoveOffset.lerpDelta(moveOffset, 0.1f);\r\n", "    lastDeepFloor = null;\r\n", "    int deeps = 0;\r\n", "    for (int i = 0; i < legs.length; i++) {\r\n", "      float dstRot = legAngle(i);\r\n", "      Vec2 baseOffset = legOffset(Tmp.v5, i).add(x, y);\r\n", "      Leg l = legs[i];\r\n", "      // TODO is limiting twice necessary?\r\n", "      l.joint.sub(baseOffset).clampLength(type.legMinLength * legLength / 2f, type.legMaxLength * legLength / 2f).add(baseOffset);\r\n", "      l.base.sub(baseOffset).clampLength(type.legMinLength * legLength, type.legMaxLength * legLength).add(baseOffset);\r\n", "      float stageF = (totalLength + i * type.legPairOffset) / moveSpace;\r\n", "      int stage = (int) stageF;\r\n", "      int group = stage % div;\r\n", "      boolean move = i % div == group;\r\n", "      boolean side = i < legs.length / 2;\r\n", "      // back legs have reversed directions\r\n", "      boolean backLeg = Math.abs((i + 0.5f) - legs.length / 2f) <= 0.501f;\r\n", "      if (backLeg && type.flipBackLegs)\r\n", "        side = !side;\r\n", "      if (type.flipLegSide)\r\n", "        side = !side;\r\n", "      l.moving = move;\r\n", "      l.stage = moving ? stageF % 1f : Mathf.lerpDelta(l.stage, 0f, 0.1f);\r\n", "      Floor floor = Vars.world.floorWorld(l.base.x, l.base.y);\r\n", "      if (floor.isDeep()) {\r\n", "        deeps++;\r\n", "        lastDeepFloor = floor;\r\n", "      }\r\n", "      if (l.group != group) {\r\n", "        // create effect when transitioning to a group it can't move in\r\n", "        if (!move && (moving || !type.legContinuousMove) && i % div == l.group) {\r\n", "          if (!headless && !inFogTo(player.team())) {\r\n", "            if (floor.isLiquid) {\r\n", "              floor.walkEffect.at(l.base.x, l.base.y, type.rippleScale, floor.mapColor);\r\n", "              floor.walkSound.at(x, y, 1f, floor.walkSoundVolume);\r\n", "            } else {\r\n", "              Fx.unitLandSmall.at(l.base.x, l.base.y, type.rippleScale, floor.mapColor);\r\n", "            }\r\n", "            // shake when legs contact ground\r\n", "            if (type.stepShake > 0) {\r\n", "              Effect.shake(type.stepShake, type.stepShake, l.base);\r\n", "            }\r\n", "          }\r\n", "          if (type.legSplashDamage > 0) {\r\n", "            Damage.damage(team, l.base.x, l.base.y, type.legSplashRange, type.legSplashDamage * state.rules.unitDamage(team), false, true);\r\n", "          }\r\n", "        }\r\n", "        l.group = group;\r\n", "      }\r\n", "      // leg destination\r\n", "      Vec2 legDest = Tmp.v1.trns(dstRot, legLength * type.legLengthScl).add(baseOffset).add(moveOffset);\r\n", "      // join destination\r\n", "      Vec2 jointDest = Tmp.v2;\r\n", "      InverseKinematics.solve(legLength / 2f, legLength / 2f, Tmp.v6.set(l.base).sub(baseOffset), side, jointDest);\r\n", "      jointDest.add(baseOffset);\r\n", "      Tmp.v6.set(baseOffset).lerp(l.base, 0.5f);\r\n", "      if (move) {\r\n", "        float moveFract = stageF % 1f;\r\n", "        l.base.lerpDelta(legDest, moveFract);\r\n", "        l.joint.lerpDelta(jointDest, moveFract / 2f);\r\n", "      }\r\n", "      l.joint.lerpDelta(jointDest, moveSpeed / 4f);\r\n", "      // limit again after updating\r\n", "      l.joint.sub(baseOffset).clampLength(type.legMinLength * legLength / 2f, type.legMaxLength * legLength / 2f).add(baseOffset);\r\n", "      l.base.sub(baseOffset).clampLength(type.legMinLength * legLength, type.legMaxLength * legLength).add(baseOffset);\r\n", "    }\r\n", "    // when at least 1 leg is touching land, it can't drown\r\n", "    if (deeps != legs.length || !floorOn().isDeep()) {\r\n", "      lastDeepFloor = null;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  Vec2 legOffset(Vec2 out, int index) {\r\n", "    out.trns(defaultLegAngle(index), type.legBaseOffset);\r\n", "    if (type.legStraightness > 0) {\r\n", "      straightVec.trns(defaultLegAngle(index) - baseRotation, type.legBaseOffset);\r\n", "      straightVec.y = Mathf.sign(straightVec.y) * type.legBaseOffset * type.legStraightLength;\r\n", "      straightVec.rotate(baseRotation);\r\n", "      out.lerp(straightVec, type.baseLegStraightness);\r\n", "    }\r\n", "    return out;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return outwards facing angle of leg at the specified index.\r\n", "   */\r\n", "  float legAngle(int index) {\r\n", "    if (type.legStraightness > 0) {\r\n", "      return Mathf.slerp(defaultLegAngle(index), (index >= legs.length / 2 ? -90 : 90f) + baseRotation, type.legStraightness);\r\n", "    }\r\n", "    return defaultLegAngle(index);\r\n", "  }\r\n", "\r\n", "  float defaultLegAngle(int index) {\r\n", "    return baseRotation + 360f / legs.length * index + (360f / legs.length / 2f);\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("MechComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.math.*;\r\n", "import arc.math.geom.*;\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.type.*;\r\n", "import mindustry.world.blocks.environment.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class MechComp implements Posc, Flyingc, Hitboxc, Unitc, Mechc, ElevationMovec {\r\n", "\r\n", "  @Import\r\n", "  float x, y, hitSize;\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  @SyncField(false)\r\n", "  @SyncLocal\r\n", "  float baseRotation;\r\n", "\r\n", "  transient float walkTime, walkExtension;\r\n", "\r\n", "  transient private boolean walked;\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    // trigger animation only when walking manually\r\n", "    if (walked || net.client()) {\r\n", "      float len = deltaLen();\r\n", "      baseRotation = Angles.moveToward(baseRotation, deltaAngle(), type().baseRotateSpeed * Mathf.clamp(len / type().speed / Time.delta) * Time.delta);\r\n", "      walkTime += len;\r\n", "      walked = false;\r\n", "    }\r\n", "    // update mech effects\r\n", "    float extend = walkExtend(false);\r\n", "    float base = walkExtend(true);\r\n", "    float extendScl = base % 1f;\r\n", "    float lastExtend = walkExtension;\r\n", "    if (!headless && extendScl < lastExtend && base % 2f > 1f && !isFlying() && !inFogTo(player.team())) {\r\n", "      int side = -Mathf.sign(extend);\r\n", "      float width = hitSize / 2f * side, length = type.mechStride * 1.35f;\r\n", "      float cx = x + Angles.trnsx(baseRotation, length, width), cy = y + Angles.trnsy(baseRotation, length, width);\r\n", "      if (type.stepShake > 0) {\r\n", "        Effect.shake(type.stepShake, type.stepShake, cx, cy);\r\n", "      }\r\n", "      if (type.mechStepParticles) {\r\n", "        Effect.floorDust(cx, cy, hitSize / 8f);\r\n", "      }\r\n", "    }\r\n", "    walkExtension = extendScl;\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  @Nullable\r\n", "  public Floor drownFloor() {\r\n", "    // large mechs can only drown when all the nearby floors are deep\r\n", "    if (hitSize >= 12 && canDrown()) {\r\n", "      for (Point2 p : Geometry.d8) {\r\n", "        Floor f = world.floorWorld(x + p.x * tilesize, y + p.y * tilesize);\r\n", "        if (!f.isDeep()) {\r\n", "          return null;\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "    return canDrown() ? floorOn() : null;\r\n", "  }\r\n", "\r\n", "  public float walkExtend(boolean scaled) {\r\n", "    // now ranges from -maxExtension to maxExtension*3\r\n", "    float raw = walkTime % (type.mechStride * 4);\r\n", "    if (scaled)\r\n", "      return raw / type.mechStride;\r\n", "    if (raw > type.mechStride * 3)\r\n", "      raw = raw - type.mechStride * 4;\r\n", "    else if (raw > type.mechStride * 2)\r\n", "      raw = type.mechStride * 2 - raw;\r\n", "    else if (raw > type.mechStride)\r\n", "      raw = type.mechStride * 2 - raw;\r\n", "    return raw;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public void rotateMove(Vec2 vec) {\r\n", "    // mechs use baseRotation to rotate, not rotation.\r\n", "    moveAt(Tmp.v2.trns(baseRotation, vec.len()));\r\n", "    if (!vec.isZero()) {\r\n", "      baseRotation = Angles.moveToward(baseRotation, vec.angle(), type.rotateSpeed * Math.max(Time.delta, 1));\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void moveAt(Vec2 vector, float acceleration) {\r\n", "    // mark walking state when moving in a controlled manner\r\n", "    if (!vector.isZero()) {\r\n", "      walked = true;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void approach(Vec2 vector) {\r\n", "    // mark walking state when moving in a controlled manner\r\n", "    if (!vector.isZero(0.001f)) {\r\n", "      walked = true;\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("MinerComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.*;\r\n", "import arc.graphics.*;\r\n", "import arc.graphics.g2d.*;\r\n", "import arc.math.*;\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.graphics.*;\r\n", "import mindustry.input.*;\r\n", "import mindustry.type.*;\r\n", "import mindustry.world.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class MinerComp implements Itemsc, Posc, Teamc, Rotc, Drawc {\r\n", "\r\n", "  @Import\r\n", "  float x, y, rotation, hitSize;\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  transient float mineTimer;\r\n", "\r\n", "  @Nullable\r\n", "  @SyncLocal\r\n", "  Tile mineTile;\r\n", "\r\n", "  public boolean canMine(@Nullable Item item) {\r\n", "    if (item == null)\r\n", "      return false;\r\n", "    return type.mineTier >= item.hardness;\r\n", "  }\r\n", "\r\n", "  public boolean offloadImmediately() {\r\n", "    return this.<Unit>self().isPlayer();\r\n", "  }\r\n", "\r\n", "  boolean mining() {\r\n", "    return mineTile != null && !this.<Unit>self().activelyBuilding();\r\n", "  }\r\n", "\r\n", "  @Nullable\r\n", "  public Item getMineResult(@Nullable Tile tile) {\r\n", "    if (tile == null)\r\n", "      return null;\r\n", "    Item result;\r\n", "    if (type.mineFloor && tile.block() == Blocks.air) {\r\n", "      result = tile.drop();\r\n", "    } else if (type.mineWalls) {\r\n", "      result = tile.wallDrop();\r\n", "    } else {\r\n", "      return null;\r\n", "    }\r\n", "    return canMine(result) ? result : null;\r\n", "  }\r\n", "\r\n", "  public boolean validMine(Tile tile, boolean checkDst) {\r\n", "    if (tile == null)\r\n", "      return false;\r\n", "    if (checkDst && !within(tile.worldx(), tile.worldy(), type.mineRange)) {\r\n", "      return false;\r\n", "    }\r\n", "    return getMineResult(tile) != null;\r\n", "  }\r\n", "\r\n", "  public boolean validMine(Tile tile) {\r\n", "    return validMine(tile, true);\r\n", "  }\r\n", "\r\n", "  public boolean canMine() {\r\n", "    return type.mineSpeed > 0 && type.mineTier >= 0;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    if (mineTile == null)\r\n", "      return;\r\n", "    Building core = closestCore();\r\n", "    Item item = getMineResult(mineTile);\r\n", "    if (core != null && item != null && !acceptsItem(item) && within(core, mineTransferRange) && !offloadImmediately()) {\r\n", "      int accepted = core.acceptStack(item(), stack().amount, this);\r\n", "      if (accepted > 0) {\r\n", "        Call.transferItemTo(self(), item(), accepted, mineTile.worldx() + Mathf.range(tilesize / 2f), mineTile.worldy() + Mathf.range(tilesize / 2f), core);\r\n", "        clearItem();\r\n", "      }\r\n", "    }\r\n", "    if ((!net.client() || isLocal()) && !validMine(mineTile)) {\r\n", "      mineTile = null;\r\n", "      mineTimer = 0f;\r\n", "    } else if (mining() && item != null) {\r\n", "      mineTimer += Time.delta * type.mineSpeed;\r\n", "      if (Mathf.chance(0.06 * Time.delta)) {\r\n", "        Fx.pulverizeSmall.at(mineTile.worldx() + Mathf.range(tilesize / 2f), mineTile.worldy() + Mathf.range(tilesize / 2f), 0f, item.color);\r\n", "      }\r\n", "      if (mineTimer >= 50f + (type.mineHardnessScaling ? item.hardness * 15f : 15f)) {\r\n", "        mineTimer = 0;\r\n", "        if (state.rules.sector != null && team() == state.rules.defaultTeam)\r\n", "          state.rules.sector.info.handleProduction(item, 1);\r\n", "        if (core != null && within(core, mineTransferRange) && core.acceptStack(item, 1, this) == 1 && offloadImmediately()) {\r\n", "          // add item to inventory before it is transferred\r\n", "          if (item() == item && !net.client())\r\n", "            addItem(item);\r\n", "          Call.transferItemTo(self(), item, 1, mineTile.worldx() + Mathf.range(tilesize / 2f), mineTile.worldy() + Mathf.range(tilesize / 2f), core);\r\n", "        } else if (acceptsItem(item)) {\r\n", "          // this is clientside, since items are synced anyway\r\n", "          InputHandler.transferItemToUnit(item, mineTile.worldx() + Mathf.range(tilesize / 2f), mineTile.worldy() + Mathf.range(tilesize / 2f), this);\r\n", "        } else {\r\n", "          mineTile = null;\r\n", "          mineTimer = 0f;\r\n", "        }\r\n", "      }\r\n", "      if (!headless) {\r\n", "        control.sound.loop(type.mineSound, this, type.mineSoundVolume);\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void draw() {\r\n", "    if (!mining())\r\n", "      return;\r\n", "    float focusLen = hitSize / 2f + Mathf.absin(Time.time, 1.1f, 0.5f);\r\n", "    float swingScl = 12f, swingMag = tilesize / 8f;\r\n", "    float flashScl = 0.3f;\r\n", "    float px = x + Angles.trnsx(rotation, focusLen);\r\n", "    float py = y + Angles.trnsy(rotation, focusLen);\r\n", "    float ex = mineTile.worldx() + Mathf.sin(Time.time + 48, swingScl, swingMag);\r\n", "    float ey = mineTile.worldy() + Mathf.sin(Time.time + 48, swingScl + 2f, swingMag);\r\n", "    Draw.z(Layer.flyingUnit + 0.1f);\r\n", "    Draw.color(Color.lightGray, Color.white, 1f - flashScl + Mathf.absin(Time.time, 0.5f, flashScl));\r\n", "    Drawf.laser(Core.atlas.find(\"minelaser\"), Core.atlas.find(\"minelaser-end\"), px, py, ex, ey, 0.75f);\r\n", "    if (isLocal()) {\r\n", "      Lines.stroke(1f, Pal.accent);\r\n", "      Lines.poly(mineTile.worldx(), mineTile.worldy(), 4, tilesize / 2f * Mathf.sqrt2, Time.time);\r\n", "    }\r\n", "    Draw.color();\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("OwnerComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "class OwnerComp {\r\n", "\r\n", "  Entityc owner;\r\n", "}\r\n" }));
        compMap.put("PayloadComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.*;\r\n", "import arc.math.*;\r\n", "import arc.scene.ui.layout.*;\r\n", "import arc.struct.*;\r\n", "import arc.util.*;\r\n", "import mindustry.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.core.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.game.EventType.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.type.*;\r\n", "import mindustry.world.*;\r\n", "import mindustry.world.blocks.payloads.*;\r\n", "import mindustry.world.blocks.power.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "/**\r\n", " * An entity that holds a payload.\r\n", " */\r\n", "@Component\r\n", "abstract class PayloadComp implements Posc, Rotc, Hitboxc, Unitc {\r\n", "\r\n", "  @Import\r\n", "  float x, y, rotation;\r\n", "\r\n", "  @Import\r\n", "  Team team;\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  Seq<Payload> payloads = new Seq<>();\r\n", "\r\n", "  @Nullable\r\n", "  private transient PowerGraph payloadPower;\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    if (payloadPower != null) {\r\n", "      payloadPower.clear();\r\n", "    }\r\n", "    // update power graph first, resolve everything\r\n", "    for (Payload pay : payloads) {\r\n", "      if (pay instanceof BuildPayload pb && pb.build.power != null) {\r\n", "        if (payloadPower == null)\r\n", "          payloadPower = new PowerGraph(false);\r\n", "        // pb.build.team = team;\r\n", "        pb.build.power.graph = null;\r\n", "        payloadPower.add(pb.build);\r\n", "      }\r\n", "    }\r\n", "    if (payloadPower != null) {\r\n", "      payloadPower.update();\r\n", "    }\r\n", "    for (Payload pay : payloads) {\r\n", "      // apparently BasedUser doesn't want this and several plugins use it\r\n", "      // if(pay instanceof BuildPayload build){\r\n", "      // build.build.team = team;\r\n", "      // }\r\n", "      pay.set(x, y, rotation);\r\n", "      pay.update(self(), null);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  float payloadUsed() {\r\n", "    return payloads.sumf(p -> p.size() * p.size());\r\n", "  }\r\n", "\r\n", "  boolean canPickup(Unit unit) {\r\n", "    return type.pickupUnits && payloadUsed() + unit.hitSize * unit.hitSize <= type.payloadCapacity + 0.001f && unit.team == team() && unit.isAI();\r\n", "  }\r\n", "\r\n", "  boolean canPickup(Building build) {\r\n", "    return payloadUsed() + build.block.size * build.block.size * Vars.tilesize * Vars.tilesize <= type.payloadCapacity + 0.001f && build.canPickup() && build.team == team;\r\n", "  }\r\n", "\r\n", "  boolean canPickupPayload(Payload pay) {\r\n", "    return payloadUsed() + pay.size() * pay.size() <= type.payloadCapacity + 0.001f && (type.pickupUnits || !(pay instanceof UnitPayload));\r\n", "  }\r\n", "\r\n", "  boolean hasPayload() {\r\n", "    return payloads.size > 0;\r\n", "  }\r\n", "\r\n", "  void addPayload(Payload load) {\r\n", "    payloads.add(load);\r\n", "  }\r\n", "\r\n", "  void pickup(Unit unit) {\r\n", "    unit.remove();\r\n", "    addPayload(new UnitPayload(unit));\r\n", "    Fx.unitPickup.at(unit);\r\n", "    if (Vars.net.client()) {\r\n", "      Vars.netClient.clearRemovedEntity(unit.id);\r\n", "    }\r\n", "    Events.fire(new PickupEvent(self(), unit));\r\n", "  }\r\n", "\r\n", "  void pickup(Building tile) {\r\n", "    tile.pickedUp();\r\n", "    tile.tile.remove();\r\n", "    tile.afterPickedUp();\r\n", "    addPayload(new BuildPayload(tile));\r\n", "    Fx.unitPickup.at(tile);\r\n", "    Events.fire(new PickupEvent(self(), tile));\r\n", "  }\r\n", "\r\n", "  boolean dropLastPayload() {\r\n", "    if (payloads.isEmpty())\r\n", "      return false;\r\n", "    Payload load = payloads.peek();\r\n", "    if (tryDropPayload(load)) {\r\n", "      payloads.pop();\r\n", "      return true;\r\n", "    }\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  boolean tryDropPayload(Payload payload) {\r\n", "    Tile on = tileOn();\r\n", "    // clear removed state of unit so it can be synced\r\n", "    if (Vars.net.client() && payload instanceof UnitPayload u) {\r\n", "      Vars.netClient.clearRemovedEntity(u.unit.id);\r\n", "    }\r\n", "    // drop off payload on an acceptor if possible\r\n", "    if (on != null && on.build != null && on.build.acceptPayload(on.build, payload)) {\r\n", "      Fx.unitDrop.at(on.build);\r\n", "      on.build.handlePayload(on.build, payload);\r\n", "      return true;\r\n", "    }\r\n", "    if (payload instanceof BuildPayload b) {\r\n", "      return dropBlock(b);\r\n", "    } else if (payload instanceof UnitPayload p) {\r\n", "      return dropUnit(p);\r\n", "    }\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  boolean dropUnit(UnitPayload payload) {\r\n", "    Unit u = payload.unit;\r\n", "    // can't drop ground units\r\n", "    if (!u.canPass(tileX(), tileY()) || Units.count(x, y, u.physicSize(), o -> o.isGrounded()) > 1) {\r\n", "      return false;\r\n", "    }\r\n", "    Fx.unitDrop.at(this);\r\n", "    // clients do not drop payloads\r\n", "    if (Vars.net.client())\r\n", "      return true;\r\n", "    u.set(this);\r\n", "    u.trns(Tmp.v1.rnd(Mathf.random(2f)));\r\n", "    u.rotation(rotation);\r\n", "    // reset the ID to a new value to make sure it's synced\r\n", "    u.id = EntityGroup.nextId();\r\n", "    // decrement count to prevent double increment\r\n", "    if (!u.isAdded())\r\n", "      u.team.data().updateCount(u.type, -1);\r\n", "    u.add();\r\n", "    u.unloaded();\r\n", "    Events.fire(new PayloadDropEvent(self(), u));\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return whether the tile has been successfully placed.\r\n", "   */\r\n", "  boolean dropBlock(BuildPayload payload) {\r\n", "    Building tile = payload.build;\r\n", "    int tx = World.toTile(x - tile.block.offset), ty = World.toTile(y - tile.block.offset);\r\n", "    Tile on = Vars.world.tile(tx, ty);\r\n", "    if (on != null && Build.validPlace(tile.block, tile.team, tx, ty, tile.rotation, false)) {\r\n", "      payload.place(on, tile.rotation);\r\n", "      Events.fire(new PayloadDropEvent(self(), tile));\r\n", "      if (getControllerName() != null) {\r\n", "        payload.build.lastAccessed = getControllerName();\r\n", "      }\r\n", "      Fx.unitDrop.at(tile);\r\n", "      on.block().placeEffect.at(on.drawx(), on.drawy(), on.block().size);\r\n", "      return true;\r\n", "    }\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  void contentInfo(Table table, float itemSize, float width) {\r\n", "    table.clear();\r\n", "    table.top().left();\r\n", "    float pad = 0;\r\n", "    float items = payloads.size;\r\n", "    if (itemSize * items + pad * items > width) {\r\n", "      pad = (width - (itemSize) * items) / items;\r\n", "    }\r\n", "    for (Payload p : payloads) {\r\n", "      table.image(p.icon()).size(itemSize).padRight(pad);\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("PhysicsComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.math.*;\r\n", "import arc.math.geom.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.async.PhysicsProcess.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "/**\r\n", " * Affected by physics.\r\n", " * Will bounce off of other objects that are at similar elevations.\r\n", " * Has mass.\r\n", " */\r\n", "@Component\r\n", "abstract class PhysicsComp implements Velc, Hitboxc, Flyingc {\r\n", "\r\n", "  @Import\r\n", "  float hitSize, x, y;\r\n", "\r\n", "  @Import\r\n", "  Vec2 vel;\r\n", "\r\n", "  transient PhysicRef physref;\r\n", "\r\n", "  // mass is simply the area of this object\r\n", "  float mass() {\r\n", "    return hitSize * hitSize * Mathf.pi;\r\n", "  }\r\n", "\r\n", "  void impulse(float x, float y) {\r\n", "    float mass = mass();\r\n", "    vel.add(x / mass, y / mass);\r\n", "  }\r\n", "\r\n", "  void impulse(Vec2 v) {\r\n", "    impulse(v.x, v.y);\r\n", "  }\r\n", "\r\n", "  void impulseNet(Vec2 v) {\r\n", "    impulse(v.x, v.y);\r\n", "    // manually move units to simulate velocity for remote players\r\n", "    if (isRemote()) {\r\n", "      float mass = mass();\r\n", "      move(v.x / mass, v.y / mass);\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("PlayerComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.*;\r\n", "import arc.graphics.*;\r\n", "import arc.graphics.g2d.*;\r\n", "import arc.math.*;\r\n", "import arc.scene.ui.layout.*;\r\n", "import arc.util.*;\r\n", "import arc.util.pooling.*;\r\n", "import mindustry.*;\r\n", "import mindustry.ai.*;\r\n", "import mindustry.ai.types.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.entities.units.*;\r\n", "import mindustry.game.EventType.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.graphics.*;\r\n", "import mindustry.net.Administration.*;\r\n", "import mindustry.net.*;\r\n", "import mindustry.net.Packets.*;\r\n", "import mindustry.ui.*;\r\n", "import mindustry.world.blocks.storage.*;\r\n", "import mindustry.world.blocks.storage.CoreBlock.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { Playerc.class }, serialize = false)\r\n", "@Component(base = true)\r\n", "abstract class PlayerComp implements UnitController, Entityc, Syncc, Timerc, Drawc {\r\n", "\r\n", "  static final float deathDelay = 60f;\r\n", "\r\n", "  @Import\r\n", "  float x, y;\r\n", "\r\n", "  @ReadOnly\r\n", "  Unit unit = Nulls.unit;\r\n", "\r\n", "  @Nullable\r\n", "  transient NetConnection con;\r\n", "\r\n", "  @ReadOnly\r\n", "  Team team = Team.sharded;\r\n", "\r\n", "  @SyncLocal\r\n", "  boolean typing, shooting, boosting;\r\n", "\r\n", "  @SyncLocal\r\n", "  float mouseX, mouseY;\r\n", "\r\n", "  /**\r\n", "   * command the unit had before it was controlled.\r\n", "   */\r\n", "  @Nullable\r\n", "  @NoSync\r\n", "  UnitCommand lastCommand;\r\n", "\r\n", "  boolean admin;\r\n", "\r\n", "  String name = \"frog\";\r\n", "\r\n", "  Color color = new Color();\r\n", "\r\n", "  transient String locale = \"en\";\r\n", "\r\n", "  transient float deathTimer;\r\n", "\r\n", "  transient String lastText = \"\";\r\n", "\r\n", "  transient float textFadeTime;\r\n", "\r\n", "  transient private Unit lastReadUnit = Nulls.unit;\r\n", "\r\n", "  transient private int wrongReadUnits;\r\n", "\r\n", "  @Nullable\r\n", "  transient Unit justSwitchFrom, justSwitchTo;\r\n", "\r\n", "  public boolean isBuilder() {\r\n", "    return unit.canBuild();\r\n", "  }\r\n", "\r\n", "  @Nullable\r\n", "  public CoreBuild closestCore() {\r\n", "    return state.teams.closestCore(x, y, team);\r\n", "  }\r\n", "\r\n", "  @Nullable\r\n", "  public CoreBuild core() {\r\n", "    return team.core();\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return largest/closest core, with largest cores getting priority\r\n", "   */\r\n", "  @Nullable\r\n", "  public CoreBuild bestCore() {\r\n", "    return team.cores().min(Structs.comps(Structs.comparingInt(c -> -c.block.size), Structs.comparingFloat(c -> c.dst(x, y))));\r\n", "  }\r\n", "\r\n", "  public TextureRegion icon() {\r\n", "    // display default icon for dead players\r\n", "    if (dead())\r\n", "      return core() == null ? UnitTypes.alpha.fullIcon : ((CoreBlock) bestCore().block).unitType.fullIcon;\r\n", "    return unit.icon();\r\n", "  }\r\n", "\r\n", "  public boolean displayAmmo() {\r\n", "    return unit instanceof BlockUnitc || state.rules.unitAmmo;\r\n", "  }\r\n", "\r\n", "  public void reset() {\r\n", "    team = state.rules.defaultTeam;\r\n", "    admin = typing = false;\r\n", "    textFadeTime = 0f;\r\n", "    x = y = 0f;\r\n", "    if (!dead()) {\r\n", "      unit.resetController();\r\n", "      unit = Nulls.unit;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public boolean isValidController() {\r\n", "    return isAdded();\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public boolean isLogicControllable() {\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  public float clipSize() {\r\n", "    return unit.isNull() ? 20 : unit.type.hitSize * 2f;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void afterSync() {\r\n", "    // fix rubberbanding:\r\n", "    // when the player recs a unit that they JUST transitioned away from, use the new unit instead\r\n", "    // reason: we know the server is lying here, essentially skip the unit snapshot because we know the client's information is more recent\r\n", "    if (isLocal() && unit == justSwitchFrom && justSwitchFrom != null && justSwitchTo != null) {\r\n", "      unit = justSwitchTo;\r\n", "      // if several snapshots have passed and this unit is still incorrect, something's wrong\r\n", "      if (++wrongReadUnits >= 2) {\r\n", "        justSwitchFrom = null;\r\n", "        wrongReadUnits = 0;\r\n", "      }\r\n", "    } else {\r\n", "      justSwitchFrom = null;\r\n", "      justSwitchTo = null;\r\n", "      wrongReadUnits = 0;\r\n", "    }\r\n", "    // simulate a unit change after sync\r\n", "    Unit set = unit;\r\n", "    unit = lastReadUnit;\r\n", "    unit(set);\r\n", "    lastReadUnit = unit;\r\n", "    unit.aim(mouseX, mouseY);\r\n", "    // this is only necessary when the thing being controlled isn't synced\r\n", "    unit.controlWeapons(shooting, shooting);\r\n", "    // extra precaution, necessary for non-synced things\r\n", "    unit.controller(this);\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    if (!unit.isValid()) {\r\n", "      clearUnit();\r\n", "    }\r\n", "    CoreBuild core;\r\n", "    if (!dead()) {\r\n", "      set(unit);\r\n", "      unit.team(team);\r\n", "      deathTimer = 0;\r\n", "      // update some basic state to sync things\r\n", "      if (unit.type.canBoost) {\r\n", "        unit.elevation = Mathf.approachDelta(unit.elevation, unit.onSolid() || boosting || (unit.isFlying() && !unit.canLand()) ? 1f : 0f, unit.type.riseSpeed);\r\n", "      }\r\n", "    } else if ((core = bestCore()) != null) {\r\n", "      // have a small delay before death to prevent the camera from jumping around too quickly\r\n", "      // (this is not for balance, it just looks better this way)\r\n", "      deathTimer += Time.delta;\r\n", "      if (deathTimer >= deathDelay) {\r\n", "        // request spawn - this happens serverside only\r\n", "        core.requestSpawn(self());\r\n", "        deathTimer = 0;\r\n", "      }\r\n", "    }\r\n", "    textFadeTime -= Time.delta / (60 * 5);\r\n", "  }\r\n", "\r\n", "  public void checkSpawn() {\r\n", "    CoreBuild core = bestCore();\r\n", "    if (core != null) {\r\n", "      core.requestSpawn(self());\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void remove() {\r\n", "    // clear unit upon removal\r\n", "    if (!unit.isNull()) {\r\n", "      clearUnit();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void team(Team team) {\r\n", "    this.team = team;\r\n", "    unit.team(team);\r\n", "  }\r\n", "\r\n", "  public void clearUnit() {\r\n", "    unit(Nulls.unit);\r\n", "  }\r\n", "\r\n", "  public Unit unit() {\r\n", "    return unit;\r\n", "  }\r\n", "\r\n", "  public void unit(Unit unit) {\r\n", "    // refuse to switch when the unit was just transitioned from\r\n", "    if (isLocal() && unit == justSwitchFrom && justSwitchFrom != null && justSwitchTo != null) {\r\n", "      return;\r\n", "    }\r\n", "    if (unit == null)\r\n", "      throw new IllegalArgumentException(\"Unit cannot be null. Use clearUnit() instead.\");\r\n", "    if (this.unit == unit)\r\n", "      return;\r\n", "    // save last command this unit had\r\n", "    if (unit.controller() instanceof CommandAI ai) {\r\n", "      lastCommand = ai.command;\r\n", "    }\r\n", "    if (this.unit != Nulls.unit) {\r\n", "      // un-control the old unit\r\n", "      this.unit.resetController();\r\n", "      // restore last command issued before it was controlled\r\n", "      if (lastCommand != null && this.unit.controller() instanceof CommandAI ai) {\r\n", "        ai.command(lastCommand);\r\n", "      }\r\n", "    }\r\n", "    this.unit = unit;\r\n", "    if (unit != Nulls.unit) {\r\n", "      unit.team(team);\r\n", "      unit.controller(this);\r\n", "      // this player just became remote, snap the interpolation so it doesn't go wild\r\n", "      if (unit.isRemote()) {\r\n", "        unit.snapInterpolation();\r\n", "      }\r\n", "      // reset selected block when switching units\r\n", "      if (!headless && isLocal()) {\r\n", "        control.input.block = null;\r\n", "      }\r\n", "    }\r\n", "    Events.fire(new UnitChangeEvent(self(), unit));\r\n", "  }\r\n", "\r\n", "  boolean dead() {\r\n", "    return unit.isNull() || !unit.isValid();\r\n", "  }\r\n", "\r\n", "  String ip() {\r\n", "    return con == null ? \"localhost\" : con.address;\r\n", "  }\r\n", "\r\n", "  String uuid() {\r\n", "    return con == null ? \"[LOCAL]\" : con.uuid;\r\n", "  }\r\n", "\r\n", "  String usid() {\r\n", "    return con == null ? \"[LOCAL]\" : con.usid;\r\n", "  }\r\n", "\r\n", "  void kick(KickReason reason) {\r\n", "    con.kick(reason);\r\n", "  }\r\n", "\r\n", "  void kick(KickReason reason, long duration) {\r\n", "    con.kick(reason, duration);\r\n", "  }\r\n", "\r\n", "  void kick(String reason) {\r\n", "    con.kick(reason);\r\n", "  }\r\n", "\r\n", "  void kick(String reason, long duration) {\r\n", "    con.kick(reason, duration);\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void draw() {\r\n", "    if (unit != null && unit.inFogTo(Vars.player.team()))\r\n", "      return;\r\n", "    // ??????\r\n", "    if (name == null)\r\n", "      return;\r\n", "    Draw.z(Layer.playerName);\r\n", "    float z = Drawf.text();\r\n", "    Font font = Fonts.outline;\r\n", "    GlyphLayout layout = Pools.obtain(GlyphLayout.class, GlyphLayout::new);\r\n", "    final float nameHeight = 11;\r\n", "    final float textHeight = 15;\r\n", "    boolean ints = font.usesIntegerPositions();\r\n", "    font.setUseIntegerPositions(false);\r\n", "    font.getData().setScale(0.25f / Scl.scl(1f));\r\n", "    layout.setText(font, name);\r\n", "    if (!isLocal()) {\r\n", "      Draw.color(0f, 0f, 0f, 0.3f);\r\n", "      Fill.rect(unit.x, unit.y + nameHeight - layout.height / 2, layout.width + 2, layout.height + 3);\r\n", "      Draw.color();\r\n", "      font.setColor(color);\r\n", "      font.draw(name, unit.x, unit.y + nameHeight, 0, Align.center, false);\r\n", "      if (admin) {\r\n", "        float s = 3f;\r\n", "        Draw.color(color.r * 0.5f, color.g * 0.5f, color.b * 0.5f, 1f);\r\n", "        Draw.rect(Icon.adminSmall.getRegion(), unit.x + layout.width / 2f + 2 + 1, unit.y + nameHeight - 1.5f, s, s);\r\n", "        Draw.color(color);\r\n", "        Draw.rect(Icon.adminSmall.getRegion(), unit.x + layout.width / 2f + 2 + 1, unit.y + nameHeight - 1f, s, s);\r\n", "      }\r\n", "    }\r\n", "    if (Core.settings.getBool(\"playerchat\") && ((textFadeTime > 0 && lastText != null) || typing)) {\r\n", "      String text = textFadeTime <= 0 || lastText == null ? \"[lightgray]\" + Strings.animated(Time.time, 4, 15f, \".\") : lastText;\r\n", "      float width = 100f;\r\n", "      float visualFadeTime = 1f - Mathf.curve(1f - textFadeTime, 0.9f);\r\n", "      font.setColor(1f, 1f, 1f, textFadeTime <= 0 || lastText == null ? 1f : visualFadeTime);\r\n", "      layout.setText(font, text, Color.white, width, Align.bottom, true);\r\n", "      Draw.color(0f, 0f, 0f, 0.3f * (textFadeTime <= 0 || lastText == null ? 1f : visualFadeTime));\r\n", "      Fill.rect(unit.x, unit.y + textHeight + layout.height - layout.height / 2f, layout.width + 2, layout.height + 3);\r\n", "      font.draw(text, unit.x - width / 2f, unit.y + textHeight + layout.height, width, Align.center, true);\r\n", "    }\r\n", "    Draw.reset();\r\n", "    Pools.free(layout);\r\n", "    font.getData().setScale(1f);\r\n", "    font.setColor(Color.white);\r\n", "    font.setUseIntegerPositions(ints);\r\n", "    Draw.z(z);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return name with a markup color prefix\r\n", "   */\r\n", "  String coloredName() {\r\n", "    return \"[#\" + color.toString().toUpperCase() + \"]\" + name;\r\n", "  }\r\n", "\r\n", "  String plainName() {\r\n", "    return Strings.stripColors(name);\r\n", "  }\r\n", "\r\n", "  void sendMessage(String text) {\r\n", "    sendMessage(text, null, null);\r\n", "  }\r\n", "\r\n", "  void sendMessage(String text, Player from) {\r\n", "    sendMessage(text, from, null);\r\n", "  }\r\n", "\r\n", "  void sendMessage(String text, Player from, String unformatted) {\r\n", "    if (isLocal()) {\r\n", "      if (ui != null) {\r\n", "        ui.chatfrag.addMessage(text);\r\n", "      }\r\n", "    } else {\r\n", "      Call.sendMessage(con, text, unformatted, from);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  void sendUnformatted(String unformatted) {\r\n", "    sendUnformatted(null, unformatted);\r\n", "  }\r\n", "\r\n", "  void sendUnformatted(Player from, String unformatted) {\r\n", "    sendMessage(netServer.chatFormatter.format(from, unformatted), from, unformatted);\r\n", "  }\r\n", "\r\n", "  PlayerInfo getInfo() {\r\n", "    if (isLocal()) {\r\n", "      throw new IllegalArgumentException(\"Local players cannot be traced and do not have info.\");\r\n", "    } else {\r\n", "      return netServer.admins.getInfo(uuid());\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("PosComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.math.geom.*;\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.core.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.world.*;\r\n", "import mindustry.world.blocks.environment.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class PosComp implements Position {\r\n", "\r\n", "  @SyncField(true)\r\n", "  @SyncLocal\r\n", "  float x, y;\r\n", "\r\n", "  void set(float x, float y) {\r\n", "    this.x = x;\r\n", "    this.y = y;\r\n", "  }\r\n", "\r\n", "  void set(Position pos) {\r\n", "    set(pos.getX(), pos.getY());\r\n", "  }\r\n", "\r\n", "  void trns(float x, float y) {\r\n", "    set(this.x + x, this.y + y);\r\n", "  }\r\n", "\r\n", "  void trns(Position pos) {\r\n", "    trns(pos.getX(), pos.getY());\r\n", "  }\r\n", "\r\n", "  int tileX() {\r\n", "    return World.toTile(x);\r\n", "  }\r\n", "\r\n", "  int tileY() {\r\n", "    return World.toTile(y);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Returns air if this unit is on a non-air top block.\r\n", "   */\r\n", "  Floor floorOn() {\r\n", "    Tile tile = tileOn();\r\n", "    return tile == null || tile.block() != Blocks.air ? (Floor) Blocks.air : tile.floor();\r\n", "  }\r\n", "\r\n", "  Block blockOn() {\r\n", "    Tile tile = tileOn();\r\n", "    return tile == null ? Blocks.air : tile.block();\r\n", "  }\r\n", "\r\n", "  @Nullable\r\n", "  Building buildOn() {\r\n", "    return world.buildWorld(x, y);\r\n", "  }\r\n", "\r\n", "  @Nullable\r\n", "  Tile tileOn() {\r\n", "    return world.tileWorld(x, y);\r\n", "  }\r\n", "\r\n", "  boolean onSolid() {\r\n", "    Tile tile = tileOn();\r\n", "    return tile == null || tile.solid();\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public float getX() {\r\n", "    return x;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public float getY() {\r\n", "    return y;\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("PosTeamDef",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "// dummy target definition\r\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = Teamc.class, genio = false, isFinal = false)\r\n", "public class PosTeamDef {\r\n", "}\r\n" }));
        compMap.put("PowerGraphUpdaterComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.world.blocks.power.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = PowerGraphUpdaterc.class, serialize = false, genio = false)\r\n", "@Component\r\n", "abstract class PowerGraphUpdaterComp implements Entityc {\r\n", "\r\n", "  public transient PowerGraph graph;\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    graph.update();\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("PuddleComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.func.*;\r\n", "import arc.graphics.g2d.*;\r\n", "import arc.math.*;\r\n", "import arc.math.geom.*;\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.graphics.*;\r\n", "import mindustry.type.*;\r\n", "import mindustry.world.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.entities.Puddles.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { Puddlec.class }, pooled = true)\r\n", "@Component(base = true)\r\n", "abstract class PuddleComp implements Posc, Puddlec, Drawc, Syncc {\r\n", "\r\n", "  private static final Rect rect = new Rect(), rect2 = new Rect();\r\n", "\r\n", "  private static Puddle paramPuddle;\r\n", "\r\n", "  private static Cons<Unit> unitCons = unit -> {\r\n", "    if (unit.isGrounded() && !unit.hovering) {\r\n", "      unit.hitbox(rect2);\r\n", "      if (rect.overlaps(rect2)) {\r\n", "        unit.apply(paramPuddle.liquid.effect, 60 * 2);\r\n", "        if (unit.vel.len2() > 0.1f * 0.1f) {\r\n", "          Fx.ripple.at(unit.x, unit.y, unit.type.rippleScale, paramPuddle.liquid.color);\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "  };\r\n", "\r\n", "  @Import\r\n", "  int id;\r\n", "\r\n", "  @Import\r\n", "  float x, y;\r\n", "\r\n", "  @Import\r\n", "  boolean added;\r\n", "\r\n", "  transient float accepting, updateTime, lastRipple = Time.time + Mathf.random(40f), effectTime = Mathf.random(50f);\r\n", "\r\n", "  float amount;\r\n", "\r\n", "  Tile tile;\r\n", "\r\n", "  Liquid liquid;\r\n", "\r\n", "  public float getFlammability() {\r\n", "    return liquid.flammability * amount;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    if (liquid == null || tile == null) {\r\n", "      remove();\r\n", "      return;\r\n", "    }\r\n", "    float addSpeed = accepting > 0 ? 3f : 0f;\r\n", "    amount -= Time.delta * (1f - liquid.viscosity) / (5f + addSpeed);\r\n", "    amount += accepting;\r\n", "    accepting = 0f;\r\n", "    if (amount >= maxLiquid / 1.5f) {\r\n", "      float deposited = Math.min((amount - maxLiquid / 1.5f) / 4f, 0.3f * Time.delta);\r\n", "      int targets = 0;\r\n", "      for (Point2 point : Geometry.d4) {\r\n", "        Tile other = world.tile(tile.x + point.x, tile.y + point.y);\r\n", "        if (other != null && (other.block() == Blocks.air || liquid.moveThroughBlocks)) {\r\n", "          targets++;\r\n", "          Puddles.deposit(other, tile, liquid, deposited, false);\r\n", "        }\r\n", "      }\r\n", "      amount -= deposited * targets;\r\n", "    }\r\n", "    if (liquid.capPuddles) {\r\n", "      amount = Mathf.clamp(amount, 0, maxLiquid);\r\n", "    }\r\n", "    if (amount <= 0f) {\r\n", "      remove();\r\n", "      return;\r\n", "    }\r\n", "    if (Puddles.get(tile) != self() && added) {\r\n", "      // force removal without pool free\r\n", "      Groups.all.remove(self());\r\n", "      Groups.draw.remove(self());\r\n", "      Groups.puddle.remove(self());\r\n", "      added = false;\r\n", "      return;\r\n", "    }\r\n", "    // effects-only code\r\n", "    if (amount >= maxLiquid / 2f && updateTime <= 0f) {\r\n", "      paramPuddle = self();\r\n", "      Units.nearby(rect.setSize(Mathf.clamp(amount / (maxLiquid / 1.5f)) * 10f).setCenter(x, y), unitCons);\r\n", "      if (liquid.temperature > 0.7f && tile.build != null && Mathf.chance(0.5)) {\r\n", "        Fires.create(tile);\r\n", "      }\r\n", "      updateTime = 40f;\r\n", "    }\r\n", "    if (!headless && liquid.particleEffect != Fx.none) {\r\n", "      if ((effectTime += Time.delta) >= liquid.particleSpacing) {\r\n", "        float size = Mathf.clamp(amount / (maxLiquid / 1.5f)) * 4f;\r\n", "        liquid.particleEffect.at(x + Mathf.range(size), y + Mathf.range(size));\r\n", "        effectTime = 0f;\r\n", "      }\r\n", "    }\r\n", "    updateTime -= Time.delta;\r\n", "    liquid.update(self());\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void draw() {\r\n", "    Draw.z(Layer.debris - 1);\r\n", "    liquid.drawPuddle(self());\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  public float clipSize() {\r\n", "    // high for light drawing\r\n", "    return 50;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void remove() {\r\n", "    Puddles.remove(tile);\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void afterRead() {\r\n", "    Puddles.register(self());\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void afterSync() {\r\n", "    if (liquid != null) {\r\n", "      Puddles.register(self());\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("RotComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class RotComp implements Entityc {\r\n", "\r\n", "  @SyncField(false)\r\n", "  @SyncLocal\r\n", "  float rotation;\r\n", "}\r\n" }));
        compMap.put("ShieldComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.util.*;\r\n", "import mindustry.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.type.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class ShieldComp implements Healthc, Posc {\r\n", "\r\n", "  @Import\r\n", "  float health, hitTime, x, y, healthMultiplier;\r\n", "\r\n", "  @Import\r\n", "  boolean dead;\r\n", "\r\n", "  @Import\r\n", "  Team team;\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  /**\r\n", "   * Absorbs health damage.\r\n", "   */\r\n", "  float shield;\r\n", "\r\n", "  /**\r\n", "   * Subtracts an amount from damage. No need to save.\r\n", "   */\r\n", "  transient float armor;\r\n", "\r\n", "  /**\r\n", "   * Shield opacity.\r\n", "   */\r\n", "  transient float shieldAlpha = 0f;\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public void damage(float amount) {\r\n", "    // apply armor and scaling effects\r\n", "    rawDamage(Damage.applyArmor(amount, armor) / healthMultiplier / Vars.state.rules.unitHealth(team));\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public void damagePierce(float amount, boolean withEffect) {\r\n", "    float pre = hitTime;\r\n", "    rawDamage(amount / healthMultiplier / Vars.state.rules.unitHealth(team));\r\n", "    if (!withEffect) {\r\n", "      hitTime = pre;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  protected void rawDamage(float amount) {\r\n", "    boolean hadShields = shield > 0.0001f;\r\n", "    if (hadShields) {\r\n", "      shieldAlpha = 1f;\r\n", "    }\r\n", "    float shieldDamage = Math.min(Math.max(shield, 0), amount);\r\n", "    shield -= shieldDamage;\r\n", "    hitTime = 1f;\r\n", "    amount -= shieldDamage;\r\n", "    if (amount > 0 && type.killable) {\r\n", "      health -= amount;\r\n", "      if (health <= 0 && !dead) {\r\n", "        kill();\r\n", "      }\r\n", "      if (hadShields && shield <= 0.0001f) {\r\n", "        Fx.unitShieldBreak.at(x, y, 0, team.color, this);\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    shieldAlpha -= Time.delta / 15f;\r\n", "    if (shieldAlpha < 0)\r\n", "      shieldAlpha = 0f;\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("ShielderComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class ShielderComp implements Damagec, Teamc, Posc {\r\n", "\r\n", "  void absorb() {\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("StatusComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.graphics.*;\r\n", "import arc.struct.*;\r\n", "import arc.util.*;\r\n", "import arc.util.pooling.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.ctype.*;\r\n", "import mindustry.entities.units.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.type.*;\r\n", "import mindustry.world.blocks.environment.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class StatusComp implements Posc, Flyingc {\r\n", "\r\n", "  private Seq<StatusEntry> statuses = new Seq<>();\r\n", "\r\n", "  private transient Bits applied = new Bits(content.getBy(ContentType.status).size);\r\n", "\r\n", "  // these are considered read-only\r\n", "  transient float speedMultiplier = 1, damageMultiplier = 1, healthMultiplier = 1, reloadMultiplier = 1, buildSpeedMultiplier = 1, dragMultiplier = 1;\r\n", "\r\n", "  transient boolean disarmed = false;\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  /**\r\n", "   * Apply a status effect for 1 tick (for permanent effects) *\r\n", "   */\r\n", "  void apply(StatusEffect effect) {\r\n", "    apply(effect, 1);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Adds a status effect to this unit.\r\n", "   */\r\n", "  void apply(StatusEffect effect, float duration) {\r\n", "    // don't apply empty or immune effects\r\n", "    if (effect == StatusEffects.none || effect == null || isImmune(effect))\r\n", "      return;\r\n", "    // unlock status effects regardless of whether they were applied to friendly units\r\n", "    if (state.isCampaign()) {\r\n", "      effect.unlock();\r\n", "    }\r\n", "    if (statuses.size > 0) {\r\n", "      // check for opposite effects\r\n", "      for (int i = 0; i < statuses.size; i++) {\r\n", "        StatusEntry entry = statuses.get(i);\r\n", "        // extend effect\r\n", "        if (entry.effect == effect) {\r\n", "          entry.time = Math.max(entry.time, duration);\r\n", "          effect.applied(self(), entry.time, true);\r\n", "          return;\r\n", "        } else if (entry.effect.applyTransition(self(), effect, entry, duration)) {\r\n", "          // find reaction\r\n", "          // TODO effect may react with multiple other effects\r\n", "          // stop looking when one is found\r\n", "          return;\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "    if (!effect.reactive) {\r\n", "      // otherwise, no opposites found, add direct effect\r\n", "      StatusEntry entry = Pools.obtain(StatusEntry.class, StatusEntry::new);\r\n", "      entry.set(effect, duration);\r\n", "      statuses.add(entry);\r\n", "      effect.applied(self(), duration, false);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  float getDuration(StatusEffect effect) {\r\n", "    var entry = statuses.find(e -> e.effect == effect);\r\n", "    return entry == null ? 0 : entry.time;\r\n", "  }\r\n", "\r\n", "  void clearStatuses() {\r\n", "    statuses.clear();\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Removes a status effect.\r\n", "   */\r\n", "  void unapply(StatusEffect effect) {\r\n", "    statuses.remove(e -> {\r\n", "      if (e.effect == effect) {\r\n", "        Pools.free(e);\r\n", "        return true;\r\n", "      }\r\n", "      return false;\r\n", "    });\r\n", "  }\r\n", "\r\n", "  boolean isBoss() {\r\n", "    return hasEffect(StatusEffects.boss);\r\n", "  }\r\n", "\r\n", "  abstract boolean isImmune(StatusEffect effect);\r\n", "\r\n", "  Color statusColor() {\r\n", "    if (statuses.size == 0) {\r\n", "      return Tmp.c1.set(Color.white);\r\n", "    }\r\n", "    float r = 1f, g = 1f, b = 1f, total = 0f;\r\n", "    for (StatusEntry entry : statuses) {\r\n", "      float intensity = entry.time < 10f ? entry.time / 10f : 1f;\r\n", "      r += entry.effect.color.r * intensity;\r\n", "      g += entry.effect.color.g * intensity;\r\n", "      b += entry.effect.color.b * intensity;\r\n", "      total += intensity;\r\n", "    }\r\n", "    float count = statuses.size + total;\r\n", "    return Tmp.c1.set(r / count, g / count, b / count, 1f);\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    Floor floor = floorOn();\r\n", "    if (isGrounded() && !type.hovering) {\r\n", "      // apply effect\r\n", "      apply(floor.status, floor.statusDuration);\r\n", "    }\r\n", "    applied.clear();\r\n", "    speedMultiplier = damageMultiplier = healthMultiplier = reloadMultiplier = buildSpeedMultiplier = dragMultiplier = 1f;\r\n", "    disarmed = false;\r\n", "    if (statuses.isEmpty())\r\n", "      return;\r\n", "    int index = 0;\r\n", "    while (index < statuses.size) {\r\n", "      StatusEntry entry = statuses.get(index++);\r\n", "      entry.time = Math.max(entry.time - Time.delta, 0);\r\n", "      if (entry.effect == null || (entry.time <= 0 && !entry.effect.permanent)) {\r\n", "        Pools.free(entry);\r\n", "        index--;\r\n", "        statuses.remove(index);\r\n", "      } else {\r\n", "        applied.set(entry.effect.id);\r\n", "        speedMultiplier *= entry.effect.speedMultiplier;\r\n", "        healthMultiplier *= entry.effect.healthMultiplier;\r\n", "        damageMultiplier *= entry.effect.damageMultiplier;\r\n", "        reloadMultiplier *= entry.effect.reloadMultiplier;\r\n", "        buildSpeedMultiplier *= entry.effect.buildSpeedMultiplier;\r\n", "        dragMultiplier *= entry.effect.dragMultiplier;\r\n", "        disarmed |= entry.effect.disarm;\r\n", "        entry.effect.update(self(), entry.time);\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public Bits statusBits() {\r\n", "    return applied;\r\n", "  }\r\n", "\r\n", "  public void draw() {\r\n", "    for (StatusEntry e : statuses) {\r\n", "      e.effect.draw(self(), e.time);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  boolean hasEffect(StatusEffect effect) {\r\n", "    return applied.get(effect.id);\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("SyncComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.util.io.*;\r\n", "import mindustry.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import java.nio.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class SyncComp implements Entityc {\r\n", "\r\n", "  transient long lastUpdated, updateSpacing;\r\n", "\r\n", "  // all these method bodies are internally generated\r\n", "  void snapSync() {\r\n", "  }\r\n", "\r\n", "  void snapInterpolation() {\r\n", "  }\r\n", "\r\n", "  void readSync(Reads read) {\r\n", "  }\r\n", "\r\n", "  void writeSync(Writes write) {\r\n", "  }\r\n", "\r\n", "  void readSyncManual(FloatBuffer buffer) {\r\n", "  }\r\n", "\r\n", "  void writeSyncManual(FloatBuffer buffer) {\r\n", "  }\r\n", "\r\n", "  void afterSync() {\r\n", "  }\r\n", "\r\n", "  void interpolate() {\r\n", "  }\r\n", "\r\n", "  boolean isSyncHidden(Player player) {\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  void handleSyncHidden() {\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    // interpolate the player if:\r\n", "    // - this is a client and the entity is everything except the local player\r\n", "    // - this is a server and the entity is a remote player\r\n", "    if ((Vars.net.client() && !isLocal()) || isRemote()) {\r\n", "      interpolate();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void remove() {\r\n", "    // notify client of removal\r\n", "    if (Vars.net.client()) {\r\n", "      Vars.netClient.addRemovedEntity(id());\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("TankComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.math.*;\r\n", "import arc.math.geom.*;\r\n", "import arc.util.*;\r\n", "import mindustry.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.type.*;\r\n", "import mindustry.world.*;\r\n", "import mindustry.world.blocks.environment.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class TankComp implements Posc, Flyingc, Hitboxc, Unitc, ElevationMovec {\r\n", "\r\n", "  @Import\r\n", "  float x, y, hitSize, rotation, speedMultiplier;\r\n", "\r\n", "  @Import\r\n", "  boolean hovering;\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  @Import\r\n", "  Team team;\r\n", "\r\n", "  transient private float treadEffectTime, lastSlowdown = 1f;\r\n", "\r\n", "  transient float treadTime;\r\n", "\r\n", "  transient boolean walked;\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    // dust\r\n", "    if ((walked || (net.client() && deltaLen() >= 0.01f)) && !headless && !inFogTo(player.team())) {\r\n", "      treadEffectTime += Time.delta;\r\n", "      if (treadEffectTime >= 6f && type.treadRects.length > 0) {\r\n", "        // first rect should always be at the back\r\n", "        var treadRect = type.treadRects[0];\r\n", "        float xOffset = (-(treadRect.x + treadRect.width / 2f)) / 4f;\r\n", "        float yOffset = (-(treadRect.y + treadRect.height / 2f)) / 4f;\r\n", "        for (int i : Mathf.signs) {\r\n", "          Tmp.v1.set(xOffset * i, yOffset - treadRect.height / 2f / 4f).rotate(rotation - 90);\r\n", "          // TODO could fin for a while\r\n", "          Effect.floorDustAngle(type.treadEffect, Tmp.v1.x + x, Tmp.v1.y + y, rotation + 180f);\r\n", "        }\r\n", "        treadEffectTime = 0f;\r\n", "      }\r\n", "    }\r\n", "    // calculate overlapping tiles so it slows down when going \"over\" walls\r\n", "    int r = Math.max(Math.round(hitSize * 0.6f / tilesize), 1);\r\n", "    int solids = 0, total = (r * 2 + 1) * (r * 2 + 1);\r\n", "    for (int dx = -r; dx <= r; dx++) {\r\n", "      for (int dy = -r; dy <= r; dy++) {\r\n", "        Tile t = Vars.world.tileWorld(x + dx * tilesize, y + dy * tilesize);\r\n", "        if (t == null || t.solid()) {\r\n", "          solids++;\r\n", "        }\r\n", "        // TODO should this apply to the player team(s)? currently PvE due to balancing\r\n", "        if (// damage radius is 1 tile smaller to prevent it from just touching walls as it passes\r\n", "        type.crushDamage > 0 && (walked || deltaLen() >= 0.01f) && t != null && t.build != null && t.build.team != team && Math.max(Math.abs(dx), Math.abs(dy)) <= r - 1) {\r\n", "          t.build.damage(team, type.crushDamage * Time.delta * t.block().crushDamageMultiplier * state.rules.unitDamage(team));\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "    lastSlowdown = Mathf.lerp(1f, type.crawlSlowdown, Mathf.clamp((float) solids / total / type.crawlSlowdownFrac));\r\n", "    // trigger animation only when walking manually\r\n", "    if (walked || net.client()) {\r\n", "      float len = deltaLen();\r\n", "      treadTime += len;\r\n", "      walked = false;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public float floorSpeedMultiplier() {\r\n", "    Floor on = isFlying() || hovering ? Blocks.air.asFloor() : floorOn();\r\n", "    // TODO take into account extra blocks\r\n", "    return on.speedMultiplier * speedMultiplier * lastSlowdown;\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  @Nullable\r\n", "  public Floor drownFloor() {\r\n", "    // tanks can only drown when all the nearby floors are deep\r\n", "    // TODO implement properly\r\n", "    if (hitSize >= 12 && canDrown()) {\r\n", "      for (Point2 p : Geometry.d8) {\r\n", "        Floor f = world.floorWorld(x + p.x * tilesize, y + p.y * tilesize);\r\n", "        if (!f.isDeep()) {\r\n", "          return null;\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "    return canDrown() ? floorOn() : null;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void moveAt(Vec2 vector, float acceleration) {\r\n", "    // mark walking state when moving in a controlled manner\r\n", "    if (!vector.isZero(0.001f)) {\r\n", "      walked = true;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void approach(Vec2 vector) {\r\n", "    // mark walking state when moving in a controlled manner\r\n", "    if (!vector.isZero(0.001f)) {\r\n", "      walked = true;\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("TeamComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.world.blocks.storage.CoreBlock.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class TeamComp implements Posc {\r\n", "\r\n", "  @Import\r\n", "  float x, y;\r\n", "\r\n", "  Team team = Team.derelict;\r\n", "\r\n", "  public boolean cheating() {\r\n", "    return team.rules().cheat;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return whether the center of this entity is visible to the viewing team.\r\n", "   */\r\n", "  boolean inFogTo(Team viewer) {\r\n", "    return this.team != viewer && !fogControl.isVisible(viewer, x, y);\r\n", "  }\r\n", "\r\n", "  @Nullable\r\n", "  public CoreBuild core() {\r\n", "    return team.core();\r\n", "  }\r\n", "\r\n", "  @Nullable\r\n", "  public CoreBuild closestCore() {\r\n", "    return state.teams.closestCore(x, y, team);\r\n", "  }\r\n", "\r\n", "  @Nullable\r\n", "  public CoreBuild closestEnemyCore() {\r\n", "    return state.teams.closestEnemyCore(x, y, team);\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("TimedComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.math.*;\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class TimedComp implements Entityc, Scaled {\r\n", "\r\n", "  float time, lifetime;\r\n", "\r\n", "  // called last so pooling and removal happens then.\r\n", "  @MethodPriority(100)\r\n", "  @Override\r\n", "  public void update() {\r\n", "    time = Math.min(time + Time.delta, lifetime);\r\n", "    if (time >= lifetime) {\r\n", "      remove();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public float fin() {\r\n", "    return time / lifetime;\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("TimedKillComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.math.*;\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "// basically just TimedComp but kills instead of removing.\r\n", "@Component\r\n", "abstract class TimedKillComp implements Entityc, Healthc, Scaled {\r\n", "\r\n", "  float time, lifetime;\r\n", "\r\n", "  // called last so pooling and removal happens then.\r\n", "  @MethodPriority(100)\r\n", "  @Override\r\n", "  public void update() {\r\n", "    time = Math.min(time + Time.delta, lifetime);\r\n", "    if (time >= lifetime) {\r\n", "      kill();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public float fin() {\r\n", "    return time / lifetime;\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("TimerComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class TimerComp {\r\n", "\r\n", "  transient Interval timer = new Interval(6);\r\n", "\r\n", "  public boolean timer(int index, float time) {\r\n", "    if (Float.isInfinite(time))\r\n", "      return false;\r\n", "    return timer.get(index, time);\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("UnitComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.*;\r\n", "import arc.graphics.*;\r\n", "import arc.graphics.g2d.*;\r\n", "import arc.math.*;\r\n", "import arc.math.geom.*;\r\n", "import arc.scene.ui.layout.*;\r\n", "import arc.util.*;\r\n", "import mindustry.ai.*;\r\n", "import mindustry.ai.types.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.core.*;\r\n", "import mindustry.ctype.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.entities.abilities.*;\r\n", "import mindustry.entities.units.*;\r\n", "import mindustry.game.EventType.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.graphics.*;\r\n", "import mindustry.logic.*;\r\n", "import mindustry.type.*;\r\n", "import mindustry.ui.*;\r\n", "import mindustry.world.*;\r\n", "import mindustry.world.blocks.environment.*;\r\n", "import mindustry.world.blocks.payloads.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.GlobalVars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component(base = true)\r\n", "abstract class UnitComp implements Healthc, Physicsc, Hitboxc, Statusc, Teamc, Itemsc, Rotc, Unitc, Weaponsc, Drawc, Boundedc, Syncc, Shieldc, Displayable, Ranged, Minerc, Builderc, Senseable, Settable {\r\n", "\r\n", "  @Import\r\n", "  boolean hovering, dead, disarmed;\r\n", "\r\n", "  @Import\r\n", "  float x, y, rotation, elevation, maxHealth, drag, armor, hitSize, health, ammo, dragMultiplier;\r\n", "\r\n", "  @Import\r\n", "  Team team;\r\n", "\r\n", "  @Import\r\n", "  int id;\r\n", "\r\n", "  @Import\r\n", "  @Nullable\r\n", "  Tile mineTile;\r\n", "\r\n", "  @Import\r\n", "  Vec2 vel;\r\n", "\r\n", "  @Import\r\n", "  WeaponMount[] mounts;\r\n", "\r\n", "  @Import\r\n", "  ItemStack stack;\r\n", "\r\n", "  private UnitController controller;\r\n", "\r\n", "  Ability[] abilities = {};\r\n", "\r\n", "  UnitType type = UnitTypes.alpha;\r\n", "\r\n", "  boolean spawnedByCore;\r\n", "\r\n", "  double flag;\r\n", "\r\n", "  @Nullable\r\n", "  transient Trail trail;\r\n", "\r\n", "  // TODO could be better represented as a unit\r\n", "  @Nullable\r\n", "  transient UnitType dockedType;\r\n", "\r\n", "  transient String lastCommanded;\r\n", "\r\n", "  transient float shadowAlpha = -1f, healTime;\r\n", "\r\n", "  transient int lastFogPos;\r\n", "\r\n", "  private transient float resupplyTime = Mathf.random(10f);\r\n", "\r\n", "  private transient boolean wasPlayer;\r\n", "\r\n", "  private transient boolean wasHealed;\r\n", "\r\n", "  /**\r\n", "   * Called when this unit was unloaded from a factory or spawn point.\r\n", "   */\r\n", "  public void unloaded() {\r\n", "  }\r\n", "\r\n", "  public void updateBoosting(boolean boost) {\r\n", "    if (!type.canBoost || dead)\r\n", "      return;\r\n", "    elevation = Mathf.approachDelta(elevation, type.canBoost ? Mathf.num(boost || onSolid() || (isFlying() && !canLand())) : 0f, type.riseSpeed);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Move based on preferred unit movement type.\r\n", "   */\r\n", "  public void movePref(Vec2 movement) {\r\n", "    if (type.omniMovement) {\r\n", "      moveAt(movement);\r\n", "    } else {\r\n", "      rotateMove(movement);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void moveAt(Vec2 vector) {\r\n", "    moveAt(vector, type.accel);\r\n", "  }\r\n", "\r\n", "  public void approach(Vec2 vector) {\r\n", "    vel.approachDelta(vector, type.accel * speed());\r\n", "  }\r\n", "\r\n", "  public void rotateMove(Vec2 vec) {\r\n", "    moveAt(Tmp.v2.trns(rotation, vec.len()));\r\n", "    if (!vec.isZero()) {\r\n", "      rotation = Angles.moveToward(rotation, vec.angle(), type.rotateSpeed * Time.delta);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public void aimLook(Position pos) {\r\n", "    aim(pos);\r\n", "    lookAt(pos);\r\n", "  }\r\n", "\r\n", "  public void aimLook(float x, float y) {\r\n", "    aim(x, y);\r\n", "    lookAt(x, y);\r\n", "  }\r\n", "\r\n", "  public boolean isPathImpassable(int tileX, int tileY) {\r\n", "    return !type.flying && world.tiles.in(tileX, tileY) && type.pathCost.getCost(team.id, pathfinder.get(tileX, tileY)) == -1;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return approx. square size of the physical hitbox for physics\r\n", "   */\r\n", "  public float physicSize() {\r\n", "    return hitSize * 0.7f;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return whether there is solid, un-occupied ground under this unit.\r\n", "   */\r\n", "  public boolean canLand() {\r\n", "    return !onSolid() && Units.count(x, y, physicSize(), f -> f != self() && f.isGrounded()) == 0;\r\n", "  }\r\n", "\r\n", "  public boolean inRange(Position other) {\r\n", "    return within(other, type.range);\r\n", "  }\r\n", "\r\n", "  public boolean hasWeapons() {\r\n", "    return type.hasWeapons();\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return speed with boost & floor multipliers factored in.\r\n", "   */\r\n", "  public float speed() {\r\n", "    float strafePenalty = isGrounded() || !isPlayer() ? 1f : Mathf.lerp(1f, type.strafePenalty, Angles.angleDist(vel().angle(), rotation) / 180f);\r\n", "    float boost = Mathf.lerp(1f, type.canBoost ? type.boostMultiplier : 1f, elevation);\r\n", "    return type.speed * strafePenalty * boost * floorSpeedMultiplier();\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return where the unit wants to look at.\r\n", "   */\r\n", "  public float prefRotation() {\r\n", "    if (activelyBuilding() && type.rotateToBuilding) {\r\n", "      return angleTo(buildPlan());\r\n", "    } else if (mineTile != null) {\r\n", "      return angleTo(mineTile);\r\n", "    } else if (moving() && type.omniMovement) {\r\n", "      return vel().angle();\r\n", "    }\r\n", "    return rotation;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public boolean displayable() {\r\n", "    return type.hoverable;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public boolean isSyncHidden(Player player) {\r\n", "    // shooting reveals position so bullets can be seen\r\n", "    return !isShooting() && inFogTo(player.team());\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void handleSyncHidden() {\r\n", "    remove();\r\n", "    netClient.clearRemovedEntity(id);\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public boolean inFogTo(Team viewer) {\r\n", "    if (this.team == viewer || !state.rules.fog)\r\n", "      return false;\r\n", "    if (hitSize <= 16f) {\r\n", "      return !fogControl.isVisible(viewer, x, y);\r\n", "    } else {\r\n", "      // for large hitsizes, check around the unit instead\r\n", "      float trns = hitSize / 2f;\r\n", "      for (var p : Geometry.d8) {\r\n", "        if (fogControl.isVisible(viewer, x + p.x * trns, y + p.y * trns)) {\r\n", "          return false;\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "    return true;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public float range() {\r\n", "    return type.maxRange;\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  public float clipSize() {\r\n", "    if (isBuilding()) {\r\n", "      return state.rules.infiniteResources ? Float.MAX_VALUE : Math.max(type.clipSize, type.region.width) + type.buildRange + tilesize * 4f;\r\n", "    }\r\n", "    if (mining()) {\r\n", "      return type.clipSize + type.mineRange;\r\n", "    }\r\n", "    return type.clipSize;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public double sense(LAccess sensor) {\r\n", "    switch(sensor) {\r\n", "      case totalItems:\r\n", "        return stack().amount;\r\n", "      case itemCapacity:\r\n", "        return type.itemCapacity;\r\n", "      case rotation:\r\n", "        return rotation;\r\n", "      case health:\r\n", "        return health;\r\n", "      case maxHealth:\r\n", "        return maxHealth;\r\n", "      case ammo:\r\n", "        return !state.rules.unitAmmo ? type.ammoCapacity : ammo;\r\n", "      case ammoCapacity:\r\n", "        return type.ammoCapacity;\r\n", "      case x:\r\n", "        return World.conv(x);\r\n", "      case y:\r\n", "        return World.conv(y);\r\n", "      case dead:\r\n", "        return dead || !isAdded() ? 1 : 0;\r\n", "      case team:\r\n", "        return team.id;\r\n", "      case shooting:\r\n", "        return isShooting() ? 1 : 0;\r\n", "      case boosting:\r\n", "        return type.canBoost && isFlying() ? 1 : 0;\r\n", "      case range:\r\n", "        return range() / tilesize;\r\n", "      case shootX:\r\n", "        return World.conv(aimX());\r\n", "      case shootY:\r\n", "        return World.conv(aimY());\r\n", "      case mining:\r\n", "        return mining() ? 1 : 0;\r\n", "      case mineX:\r\n", "        return mining() ? mineTile.x : -1;\r\n", "      case mineY:\r\n", "        return mining() ? mineTile.y : -1;\r\n", "      case flag:\r\n", "        return flag;\r\n", "      case speed:\r\n", "        return type.speed * 60f / tilesize;\r\n", "      case controlled:\r\n", "        return !isValid() ? 0 : controller instanceof LogicAI ? ctrlProcessor : controller instanceof Player ? ctrlPlayer : controller instanceof CommandAI command && command.hasCommand() ? ctrlCommand : 0;\r\n", "      case payloadCount:\r\n", "        return ((Object) this) instanceof Payloadc pay ? pay.payloads().size : 0;\r\n", "      case size:\r\n", "        return hitSize / tilesize;\r\n", "      case color:\r\n", "        return Color.toDoubleBits(team.color.r, team.color.g, team.color.b, 1f);\r\n", "      default:\r\n", "        return Float.NaN;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public Object senseObject(LAccess sensor) {\r\n", "    switch(sensor) {\r\n", "      case type:\r\n", "        return type;\r\n", "      case name:\r\n", "        return controller instanceof Player p ? p.name : null;\r\n", "      case firstItem:\r\n", "        return stack().amount == 0 ? null : item();\r\n", "      case controller:\r\n", "        return !isValid() ? null : controller instanceof LogicAI log ? log.controller : this;\r\n", "      case payloadType:\r\n", "        return ((Object) this) instanceof Payloadc pay ? (pay.payloads().isEmpty() ? null : pay.payloads().peek() instanceof UnitPayload p1 ? p1.unit.type : pay.payloads().peek() instanceof BuildPayload p2 ? p2.block() : null) : null;\r\n", "      default:\r\n", "        return noSensed;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public double sense(Content content) {\r\n", "    if (content == stack().item)\r\n", "      return stack().amount;\r\n", "    return Float.NaN;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void setProp(LAccess prop, double value) {\r\n", "    switch(prop) {\r\n", "      case health:\r\n", "        health = (float) Mathf.clamp(value, 0, maxHealth);\r\n", "      case x:\r\n", "        x = World.unconv((float) value);\r\n", "      case y:\r\n", "        y = World.unconv((float) value);\r\n", "      case rotation:\r\n", "        rotation = (float) value;\r\n", "      case team:\r\n", "        {\r\n", "          if (!net.client()) {\r\n", "            Team team = Team.get((int) value);\r\n", "            if (controller instanceof Player p) {\r\n", "              p.team(team);\r\n", "            }\r\n", "            this.team = team;\r\n", "          }\r\n", "        }\r\n", "      case flag:\r\n", "        flag = value;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void setProp(LAccess prop, Object value) {\r\n", "    switch(prop) {\r\n", "      case team:\r\n", "        {\r\n", "          if (value instanceof Team t && !net.client()) {\r\n", "            if (controller instanceof Player p)\r\n", "              p.team(t);\r\n", "            team = t;\r\n", "          }\r\n", "        }\r\n", "      case payloadType:\r\n", "        {\r\n", "          // only serverside\r\n", "          if (((Object) this) instanceof Payloadc pay && !net.client()) {\r\n", "            if (value instanceof Block b) {\r\n", "              Building build = b.newBuilding().create(b, team());\r\n", "              if (pay.canPickup(build))\r\n", "                pay.addPayload(new BuildPayload(build));\r\n", "            } else if (value instanceof UnitType ut) {\r\n", "              Unit unit = ut.create(team());\r\n", "              if (pay.canPickup(unit))\r\n", "                pay.addPayload(new UnitPayload(unit));\r\n", "            } else if (value == null && pay.payloads().size > 0) {\r\n", "              pay.dropLastPayload();\r\n", "            }\r\n", "          }\r\n", "        }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void setProp(UnlockableContent content, double value) {\r\n", "    if (content instanceof Item item) {\r\n", "      stack.item = item;\r\n", "      stack.amount = Mathf.clamp((int) value, 0, type.itemCapacity);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public boolean canDrown() {\r\n", "    return isGrounded() && !hovering && type.canDrown;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public boolean canShoot() {\r\n", "    // cannot shoot while boosting\r\n", "    return !disarmed && !(type.canBoost && isFlying());\r\n", "  }\r\n", "\r\n", "  public boolean isEnemy() {\r\n", "    return type.isEnemy;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public boolean collides(Hitboxc other) {\r\n", "    return hittable();\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void collision(Hitboxc other, float x, float y) {\r\n", "    if (other instanceof Bullet bullet) {\r\n", "      controller.hit(bullet);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public int itemCapacity() {\r\n", "    return type.itemCapacity;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public float bounds() {\r\n", "    return hitSize * 2f;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void controller(UnitController next) {\r\n", "    this.controller = next;\r\n", "    if (controller.unit() != self())\r\n", "      controller.unit(self());\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public UnitController controller() {\r\n", "    return controller;\r\n", "  }\r\n", "\r\n", "  public void resetController() {\r\n", "    controller(type.createController(self()));\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void set(UnitType def, UnitController controller) {\r\n", "    if (this.type != def) {\r\n", "      setType(def);\r\n", "    }\r\n", "    controller(controller);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return pathfinder path type for calculating costs\r\n", "   */\r\n", "  public int pathType() {\r\n", "    return Pathfinder.costGround;\r\n", "  }\r\n", "\r\n", "  public void lookAt(float angle) {\r\n", "    rotation = Angles.moveToward(rotation, angle, type.rotateSpeed * Time.delta * speedMultiplier());\r\n", "  }\r\n", "\r\n", "  public void lookAt(Position pos) {\r\n", "    lookAt(angleTo(pos));\r\n", "  }\r\n", "\r\n", "  public void lookAt(float x, float y) {\r\n", "    lookAt(angleTo(x, y));\r\n", "  }\r\n", "\r\n", "  public boolean isAI() {\r\n", "    return controller instanceof AIController;\r\n", "  }\r\n", "\r\n", "  public boolean isCommandable() {\r\n", "    return controller instanceof CommandAI;\r\n", "  }\r\n", "\r\n", "  public CommandAI command() {\r\n", "    if (controller instanceof CommandAI ai) {\r\n", "      return ai;\r\n", "    } else {\r\n", "      throw new IllegalArgumentException(\"Unit cannot be commanded - check isCommandable() first.\");\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public int count() {\r\n", "    return team.data().countType(type);\r\n", "  }\r\n", "\r\n", "  public int cap() {\r\n", "    return Units.getCap(team);\r\n", "  }\r\n", "\r\n", "  public void setType(UnitType type) {\r\n", "    this.type = type;\r\n", "    this.maxHealth = type.health;\r\n", "    this.drag = type.drag;\r\n", "    this.armor = type.armor;\r\n", "    this.hitSize = type.hitSize;\r\n", "    this.hovering = type.hovering;\r\n", "    if (controller == null)\r\n", "      controller(type.createController(self()));\r\n", "    if (mounts().length != type.weapons.size)\r\n", "      setupWeapons(type);\r\n", "    if (abilities.length != type.abilities.size) {\r\n", "      abilities = new Ability[type.abilities.size];\r\n", "      for (int i = 0; i < type.abilities.size; i++) {\r\n", "        abilities[i] = type.abilities.get(i).copy();\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  public boolean targetable(Team targeter) {\r\n", "    return type.targetable(self(), targeter);\r\n", "  }\r\n", "\r\n", "  public boolean hittable() {\r\n", "    return type.hittable(self());\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void afterSync() {\r\n", "    // set up type info after reading\r\n", "    setType(this.type);\r\n", "    controller.unit(self());\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void afterRead() {\r\n", "    afterSync();\r\n", "    // reset controller state\r\n", "    if (!(controller instanceof AIController ai && ai.keepState())) {\r\n", "      controller(type.createController(self()));\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void add() {\r\n", "    team.data().updateCount(type, 1);\r\n", "    // check if over unit cap\r\n", "    if (type.useUnitCap && count() > cap() && !spawnedByCore && !dead && !state.rules.editor) {\r\n", "      Call.unitCapDeath(self());\r\n", "      team.data().updateCount(type, -1);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void remove() {\r\n", "    team.data().updateCount(type, -1);\r\n", "    controller.removed(self());\r\n", "    // make sure trail doesn't just go poof\r\n", "    if (trail != null && trail.size() > 0) {\r\n", "      Fx.trailFade.at(x, y, trail.width(), type.trailColor == null ? team.color : type.trailColor, trail.copy());\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void landed() {\r\n", "    if (type.mechLandShake > 0f) {\r\n", "      Effect.shake(type.mechLandShake, type.mechLandShake, this);\r\n", "    }\r\n", "    type.landed(self());\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void heal(float amount) {\r\n", "    if (health < maxHealth && amount > 0) {\r\n", "      wasHealed = true;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    type.update(self());\r\n", "    if (wasHealed && healTime <= -1f) {\r\n", "      healTime = 1f;\r\n", "    }\r\n", "    healTime -= Time.delta / 20f;\r\n", "    wasHealed = false;\r\n", "    // die on captured sectors immediately\r\n", "    if (team.isOnlyAI() && state.isCampaign() && state.getSector().isCaptured()) {\r\n", "      kill();\r\n", "    }\r\n", "    if (!headless && type.loopSound != Sounds.none) {\r\n", "      control.sound.loop(type.loopSound, this, type.loopSoundVolume);\r\n", "    }\r\n", "    // check if environment is unsupported\r\n", "    if (!type.supportsEnv(state.rules.env) && !dead) {\r\n", "      Call.unitEnvDeath(self());\r\n", "      team.data().updateCount(type, -1);\r\n", "    }\r\n", "    if (state.rules.unitAmmo && ammo < type.ammoCapacity - 0.0001f) {\r\n", "      resupplyTime += Time.delta;\r\n", "      // resupply only at a fixed interval to prevent lag\r\n", "      if (resupplyTime > 10f) {\r\n", "        type.ammoType.resupply(self());\r\n", "        resupplyTime = 0f;\r\n", "      }\r\n", "    }\r\n", "    for (Ability a : abilities) {\r\n", "      a.update(self());\r\n", "    }\r\n", "    if (trail != null) {\r\n", "      trail.length = type.trailLength;\r\n", "      float scale = type.useEngineElevation ? elevation : 1f;\r\n", "      float offset = type.engineOffset / 2f + type.engineOffset / 2f * scale;\r\n", "      float cx = x + Angles.trnsx(rotation + 180, offset), cy = y + Angles.trnsy(rotation + 180, offset);\r\n", "      trail.update(cx, cy);\r\n", "    }\r\n", "    drag = type.drag * (isGrounded() ? (floorOn().dragMultiplier) : 1f) * dragMultiplier * state.rules.dragMultiplier;\r\n", "    // apply knockback based on spawns\r\n", "    if (team != state.rules.waveTeam && state.hasSpawns() && (!net.client() || isLocal()) && hittable()) {\r\n", "      float relativeSize = state.rules.dropZoneRadius + hitSize / 2f + 1f;\r\n", "      for (Tile spawn : spawner.getSpawns()) {\r\n", "        if (within(spawn.worldx(), spawn.worldy(), relativeSize)) {\r\n", "          velAddNet(Tmp.v1.set(this).sub(spawn.worldx(), spawn.worldy()).setLength(0.1f + 1f - dst(spawn) / relativeSize).scl(0.45f * Time.delta));\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "    // simulate falling down\r\n", "    if (dead || health <= 0) {\r\n", "      // less drag when dead\r\n", "      drag = 0.01f;\r\n", "      // standard fall smoke\r\n", "      if (Mathf.chanceDelta(0.1)) {\r\n", "        Tmp.v1.rnd(Mathf.range(hitSize));\r\n", "        type.fallEffect.at(x + Tmp.v1.x, y + Tmp.v1.y);\r\n", "      }\r\n", "      // thruster fall trail\r\n", "      if (Mathf.chanceDelta(0.2)) {\r\n", "        float offset = type.engineOffset / 2f + type.engineOffset / 2f * elevation;\r\n", "        float range = Mathf.range(type.engineSize);\r\n", "        type.fallEngineEffect.at(x + Angles.trnsx(rotation + 180, offset) + Mathf.range(range), y + Angles.trnsy(rotation + 180, offset) + Mathf.range(range), Mathf.random());\r\n", "      }\r\n", "      // move down\r\n", "      elevation -= type.fallSpeed * Time.delta;\r\n", "      if (isGrounded() || health <= -maxHealth) {\r\n", "        Call.unitDestroy(id);\r\n", "      }\r\n", "    }\r\n", "    Tile tile = tileOn();\r\n", "    Floor floor = floorOn();\r\n", "    if (tile != null && isGrounded() && !type.hovering) {\r\n", "      // unit block update\r\n", "      if (tile.build != null) {\r\n", "        tile.build.unitOn(self());\r\n", "      }\r\n", "      // apply damage\r\n", "      if (floor.damageTaken > 0f) {\r\n", "        damageContinuous(floor.damageTaken);\r\n", "      }\r\n", "    }\r\n", "    // kill entities on tiles that are solid to them\r\n", "    if (tile != null && !canPassOn()) {\r\n", "      // boost if possible\r\n", "      if (type.canBoost) {\r\n", "        elevation = 1f;\r\n", "      } else if (!net.client()) {\r\n", "        kill();\r\n", "      }\r\n", "    }\r\n", "    // AI only updates on the server\r\n", "    if (!net.client() && !dead) {\r\n", "      controller.updateUnit();\r\n", "    }\r\n", "    // clear controller when it becomes invalid\r\n", "    if (!controller.isValidController()) {\r\n", "      resetController();\r\n", "    }\r\n", "    // remove units spawned by the core\r\n", "    if (spawnedByCore && !isPlayer() && !dead) {\r\n", "      Call.unitDespawn(self());\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return a preview icon for this unit.\r\n", "   */\r\n", "  public TextureRegion icon() {\r\n", "    return type.fullIcon;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Actually destroys the unit, removing it and creating explosions. *\r\n", "   */\r\n", "  public void destroy() {\r\n", "    if (!isAdded() || !type.killable)\r\n", "      return;\r\n", "    float explosiveness = 2f + item().explosiveness * stack().amount * 1.53f;\r\n", "    float flammability = item().flammability * stack().amount / 1.9f;\r\n", "    float power = item().charge * Mathf.pow(stack().amount, 1.11f) * 160f;\r\n", "    if (!spawnedByCore) {\r\n", "      Damage.dynamicExplosion(x, y, flammability, explosiveness, power, (bounds() + type.legLength / 1.7f) / 2f, state.rules.damageExplosions && state.rules.unitCrashDamage(team) > 0, item().flammability > 1, team, type.deathExplosionEffect);\r\n", "    } else {\r\n", "      type.deathExplosionEffect.at(x, y, bounds() / 2f / 8f);\r\n", "    }\r\n", "    float shake = hitSize / 3f;\r\n", "    if (type.createScorch) {\r\n", "      Effect.scorch(x, y, (int) (hitSize / 5));\r\n", "    }\r\n", "    Effect.shake(shake, shake, this);\r\n", "    type.deathSound.at(this);\r\n", "    Events.fire(new UnitDestroyEvent(self()));\r\n", "    if (explosiveness > 7f && (isLocal() || wasPlayer)) {\r\n", "      Events.fire(Trigger.suicideBomb);\r\n", "    }\r\n", "    for (WeaponMount mount : mounts) {\r\n", "      if (mount.weapon.shootOnDeath && !(mount.weapon.bullet.killShooter && mount.totalShots > 0)) {\r\n", "        mount.reload = 0f;\r\n", "        mount.shoot = true;\r\n", "        mount.weapon.update(self(), mount);\r\n", "      }\r\n", "    }\r\n", "    // if this unit crash landed (was flying), damage stuff in a radius\r\n", "    if (type.flying && !spawnedByCore && type.createWreck && state.rules.unitCrashDamage(team) > 0) {\r\n", "      Damage.damage(team, x, y, Mathf.pow(hitSize, 0.94f) * 1.25f, Mathf.pow(hitSize, 0.75f) * type.crashDamageMultiplier * 5f * state.rules.unitCrashDamage(team), true, false, true);\r\n", "    }\r\n", "    if (!headless && type.createScorch) {\r\n", "      for (int i = 0; i < type.wreckRegions.length; i++) {\r\n", "        if (type.wreckRegions[i].found()) {\r\n", "          float range = type.hitSize / 4f;\r\n", "          Tmp.v1.rnd(range);\r\n", "          Effect.decal(type.wreckRegions[i], x + Tmp.v1.x, y + Tmp.v1.y, rotation - 90);\r\n", "        }\r\n", "      }\r\n", "    }\r\n", "    for (Ability a : abilities) {\r\n", "      a.death(self());\r\n", "    }\r\n", "    type.killed(self());\r\n", "    remove();\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return name of direct or indirect player controller.\r\n", "   */\r\n", "  @Override\r\n", "  @Nullable\r\n", "  public String getControllerName() {\r\n", "    if (isPlayer())\r\n", "      return getPlayer().name;\r\n", "    if (controller instanceof LogicAI ai && ai.controller != null)\r\n", "      return ai.controller.lastAccessed;\r\n", "    return null;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void display(Table table) {\r\n", "    type.display(self(), table);\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public boolean isImmune(StatusEffect effect) {\r\n", "    return type.immunities.contains(effect);\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void draw() {\r\n", "    type.draw(self());\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public boolean isPlayer() {\r\n", "    return controller instanceof Player;\r\n", "  }\r\n", "\r\n", "  @Nullable\r\n", "  public Player getPlayer() {\r\n", "    return isPlayer() ? (Player) controller : null;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void killed() {\r\n", "    wasPlayer = isLocal();\r\n", "    health = Math.min(health, 0);\r\n", "    dead = true;\r\n", "    // don't waste time when the unit is already on the ground, just destroy it\r\n", "    if (!type.flying || !type.createWreck) {\r\n", "      destroy();\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public void kill() {\r\n", "    if (dead || net.client() || !type.killable)\r\n", "      return;\r\n", "    // deaths are synced; this calls killed()\r\n", "    Call.unitDeath(id);\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public String toString() {\r\n", "    return \"Unit#\" + id() + \":\" + type;\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("UnitTetherComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.game.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.type.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "/**\r\n", " * A unit that depends on a units's existence; if that unit is removed, it despawns.\r\n", " */\r\n", "@Component\r\n", "abstract class UnitTetherComp implements Unitc {\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  @Import\r\n", "  Team team;\r\n", "\r\n", "  // spawner unit cannot be read directly for technical reasons.\r\n", "  @Nullable\r\n", "  public transient Unit spawner;\r\n", "\r\n", "  public int spawnerUnitId = -1;\r\n", "\r\n", "  @Override\r\n", "  public void afterRead() {\r\n", "    if (spawnerUnitId != -1)\r\n", "      spawner = Groups.unit.getByID(spawnerUnitId);\r\n", "    spawnerUnitId = -1;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void afterSync() {\r\n", "    if (spawnerUnitId != -1)\r\n", "      spawner = Groups.unit.getByID(spawnerUnitId);\r\n", "    spawnerUnitId = -1;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    if (spawner == null || !spawner.isValid() || spawner.team != team) {\r\n", "      Call.unitDespawn(self());\r\n", "    } else {\r\n", "      spawnerUnitId = spawner.id;\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("VelComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.math.*;\r\n", "import arc.math.geom.*;\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.entities.EntityCollisions.*;\r\n", "import mindustry.gen.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class VelComp implements Posc {\r\n", "\r\n", "  @Import\r\n", "  float x, y;\r\n", "\r\n", "  @SyncLocal\r\n", "  Vec2 vel = new Vec2();\r\n", "\r\n", "  transient float drag = 0f;\r\n", "\r\n", "  // velocity needs to be called first, as it affects delta and lastPosition\r\n", "  @MethodPriority(-1)\r\n", "  @Override\r\n", "  public void update() {\r\n", "    // do not update velocity on the client at all, unless it's non-interpolated\r\n", "    // velocity conflicts with interpolation.\r\n", "    if (!net.client() || isLocal()) {\r\n", "      float px = x, py = y;\r\n", "      move(vel.x * Time.delta, vel.y * Time.delta);\r\n", "      if (Mathf.equal(px, x))\r\n", "        vel.x = 0;\r\n", "      if (Mathf.equal(py, y))\r\n", "        vel.y = 0;\r\n", "      vel.scl(Math.max(1f - drag * Time.delta, 0));\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return function to use for check solid state. if null, no checking is done.\r\n", "   */\r\n", "  @Nullable\r\n", "  SolidPred solidity() {\r\n", "    return null;\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return whether this entity can move through a location\r\n", "   */\r\n", "  boolean canPass(int tileX, int tileY) {\r\n", "    SolidPred s = solidity();\r\n", "    return s == null || !s.solid(tileX, tileY);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * @return whether this entity can exist on its current location\r\n", "   */\r\n", "  boolean canPassOn() {\r\n", "    return canPass(tileX(), tileY());\r\n", "  }\r\n", "\r\n", "  boolean moving() {\r\n", "    return !vel.isZero(0.01f);\r\n", "  }\r\n", "\r\n", "  void move(Vec2 v) {\r\n", "    move(v.x, v.y);\r\n", "  }\r\n", "\r\n", "  void move(float cx, float cy) {\r\n", "    SolidPred check = solidity();\r\n", "    if (check != null) {\r\n", "      collisions.move(self(), cx, cy, check);\r\n", "    } else {\r\n", "      x += cx;\r\n", "      y += cy;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  void velAddNet(Vec2 v) {\r\n", "    vel.add(v);\r\n", "    if (isRemote()) {\r\n", "      x += v.x;\r\n", "      y += v.y;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  void velAddNet(float vx, float vy) {\r\n", "    vel.add(vx, vy);\r\n", "    if (isRemote()) {\r\n", "      x += vx;\r\n", "      y += vy;\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("WaterMoveComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.graphics.*;\r\n", "import arc.graphics.g2d.*;\r\n", "import arc.math.*;\r\n", "import arc.util.*;\r\n", "import mindustry.ai.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.content.*;\r\n", "import mindustry.entities.*;\r\n", "import mindustry.entities.EntityCollisions.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.graphics.*;\r\n", "import mindustry.type.*;\r\n", "import mindustry.world.*;\r\n", "import mindustry.world.blocks.environment.*;\r\n", "import static mindustry.Vars.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class WaterMoveComp implements Posc, Velc, Hitboxc, Flyingc, Unitc {\r\n", "\r\n", "  @Import\r\n", "  float x, y, rotation, speedMultiplier;\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  private transient Trail tleft = new Trail(1), tright = new Trail(1);\r\n", "\r\n", "  private transient Color trailColor = Blocks.water.mapColor.cpy().mul(1.5f);\r\n", "\r\n", "  @Override\r\n", "  public void update() {\r\n", "    boolean flying = isFlying();\r\n", "    for (int i = 0; i < 2; i++) {\r\n", "      Trail t = i == 0 ? tleft : tright;\r\n", "      t.length = type.trailLength;\r\n", "      int sign = i == 0 ? -1 : 1;\r\n", "      float cx = Angles.trnsx(rotation - 90, type.waveTrailX * sign, type.waveTrailY) + x, cy = Angles.trnsy(rotation - 90, type.waveTrailX * sign, type.waveTrailY) + y;\r\n", "      t.update(cx, cy, world.floorWorld(cx, cy).isLiquid && !flying ? 1 : 0);\r\n", "    }\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  @Replace\r\n", "  public int pathType() {\r\n", "    return Pathfinder.costNaval;\r\n", "  }\r\n", "\r\n", "  // don't want obnoxious splashing\r\n", "  @Override\r\n", "  @Replace\r\n", "  public boolean emitWalkSound() {\r\n", "    return false;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void add() {\r\n", "    tleft.clear();\r\n", "    tright.clear();\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void draw() {\r\n", "    float z = Draw.z();\r\n", "    Draw.z(Layer.debris);\r\n", "    Floor floor = tileOn() == null ? Blocks.air.asFloor() : tileOn().floor();\r\n", "    Color color = Tmp.c1.set(floor.mapColor.equals(Color.black) ? Blocks.water.mapColor : floor.mapColor).mul(1.5f);\r\n", "    trailColor.lerp(color, Mathf.clamp(Time.delta * 0.04f));\r\n", "    tleft.draw(trailColor, type.trailScl);\r\n", "    tright.draw(trailColor, type.trailScl);\r\n", "    Draw.z(z);\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public SolidPred solidity() {\r\n", "    return isFlying() ? null : EntityCollisions::waterSolid;\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  @Override\r\n", "  public boolean onSolid() {\r\n", "    return EntityCollisions.waterSolid(tileX(), tileY());\r\n", "  }\r\n", "\r\n", "  @Replace\r\n", "  public float floorSpeedMultiplier() {\r\n", "    Floor on = isFlying() ? Blocks.air.asFloor() : floorOn();\r\n", "    return (on.shallow ? 1f : 1.3f) * speedMultiplier;\r\n", "  }\r\n", "\r\n", "  public boolean onLiquid() {\r\n", "    Tile tile = tileOn();\r\n", "    return tile != null && tile.floor().isLiquid;\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("WeaponsComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.math.geom.*;\r\n", "import arc.util.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.entities.units.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.type.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "@Component\r\n", "abstract class WeaponsComp implements Teamc, Posc, Rotc, Velc, Statusc {\r\n", "\r\n", "  @Import\r\n", "  float x, y;\r\n", "\r\n", "  @Import\r\n", "  boolean disarmed;\r\n", "\r\n", "  @Import\r\n", "  UnitType type;\r\n", "\r\n", "  /**\r\n", "   * weapon mount array, never null\r\n", "   */\r\n", "  @SyncLocal\r\n", "  WeaponMount[] mounts = {};\r\n", "\r\n", "  @ReadOnly\r\n", "  transient boolean isRotate;\r\n", "\r\n", "  transient float aimX, aimY;\r\n", "\r\n", "  boolean isShooting;\r\n", "\r\n", "  float ammo;\r\n", "\r\n", "  float ammof() {\r\n", "    return ammo / type.ammoCapacity;\r\n", "  }\r\n", "\r\n", "  void setWeaponRotation(float rotation) {\r\n", "    for (WeaponMount mount : mounts) {\r\n", "      mount.rotation = rotation;\r\n", "    }\r\n", "  }\r\n", "\r\n", "  void setupWeapons(UnitType def) {\r\n", "    mounts = new WeaponMount[def.weapons.size];\r\n", "    for (int i = 0; i < mounts.length; i++) {\r\n", "      mounts[i] = def.weapons.get(i).mountType.get(def.weapons.get(i));\r\n", "    }\r\n", "  }\r\n", "\r\n", "  void controlWeapons(boolean rotateShoot) {\r\n", "    controlWeapons(rotateShoot, rotateShoot);\r\n", "  }\r\n", "\r\n", "  void controlWeapons(boolean rotate, boolean shoot) {\r\n", "    for (WeaponMount mount : mounts) {\r\n", "      if (mount.weapon.controllable) {\r\n", "        mount.rotate = rotate;\r\n", "        mount.shoot = shoot;\r\n", "      }\r\n", "    }\r\n", "    isRotate = rotate;\r\n", "    isShooting = shoot;\r\n", "  }\r\n", "\r\n", "  void aim(Position pos) {\r\n", "    aim(pos.getX(), pos.getY());\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Aim at something. This will make all mounts point at it.\r\n", "   */\r\n", "  void aim(float x, float y) {\r\n", "    Tmp.v1.set(x, y).sub(this.x, this.y);\r\n", "    if (Tmp.v1.len() < type.aimDst)\r\n", "      Tmp.v1.setLength(type.aimDst);\r\n", "    x = Tmp.v1.x + this.x;\r\n", "    y = Tmp.v1.y + this.y;\r\n", "    for (WeaponMount mount : mounts) {\r\n", "      if (mount.weapon.controllable) {\r\n", "        mount.aimX = x;\r\n", "        mount.aimY = y;\r\n", "      }\r\n", "    }\r\n", "    aimX = x;\r\n", "    aimY = y;\r\n", "  }\r\n", "\r\n", "  boolean canShoot() {\r\n", "    return !disarmed;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void remove() {\r\n", "    for (WeaponMount mount : mounts) {\r\n", "      if (mount.weapon.continuous && mount.bullet != null && mount.bullet.owner == self()) {\r\n", "        mount.bullet.time = mount.bullet.lifetime - 10f;\r\n", "        mount.bullet = null;\r\n", "      }\r\n", "      if (mount.sound != null) {\r\n", "        mount.sound.stop();\r\n", "      }\r\n", "    }\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * Update shooting and rotation for this unit.\r\n", "   */\r\n", "  @Override\r\n", "  public void update() {\r\n", "    for (WeaponMount mount : mounts) {\r\n", "      mount.weapon.update(self(), mount);\r\n", "    }\r\n", "  }\r\n", "}\r\n" }));
        compMap.put("WorldLabelComp",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import arc.graphics.*;\r\n", "import arc.graphics.g2d.*;\r\n", "import arc.scene.ui.layout.*;\r\n", "import arc.util.*;\r\n", "import arc.util.pooling.*;\r\n", "import mindustry.annotations.Annotations.*;\r\n", "import mindustry.gen.*;\r\n", "import mindustry.graphics.*;\r\n", "import mindustry.ui.*;\r\n", "import static mindustry.logic.LAccess.*;\r\n", "\r\n", "/**\r\n", " * Component/entity for labels in world space. Useful for servers. Does not save in files - create only on world load.\r\n", " */\r\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { WorldLabelc.class }, serialize = false)\r\n", "@Component(base = true)\r\n", "public abstract class WorldLabelComp implements Posc, Drawc, Syncc {\r\n", "\r\n", "  @Import\r\n", "  int id;\r\n", "\r\n", "  @Import\r\n", "  float x, y;\r\n", "\r\n", "  public static final byte flagBackground = 1, flagOutline = 2;\r\n", "\r\n", "  public String text = \"sample text\";\r\n", "\r\n", "  public float fontSize = 1f, z = Layer.playerName + 1;\r\n", "\r\n", "  /**\r\n", "   * Flags are packed into a byte for sync efficiency; see the flag static values.\r\n", "   */\r\n", "  public byte flags = flagBackground | flagOutline;\r\n", "\r\n", "  @Replace\r\n", "  public float clipSize() {\r\n", "    return text.length() * 10f * fontSize;\r\n", "  }\r\n", "\r\n", "  @Override\r\n", "  public void draw() {\r\n", "    drawAt(text, x, y, z, flags, fontSize);\r\n", "  }\r\n", "\r\n", "  public static void drawAt(String text, float x, float y, float layer, int flags, float fontSize) {\r\n", "    Draw.z(layer);\r\n", "    float z = Drawf.text();\r\n", "    Font font = (flags & flagOutline) != 0 ? Fonts.outline : Fonts.def;\r\n", "    GlyphLayout layout = Pools.obtain(GlyphLayout.class, GlyphLayout::new);\r\n", "    boolean ints = font.usesIntegerPositions();\r\n", "    font.setUseIntegerPositions(false);\r\n", "    font.getData().setScale(0.25f / Scl.scl(1f) * fontSize);\r\n", "    layout.setText(font, text);\r\n", "    if ((flags & flagBackground) != 0) {\r\n", "      Draw.color(0f, 0f, 0f, 0.3f);\r\n", "      Fill.rect(x, y - layout.height / 2, layout.width + 2, layout.height + 3);\r\n", "      Draw.color();\r\n", "    }\r\n", "    font.setColor(Color.white);\r\n", "    font.draw(text, x, y, 0, Align.center, false);\r\n", "    Draw.reset();\r\n", "    Pools.free(layout);\r\n", "    font.getData().setScale(1f);\r\n", "    font.setColor(Color.white);\r\n", "    font.setUseIntegerPositions(ints);\r\n", "    Draw.z(z);\r\n", "  }\r\n", "\r\n", "  /**\r\n", "   * This MUST be called instead of remove()!\r\n", "   */\r\n", "  public void hide() {\r\n", "    remove();\r\n", "    Call.removeWorldLabel(id);\r\n", "  }\r\n", "}\r\n" }));
        groupDefs="package mma.entities;\r\n\r\nimport mindustry.annotations.Annotations.GroupDef;\r\nimport mindustry.gen.*;\r\n\r\nclass GroupDefs<G>{\r\n    @GroupDef(value = Entityc.class) G all;\r\n    @GroupDef(value = Playerc.class, mapping = true) G player;\r\n    @GroupDef(value = Bulletc.class, spatial = true, collide = true) G bullet;\r\n    @GroupDef(value = Unitc.class, spatial = true, mapping = true) G unit;\r\n    @GroupDef(value = Buildingc.class) G build;\r\n    @GroupDef(value = Syncc.class, mapping = true) G sync;\r\n    @GroupDef(value = Drawc.class) G draw;\r\n    @GroupDef(value = Firec.class) G fire;\r\n    @GroupDef(value = Puddlec.class) G puddle;\r\n//    @GroupDef(value = WeatherStatec.class) G weather;\r\n}\r\n";
        indexerDefs = new arc.struct.ObjectMap<>();
        indexerDefs.put("mindustry.gen.Entityc", new String[] { "IndexableEntity__all", "setIndex__all" });
        indexerDefs.put("mindustry.gen.Playerc", new String[] { "IndexableEntity__player", "setIndex__player" });
        indexerDefs.put("mindustry.gen.Bulletc", new String[] { "IndexableEntity__bullet", "setIndex__bullet" });
        indexerDefs.put("mindustry.gen.Unitc", new String[] { "IndexableEntity__unit", "setIndex__unit" });
        indexerDefs.put("mindustry.gen.Buildingc", new String[] { "IndexableEntity__build", "setIndex__build" });
        indexerDefs.put("mindustry.gen.Syncc", new String[] { "IndexableEntity__sync", "setIndex__sync" });
        indexerDefs.put("mindustry.gen.Drawc", new String[] { "IndexableEntity__draw", "setIndex__draw" });
        indexerDefs.put("mindustry.gen.Firec", new String[] { "IndexableEntity__fire", "setIndex__fire" });
        indexerDefs.put("mindustry.gen.Puddlec", new String[] { "IndexableEntity__puddle", "setIndex__puddle" });
    }
}
