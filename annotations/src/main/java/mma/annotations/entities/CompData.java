package mma.annotations.entities;

import arc.struct.ObjectMap;

class CompData {

    static final ObjectMap<String, String> compMap;

    static final String groupDefs;

    static {
        compMap = new ObjectMap<>();
        compMap.put("AnnotationConfigComponents",String.join("",new String[] { "package mma.entities.compByAnuke;\r\n", "\r\n", "import mma.annotations.ModAnnotations;\r\n", "\r\n", "public class AnnotationConfigComponents {\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface BlockUnitc extends mindustry.gen.BlockUnitc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Boundedc extends mindustry.gen.Boundedc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Builderc extends mindustry.gen.Builderc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Buildingc extends mindustry.gen.Buildingc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface BuildingTetherc extends mindustry.gen.BuildingTetherc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Bulletc extends mindustry.gen.Bulletc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Childc extends mindustry.gen.Childc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Crawlc extends mindustry.gen.Crawlc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Damagec extends mindustry.gen.Damagec {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Decalc extends mindustry.gen.Decalc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Drawc extends mindustry.gen.Drawc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface EffectStatec extends mindustry.gen.EffectStatec {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface ElevationMovec extends mindustry.gen.ElevationMovec {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Entityc extends mindustry.gen.Entityc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Firec extends mindustry.gen.Firec {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Flyingc extends mindustry.gen.Flyingc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Healthc extends mindustry.gen.Healthc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Hitboxc extends mindustry.gen.Hitboxc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Itemsc extends mindustry.gen.Itemsc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface LaunchCorec extends mindustry.gen.LaunchCorec {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Legsc extends mindustry.gen.Legsc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Mechc extends mindustry.gen.Mechc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Minerc extends mindustry.gen.Minerc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Ownerc extends mindustry.gen.Ownerc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Payloadc extends mindustry.gen.Payloadc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Physicsc extends mindustry.gen.Physicsc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Playerc extends mindustry.gen.Playerc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Posc extends mindustry.gen.Posc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface PowerGraphUpdaterc extends mindustry.gen.PowerGraphUpdaterc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Puddlec extends mindustry.gen.Puddlec {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Rotc extends mindustry.gen.Rotc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Shieldc extends mindustry.gen.Shieldc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Shielderc extends mindustry.gen.Shielderc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Statusc extends mindustry.gen.Statusc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Syncc extends mindustry.gen.Syncc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Tankc extends mindustry.gen.Tankc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Teamc extends mindustry.gen.Teamc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Timedc extends mindustry.gen.Timedc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface TimedKillc extends mindustry.gen.TimedKillc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Timerc extends mindustry.gen.Timerc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Unitc extends mindustry.gen.Unitc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface UnitTetherc extends mindustry.gen.UnitTetherc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Velc extends mindustry.gen.Velc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface WaterMovec extends mindustry.gen.WaterMovec {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface Weaponsc extends mindustry.gen.Weaponsc {\r\n", "    }\r\n", "\r\n", "    @ModAnnotations.EntitySuperClass()\r\n", "    interface WorldLabelc extends mindustry.gen.WorldLabelc {\r\n", "    }\r\n", "}\r\n" }));
        compMap.put("BlockUnitComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.graphics.g2d.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class BlockUnitComp implements Unitc {\n", "\n", "    @Import\n", "    Team team;\n", "\n", "    @ReadOnly\n", "    transient Building tile;\n", "\n", "    public void tile(Building tile) {\n", "        this.tile = tile;\n", "        // sets up block stats\n", "        maxHealth(tile.block.health);\n", "        health(tile.health);\n", "        hitSize(tile.block.size * tilesize * 0.7f);\n", "        set(tile);\n", "    }\n", "\n", "    @Override\n", "    public void add() {\n", "        if (tile == null) {\n", "            throw new RuntimeException(\"Do not add BlockUnit entities to the game, they will simply crash. Internal use only.\");\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        if (tile != null) {\n", "            team = tile.team;\n", "        }\n", "    }\n", "\n", "    @Replace\n", "    @Override\n", "    public TextureRegion icon() {\n", "        return tile.block.fullIcon;\n", "    }\n", "\n", "    @Override\n", "    public void killed() {\n", "        tile.kill();\n", "    }\n", "\n", "    @Replace\n", "    public void damage(float v, boolean b) {\n", "        tile.damage(v, b);\n", "    }\n", "\n", "    @Replace\n", "    public boolean dead() {\n", "        return tile == null || tile.dead();\n", "    }\n", "\n", "    @Replace\n", "    public boolean isValid() {\n", "        return tile != null && tile.isValid();\n", "    }\n", "\n", "    @Replace\n", "    public void team(Team team) {\n", "        if (tile != null && this.team != team) {\n", "            this.team = team;\n", "            if (tile.team != team) {\n", "                tile.team(team);\n", "            }\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("BoundedComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.math.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class BoundedComp implements Velc, Posc, Healthc, Flyingc {\n", "\n", "    static final float warpDst = 30f;\n", "\n", "    @Import\n", "    float x, y;\n", "\n", "    @Import\n", "    Team team;\n", "\n", "    @Override\n", "    public void update() {\n", "        float bot = 0f, left = 0f, top = world.unitHeight(), right = world.unitWidth();\n", "        // TODO hidden map rules only apply to player teams? should they?\n", "        if (state.rules.limitMapArea && !team.isAI()) {\n", "            bot = state.rules.limitY * tilesize;\n", "            left = state.rules.limitX * tilesize;\n", "            top = state.rules.limitHeight * tilesize + bot;\n", "            right = state.rules.limitWidth * tilesize + left;\n", "        }\n", "        if (!net.client() || isLocal()) {\n", "            float dx = 0f, dy = 0f;\n", "            // repel unit out of bounds\n", "            if (x < left)\n", "                dx += (-(x - left) / warpDst);\n", "            if (y < bot)\n", "                dy += (-(y - bot) / warpDst);\n", "            if (x > right)\n", "                dx -= (x - right) / warpDst;\n", "            if (y > top)\n", "                dy -= (y - top) / warpDst;\n", "            velAddNet(dx * Time.delta, dy * Time.delta);\n", "        }\n", "        // clamp position if not flying\n", "        if (isGrounded()) {\n", "            x = Mathf.clamp(x, left, right - tilesize);\n", "            y = Mathf.clamp(y, bot, top - tilesize);\n", "        }\n", "        // kill when out of bounds\n", "        if (x < -finalWorldBounds + left || y < -finalWorldBounds + bot || x >= right + finalWorldBounds || y >= top + finalWorldBounds) {\n", "            kill();\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("BuilderComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.*;\n", "import arc.func.*;\n", "import arc.graphics.*;\n", "import arc.graphics.g2d.*;\n", "import arc.math.*;\n", "import arc.struct.Queue;\n", "import arc.util.*;\n", "import mindustry.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.entities.units.*;\n", "import mindustry.game.EventType.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import mindustry.graphics.*;\n", "import mindustry.type.*;\n", "import mindustry.world.*;\n", "import mindustry.world.blocks.*;\n", "import mindustry.world.blocks.ConstructBlock.*;\n", "import java.util.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class BuilderComp implements Posc, Statusc, Teamc, Rotc {\n", "\n", "    @Import\n", "    float x, y, rotation, buildSpeedMultiplier;\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    @Import\n", "    Team team;\n", "\n", "    @SyncLocal\n", "    Queue<BuildPlan> plans = new Queue<>(1);\n", "\n", "    @SyncLocal\n", "    boolean updateBuilding = true;\n", "\n", "    private transient float buildCounter;\n", "\n", "    private transient BuildPlan lastActive;\n", "\n", "    private transient int lastSize;\n", "\n", "    transient float buildAlpha = 0f;\n", "\n", "    public boolean canBuild() {\n", "        return type.buildSpeed > 0 && buildSpeedMultiplier > 0;\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        updateBuildLogic();\n", "    }\n", "\n", "    public void validatePlans() {\n", "        if (plans.size > 0) {\n", "            Iterator<BuildPlan> it = plans.iterator();\n", "            while (it.hasNext()) {\n", "                BuildPlan plan = it.next();\n", "                Tile tile = world.tile(plan.x, plan.y);\n", "                if (tile == null || (plan.breaking && tile.block() == Blocks.air) || (!plan.breaking && ((tile.build != null && tile.build.rotation == plan.rotation) || !plan.block.rotate) && tile.block() == plan.block)) {\n", "                    it.remove();\n", "                }\n", "            }\n", "        }\n", "    }\n", "\n", "    public void updateBuildLogic() {\n", "        if (type.buildSpeed <= 0f)\n", "            return;\n", "        if (!headless) {\n", "            // visual activity update\n", "            if (lastActive != null && buildAlpha <= 0.01f) {\n", "                lastActive = null;\n", "            }\n", "            buildAlpha = Mathf.lerpDelta(buildAlpha, activelyBuilding() ? 1f : 0f, 0.15f);\n", "        }\n", "        // validate regardless of whether building is enabled.\n", "        if (!updateBuilding || !canBuild()) {\n", "            validatePlans();\n", "            return;\n", "        }\n", "        float finalPlaceDst = state.rules.infiniteResources ? Float.MAX_VALUE : type.buildRange;\n", "        boolean infinite = state.rules.infiniteResources || team().rules().infiniteResources;\n", "        buildCounter += Time.delta;\n", "        if (Float.isNaN(buildCounter) || Float.isInfinite(buildCounter))\n", "            buildCounter = 0f;\n", "        buildCounter = Math.min(buildCounter, 10f);\n", "        while (buildCounter >= 1) {\n", "            buildCounter -= 1f;\n", "            validatePlans();\n", "            var core = core();\n", "            // nothing to build.\n", "            if (buildPlan() == null)\n", "                continue;\n", "            // find the next build plan\n", "            if (plans.size > 1) {\n", "                int total = 0;\n", "                BuildPlan plan;\n", "                while ((!within((plan = buildPlan()).tile(), finalPlaceDst) || shouldSkip(plan, core)) && total < plans.size) {\n", "                    plans.removeFirst();\n", "                    plans.addLast(plan);\n", "                    total++;\n", "                }\n", "            }\n", "            BuildPlan current = buildPlan();\n", "            Tile tile = current.tile();\n", "            lastActive = current;\n", "            buildAlpha = 1f;\n", "            if (current.breaking)\n", "                lastSize = tile.block().size;\n", "            if (!within(tile, finalPlaceDst))\n", "                continue;\n", "            if (!headless) {\n", "                Vars.control.sound.loop(Sounds.build, tile, 0.51f);\n", "            }\n", "            if (!(tile.build instanceof ConstructBuild cb)) {\n", "                if (!current.initialized && !current.breaking && Build.validPlace(current.block, team, current.x, current.y, current.rotation)) {\n", "                    boolean hasAll = infinite || current.isRotation(team) || !Structs.contains(current.block.requirements, i -> core != null && !core.items.has(i.item, Math.min(Mathf.round(i.amount * state.rules.buildCostMultiplier), 1)));\n", "                    if (hasAll) {\n", "                        Call.beginPlace(self(), current.block, team, current.x, current.y, current.rotation);\n", "                    } else {\n", "                        current.stuck = true;\n", "                    }\n", "                } else if (!current.initialized && current.breaking && Build.validBreak(team, current.x, current.y)) {\n", "                    Call.beginBreak(self(), team, current.x, current.y);\n", "                } else {\n", "                    plans.removeFirst();\n", "                    continue;\n", "                }\n", "            } else if ((tile.team() != team && tile.team() != Team.derelict) || (!current.breaking && (cb.current != current.block || cb.tile != current.tile()))) {\n", "                plans.removeFirst();\n", "                continue;\n", "            }\n", "            if (tile.build instanceof ConstructBuild && !current.initialized) {\n", "                Core.app.post(() -> Events.fire(new BuildSelectEvent(tile, team, self(), current.breaking)));\n", "                current.initialized = true;\n", "            }\n", "            // if there is no core to build with or no build entity, stop building!\n", "            if ((core == null && !infinite) || !(tile.build instanceof ConstructBuild entity)) {\n", "                continue;\n", "            }\n", "            float bs = 1f / entity.buildCost * type.buildSpeed * buildSpeedMultiplier * state.rules.buildSpeed(team);\n", "            // otherwise, update it.\n", "            if (current.breaking) {\n", "                entity.deconstruct(self(), core, bs);\n", "            } else {\n", "                entity.construct(self(), core, bs, current.config);\n", "            }\n", "            current.stuck = Mathf.equal(current.progress, entity.progress);\n", "            current.progress = entity.progress;\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Draw all current build plans. Does not draw the beam effect, only the positions.\n", "     */\n", "    void drawBuildPlans() {\n", "        Boolf<BuildPlan> skip = plan -> plan.progress > 0.01f || (buildPlan() == plan && plan.initialized && (within(plan.x * tilesize, plan.y * tilesize, type.buildRange) || state.isEditor()));\n", "        for (int i = 0; i < 2; i++) {\n", "            for (BuildPlan plan : plans) {\n", "                if (skip.get(plan))\n", "                    continue;\n", "                if (i == 0) {\n", "                    drawPlan(plan, 1f);\n", "                } else {\n", "                    drawPlanTop(plan, 1f);\n", "                }\n", "            }\n", "        }\n", "        Draw.reset();\n", "    }\n", "\n", "    void drawPlan(BuildPlan plan, float alpha) {\n", "        plan.animScale = 1f;\n", "        if (plan.breaking) {\n", "            control.input.drawBreaking(plan);\n", "        } else {\n", "            plan.block.drawPlan(plan, control.input.allPlans(), Build.validPlace(plan.block, team, plan.x, plan.y, plan.rotation) || control.input.planMatches(plan), alpha);\n", "        }\n", "    }\n", "\n", "    void drawPlanTop(BuildPlan plan, float alpha) {\n", "        if (!plan.breaking) {\n", "            Draw.reset();\n", "            Draw.mixcol(Color.white, 0.24f + Mathf.absin(Time.globalTime, 6f, 0.28f));\n", "            Draw.alpha(alpha);\n", "            plan.block.drawPlanConfigTop(plan, plans);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * @return whether this plan should be skipped, in favor of the next one.\n", "     */\n", "    boolean shouldSkip(BuildPlan plan, @Nullable Building core) {\n", "        // plans that you have at least *started* are considered\n", "        if (state.rules.infiniteResources || team.rules().infiniteResources || plan.breaking || core == null || plan.isRotation(team) || (isBuilding() && !within(plans.last(), type.buildRange)))\n", "            return false;\n", "        return (plan.stuck && !core.items.has(plan.block.requirements)) || (Structs.contains(plan.block.requirements, i -> !core.items.has(i.item, Math.min(i.amount, 15)) && Mathf.round(i.amount * state.rules.buildCostMultiplier) > 0) && !plan.initialized);\n", "    }\n", "\n", "    void removeBuild(int x, int y, boolean breaking) {\n", "        // remove matching plan\n", "        int idx = plans.indexOf(req -> req.breaking == breaking && req.x == x && req.y == y);\n", "        if (idx != -1) {\n", "            plans.removeIndex(idx);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Return whether this builder's place queue contains items.\n", "     */\n", "    boolean isBuilding() {\n", "        return plans.size != 0;\n", "    }\n", "\n", "    /**\n", "     * Clears the placement queue.\n", "     */\n", "    void clearBuilding() {\n", "        plans.clear();\n", "    }\n", "\n", "    /**\n", "     * Add another build plans to the tail of the queue, if it doesn't exist there yet.\n", "     */\n", "    void addBuild(BuildPlan place) {\n", "        addBuild(place, true);\n", "    }\n", "\n", "    /**\n", "     * Add another build plans to the queue, if it doesn't exist there yet.\n", "     */\n", "    void addBuild(BuildPlan place, boolean tail) {\n", "        if (!canBuild())\n", "            return;\n", "        BuildPlan replace = null;\n", "        for (BuildPlan plan : plans) {\n", "            if (plan.x == place.x && plan.y == place.y) {\n", "                replace = plan;\n", "                break;\n", "            }\n", "        }\n", "        if (replace != null) {\n", "            plans.remove(replace);\n", "        }\n", "        Tile tile = world.tile(place.x, place.y);\n", "        ConstructBuild cons;\n", "        if (tile != null && (tile.build instanceof ConstructBuild && (cons = (ConstructBuild) tile.build) == tile.build)) {\n", "            place.progress = cons.progress;\n", "        }\n", "        if (tail) {\n", "            plans.addLast(place);\n", "        } else {\n", "            plans.addFirst(place);\n", "        }\n", "    }\n", "\n", "    boolean activelyBuilding() {\n", "        // not actively building when not near the build plan\n", "        if (isBuilding()) {\n", "            var plan = buildPlan();\n", "            if (!state.isEditor() && plan != null && !within(plan, state.rules.infiniteResources ? Float.MAX_VALUE : type.buildRange)) {\n", "                return false;\n", "            }\n", "        }\n", "        return isBuilding() && updateBuilding;\n", "    }\n", "\n", "    /**\n", "     * @return  the build plan currently active, or the one at the top of the queue.\n", "     */\n", "    @Nullable\n", "    BuildPlan buildPlan() {\n", "        return plans.size == 0 ? null : plans.first();\n", "    }\n", "\n", "    public void draw() {\n", "        drawBuilding();\n", "    }\n", "\n", "    public void drawBuilding() {\n", "        // TODO make this more generic so it works with builder \"weapons\"\n", "        boolean active = activelyBuilding();\n", "        if (!active && lastActive == null)\n", "            return;\n", "        Draw.z(Layer.flyingUnit);\n", "        BuildPlan plan = active ? buildPlan() : lastActive;\n", "        Tile tile = plan.tile();\n", "        var core = team.core();\n", "        if (tile == null || !within(plan, state.rules.infiniteResources ? Float.MAX_VALUE : type.buildRange)) {\n", "            return;\n", "        }\n", "        // draw remote plans.\n", "        if (core != null && active && !isLocal() && !(tile.block() instanceof ConstructBlock)) {\n", "            Draw.z(Layer.plans - 1f);\n", "            drawPlan(plan, 0.5f);\n", "            drawPlanTop(plan, 0.5f);\n", "            Draw.z(Layer.flyingUnit);\n", "        }\n", "        if (type.drawBuildBeam) {\n", "            float focusLen = type.buildBeamOffset + Mathf.absin(Time.time, 3f, 0.6f);\n", "            float px = x + Angles.trnsx(rotation, focusLen);\n", "            float py = y + Angles.trnsy(rotation, focusLen);\n", "            drawBuildingBeam(px, py);\n", "        }\n", "    }\n", "\n", "    public void drawBuildingBeam(float px, float py) {\n", "        boolean active = activelyBuilding();\n", "        if (!active && lastActive == null)\n", "            return;\n", "        Draw.z(Layer.flyingUnit);\n", "        BuildPlan plan = active ? buildPlan() : lastActive;\n", "        Tile tile = world.tile(plan.x, plan.y);\n", "        if (tile == null || !within(plan, state.rules.infiniteResources ? Float.MAX_VALUE : type.buildRange)) {\n", "            return;\n", "        }\n", "        int size = plan.breaking ? active ? tile.block().size : lastSize : plan.block.size;\n", "        float tx = plan.drawx(), ty = plan.drawy();\n", "        Lines.stroke(1f, plan.breaking ? Pal.remove : Pal.accent);\n", "        Draw.z(Layer.buildBeam);\n", "        Draw.alpha(buildAlpha);\n", "        if (!active && !(tile.build instanceof ConstructBuild)) {\n", "            Fill.square(plan.drawx(), plan.drawy(), size * tilesize / 2f);\n", "        }\n", "        Drawf.buildBeam(px, py, tx, ty, Vars.tilesize * size / 2f);\n", "        Fill.square(px, py, 1.8f + Mathf.absin(Time.time, 2.2f, 1.1f), rotation + 45);\n", "        Draw.reset();\n", "        Draw.z(Layer.flyingUnit);\n", "    }\n", "}\n" }));
        compMap.put("BuildingComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.*;\n", "import arc.Graphics.*;\n", "import arc.Graphics.Cursor.*;\n", "import arc.func.*;\n", "import arc.graphics.*;\n", "import arc.graphics.g2d.*;\n", "import arc.math.*;\n", "import arc.math.geom.*;\n", "import arc.math.geom.QuadTree.*;\n", "import arc.scene.ui.*;\n", "import arc.scene.ui.layout.*;\n", "import arc.struct.*;\n", "import arc.util.*;\n", "import arc.util.io.*;\n", "import mindustry.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.audio.*;\n", "import mindustry.content.*;\n", "import mindustry.core.*;\n", "import mindustry.ctype.*;\n", "import mindustry.entities.*;\n", "import mindustry.game.EventType.*;\n", "import mindustry.game.*;\n", "import mindustry.game.Teams.*;\n", "import mindustry.gen.*;\n", "import mindustry.graphics.*;\n", "import mindustry.logic.*;\n", "import mindustry.type.*;\n", "import mindustry.ui.*;\n", "import mindustry.world.*;\n", "import mindustry.world.blocks.ConstructBlock.*;\n", "import mindustry.world.blocks.*;\n", "import mindustry.world.blocks.environment.*;\n", "import mindustry.world.blocks.heat.*;\n", "import mindustry.world.blocks.heat.HeatConductor.*;\n", "import mindustry.world.blocks.logic.LogicBlock.*;\n", "import mindustry.world.blocks.payloads.*;\n", "import mindustry.world.blocks.power.*;\n", "import mindustry.world.consumers.*;\n", "import mindustry.world.meta.*;\n", "import mindustry.world.modules.*;\n", "import java.util.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { Buildingc.class }, isFinal = false, genio = false, serialize = false)\n", "@Component(base = true)\n", "abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc, Timerc, QuadTreeObject, Displayable, Senseable, Controllable, Sized {\n", "\n", "    // region vars and initialization\n", "    static final float timeToSleep = 60f * 1, recentDamageTime = 60f * 5f;\n", "\n", "    static final ObjectSet<Building> tmpTiles = new ObjectSet<>();\n", "\n", "    static final Seq<Building> tempBuilds = new Seq<>();\n", "\n", "    static final BuildTeamChangeEvent teamChangeEvent = new BuildTeamChangeEvent();\n", "\n", "    static final BuildDamageEvent bulletDamageEvent = new BuildDamageEvent();\n", "\n", "    static int sleepingEntities = 0;\n", "\n", "    @Import\n", "    float x, y, health, maxHealth;\n", "\n", "    @Import\n", "    Team team;\n", "\n", "    transient Tile tile;\n", "\n", "    transient Block block;\n", "\n", "    transient Seq<Building> proximity = new Seq<>(6);\n", "\n", "    transient int cdump;\n", "\n", "    transient int rotation;\n", "\n", "    transient float payloadRotation;\n", "\n", "    transient String lastAccessed;\n", "\n", "    // used only by the indexer\n", "    transient boolean wasDamaged;\n", "\n", "    transient float visualLiquid;\n", "\n", "    /**\n", "     * TODO Each bit corresponds to a team ID. Only 64 are supported. Does not work on servers.\n", "     */\n", "    transient long visibleFlags;\n", "\n", "    // used only by the block renderer when fog is on (TODO replace with discovered check?)\n", "    transient boolean wasVisible;\n", "\n", "    transient boolean enabled = true;\n", "\n", "    @Nullable\n", "    transient Building lastDisabler;\n", "\n", "    @Nullable\n", "    PowerModule power;\n", "\n", "    @Nullable\n", "    ItemModule items;\n", "\n", "    @Nullable\n", "    LiquidModule liquids;\n", "\n", "    /**\n", "     * Base efficiency. Takes the minimum value of all consumers.\n", "     */\n", "    transient float efficiency;\n", "\n", "    /**\n", "     * Same as efficiency, but for optional consumers only.\n", "     */\n", "    transient float optionalEfficiency;\n", "\n", "    /**\n", "     * The efficiency this block *would* have if shouldConsume() returned true.\n", "     */\n", "    transient float potentialEfficiency;\n", "\n", "    transient float healSuppressionTime = -1f;\n", "\n", "    transient float lastHealTime = -120f * 10f;\n", "\n", "    private transient float lastDamageTime = -recentDamageTime;\n", "\n", "    private transient float timeScale = 1f, timeScaleDuration;\n", "\n", "    private transient float dumpAccum;\n", "\n", "    @Nullable\n", "    private transient SoundLoop sound;\n", "\n", "    private transient boolean sleeping;\n", "\n", "    private transient float sleepTime;\n", "\n", "    private transient boolean initialized;\n", "\n", "    /**\n", "     * Sets this tile entity data to this and adds it if necessary.\n", "     */\n", "    public Building init(Tile tile, Team team, boolean shouldAdd, int rotation) {\n", "        if (!initialized) {\n", "            create(tile.block(), team);\n", "        } else {\n", "            if (block.hasPower) {\n", "                power.init = false;\n", "                // reinit power graph\n", "                new PowerGraph().add(self());\n", "            }\n", "        }\n", "        proximity.clear();\n", "        this.rotation = rotation;\n", "        this.tile = tile;\n", "        set(tile.drawx(), tile.drawy());\n", "        if (shouldAdd) {\n", "            add();\n", "        }\n", "        created();\n", "        return self();\n", "    }\n", "\n", "    /**\n", "     * Sets up all the necessary variables, but does not add this entity anywhere.\n", "     */\n", "    public Building create(Block block, Team team) {\n", "        this.block = block;\n", "        this.team = team;\n", "        if (block.loopSound != Sounds.none) {\n", "            sound = new SoundLoop(block.loopSound, block.loopSoundVolume);\n", "        }\n", "        health = block.health;\n", "        maxHealth(block.health);\n", "        timer(new Interval(block.timers));\n", "        if (block.hasItems)\n", "            items = new ItemModule();\n", "        if (block.hasLiquids)\n", "            liquids = new LiquidModule();\n", "        if (block.hasPower) {\n", "            power = new PowerModule();\n", "            power.graph.add(self());\n", "        }\n", "        initialized = true;\n", "        return self();\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public int tileX() {\n", "        return tile.x;\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public int tileY() {\n", "        return tile.y;\n", "    }\n", "\n", "    // endregion\n", "    // region io\n", "    public final void writeBase(Writes write) {\n", "        boolean writeVisibility = state.rules.fog && visibleFlags != 0;\n", "        write.f(health);\n", "        write.b(rotation | 0b10000000);\n", "        write.b(team.id);\n", "        // version\n", "        write.b(writeVisibility ? 4 : 3);\n", "        write.b(enabled ? 1 : 0);\n", "        // write presence of items/power/liquids/cons, so removing/adding them does not corrupt future saves.\n", "        write.b(moduleBitmask());\n", "        if (items != null)\n", "            items.write(write);\n", "        if (power != null)\n", "            power.write(write);\n", "        if (liquids != null)\n", "            liquids.write(write);\n", "        // efficiency is written as two bytes to save space\n", "        write.b((byte) (Mathf.clamp(efficiency) * 255f));\n", "        write.b((byte) (Mathf.clamp(optionalEfficiency) * 255f));\n", "        // only write visibility when necessary, saving 8 bytes - implies new version\n", "        if (writeVisibility) {\n", "            write.l(visibleFlags);\n", "        }\n", "    }\n", "\n", "    public final void readBase(Reads read) {\n", "        // cap health by block health in case of nerfs\n", "        health = Math.min(read.f(), block.health);\n", "        byte rot = read.b();\n", "        team = Team.get(read.b());\n", "        rotation = rot & 0b01111111;\n", "        int moduleBits = moduleBitmask();\n", "        boolean legacy = true;\n", "        byte version = 0;\n", "        // new version\n", "        if ((rot & 0b10000000) != 0) {\n", "            // version of entity save\n", "            version = read.b();\n", "            if (version >= 1) {\n", "                byte on = read.b();\n", "                this.enabled = on == 1;\n", "            }\n", "            // get which modules should actually be read; this was added in version 2\n", "            if (version >= 2) {\n", "                moduleBits = read.b();\n", "            }\n", "            legacy = false;\n", "        }\n", "        if ((moduleBits & 1) != 0)\n", "            (items == null ? new ItemModule() : items).read(read, legacy);\n", "        if ((moduleBits & 2) != 0)\n", "            (power == null ? new PowerModule() : power).read(read, legacy);\n", "        if ((moduleBits & 4) != 0)\n", "            (liquids == null ? new LiquidModule() : liquids).read(read, legacy);\n", "        // unnecessary consume module read in version 2 and below\n", "        if (version <= 2)\n", "            read.bool();\n", "        // version 3 has efficiency numbers instead of bools\n", "        if (version >= 3) {\n", "            efficiency = potentialEfficiency = read.ub() / 255f;\n", "            optionalEfficiency = read.ub() / 255f;\n", "        }\n", "        // version 4 (and only 4 at the moment) has visibility flags\n", "        if (version == 4) {\n", "            visibleFlags = read.l();\n", "        }\n", "    }\n", "\n", "    public int moduleBitmask() {\n", "        return (items != null ? 1 : 0) | (power != null ? 2 : 0) | (liquids != null ? 4 : 0) | 8;\n", "    }\n", "\n", "    public void writeAll(Writes write) {\n", "        writeBase(write);\n", "        write(write);\n", "    }\n", "\n", "    public void readAll(Reads read, byte revision) {\n", "        readBase(read);\n", "        read(read, revision);\n", "    }\n", "\n", "    @CallSuper\n", "    public void write(Writes write) {\n", "        // overriden by subclasses!\n", "    }\n", "\n", "    @CallSuper\n", "    public void read(Reads read, byte revision) {\n", "        // overriden by subclasses!\n", "    }\n", "\n", "    // endregion\n", "    // region utility methods\n", "    public void addPlan(boolean checkPrevious) {\n", "        addPlan(checkPrevious, false);\n", "    }\n", "\n", "    public void addPlan(boolean checkPrevious, boolean ignoreConditions) {\n", "        if (!ignoreConditions && (!block.rebuildable || (team == state.rules.defaultTeam && state.isCampaign() && !block.isVisible())))\n", "            return;\n", "        Object overrideConfig = null;\n", "        Block toAdd = this.block;\n", "        ConstructBuild entity;\n", "        if ((self() instanceof ConstructBuild && (entity = (ConstructBuild) self()) == self())) {\n", "            // update block to reflect the fact that something was being constructed\n", "            if (entity.current != null && entity.current.synthetic() && entity.wasConstructing) {\n", "                toAdd = entity.current;\n", "                overrideConfig = entity.lastConfig;\n", "            } else {\n", "                // otherwise this was a deconstruction that was interrupted, don't want to rebuild that\n", "                return;\n", "            }\n", "        }\n", "        TeamData data = team.data();\n", "        if (checkPrevious) {\n", "            // remove existing blocks that have been placed here.\n", "            // painful O(n) iteration + copy\n", "            for (int i = 0; i < data.plans.size; i++) {\n", "                BlockPlan b = data.plans.get(i);\n", "                if (b.x == tile.x && b.y == tile.y) {\n", "                    data.plans.removeIndex(i);\n", "                    break;\n", "                }\n", "            }\n", "        }\n", "        data.plans.addFirst(new BlockPlan(tile.x, tile.y, (short) rotation, toAdd.id, overrideConfig == null ? config() : overrideConfig));\n", "    }\n", "\n", "    @Nullable\n", "    public Tile findClosestEdge(Position to, Boolf<Tile> solid) {\n", "        Tile best = null;\n", "        float mindst = 0f;\n", "        for (var point : Edges.getEdges(block.size)) {\n", "            Tile other = Vars.world.tile(tile.x + point.x, tile.y + point.y);\n", "            if (other != null && !solid.get(other) && (best == null || to.dst2(other) < mindst)) {\n", "                best = other;\n", "                mindst = other.dst2(other);\n", "            }\n", "        }\n", "        return best;\n", "    }\n", "\n", "    /**\n", "     * Configure with the current, local player.\n", "     */\n", "    public void configure(Object value) {\n", "        // save last used config\n", "        block.lastConfig = value;\n", "        Call.tileConfig(player, self(), value);\n", "    }\n", "\n", "    /**\n", "     * Configure from a server.\n", "     */\n", "    public void configureAny(Object value) {\n", "        Call.tileConfig(null, self(), value);\n", "    }\n", "\n", "    /**\n", "     * Deselect this tile from configuration.\n", "     */\n", "    public void deselect() {\n", "        if (!headless && control.input.config.getSelected() == self()) {\n", "            control.input.config.hideConfig();\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Called clientside when the client taps a block to config.\n", "     * @return whether the configuration UI should be shown.\n", "     */\n", "    public boolean configTapped() {\n", "        return true;\n", "    }\n", "\n", "    public float calculateHeat(float[] sideHeat) {\n", "        return calculateHeat(sideHeat, null);\n", "    }\n", "\n", "    // TODO can cameFrom be an IntSet?\n", "    public float calculateHeat(float[] sideHeat, @Nullable IntSet cameFrom) {\n", "        Arrays.fill(sideHeat, 0f);\n", "        if (cameFrom != null)\n", "            cameFrom.clear();\n", "        float heat = 0f;\n", "        for (var edge : block.getEdges()) {\n", "            Building build = nearby(edge.x, edge.y);\n", "            if (build != null && build.team == team && build instanceof HeatBlock heater && (!build.block.rotate || (relativeTo(build) + 2) % 4 == build.rotation)) {\n", "                // TODO hacky\n", "                // if there's a cycle, ignore its heat\n", "                if (!(build instanceof HeatConductorBuild hc && hc.cameFrom.contains(id()))) {\n", "                    // heat is distributed across building size\n", "                    float add = heater.heat() / build.block.size;\n", "                    sideHeat[Mathf.mod(relativeTo(build), 4)] += add;\n", "                    heat += add;\n", "                }\n", "                // register traversed cycles\n", "                if (cameFrom != null) {\n", "                    cameFrom.add(build.id);\n", "                    if (build instanceof HeatConductorBuild hc) {\n", "                        cameFrom.addAll(hc.cameFrom);\n", "                    }\n", "                }\n", "            }\n", "        }\n", "        return heat;\n", "    }\n", "\n", "    public void applyBoost(float intensity, float duration) {\n", "        // do not refresh time scale when getting a weaker intensity\n", "        if (intensity >= this.timeScale - 0.001f) {\n", "            timeScaleDuration = Math.max(timeScaleDuration, duration);\n", "        }\n", "        timeScale = Math.max(timeScale, intensity);\n", "    }\n", "\n", "    public void applySlowdown(float intensity, float duration) {\n", "        // do not refresh time scale when getting a weaker intensity\n", "        if (intensity <= this.timeScale - 0.001f) {\n", "            timeScaleDuration = Math.max(timeScaleDuration, duration);\n", "        }\n", "        timeScale = Math.min(timeScale, intensity);\n", "    }\n", "\n", "    public void applyHealSuppression(float amount) {\n", "        healSuppressionTime = Math.max(healSuppressionTime, Time.time + amount);\n", "    }\n", "\n", "    public boolean isHealSuppressed() {\n", "        return block.suppressable && Time.time <= healSuppressionTime;\n", "    }\n", "\n", "    public void recentlyHealed() {\n", "        lastHealTime = Time.time;\n", "    }\n", "\n", "    public boolean wasRecentlyHealed(float duration) {\n", "        return lastHealTime + duration >= Time.time;\n", "    }\n", "\n", "    public boolean wasRecentlyDamaged() {\n", "        return lastDamageTime + recentDamageTime >= Time.time;\n", "    }\n", "\n", "    public Building nearby(int dx, int dy) {\n", "        return world.build(tile.x + dx, tile.y + dy);\n", "    }\n", "\n", "    public Building nearby(int rotation) {\n", "        switch(rotation) {\n", "            case 0:\n", "                return world.build(tile.x + 1, tile.y);\n", "            case 1:\n", "                return world.build(tile.x, tile.y + 1);\n", "            case 2:\n", "                return world.build(tile.x - 1, tile.y);\n", "            case 3:\n", "                return world.build(tile.x, tile.y - 1);\n", "            default:\n", "                return null;\n", "        }\n", "    }\n", "\n", "    public byte relativeTo(Tile tile) {\n", "        return relativeTo(tile.x, tile.y);\n", "    }\n", "\n", "    public byte relativeTo(Building build) {\n", "        if (Math.abs(x - build.x) > Math.abs(y - build.y)) {\n", "            if (x <= build.x - 1)\n", "                return 0;\n", "            if (x >= build.x + 1)\n", "                return 2;\n", "        } else {\n", "            if (y <= build.y - 1)\n", "                return 1;\n", "            if (y >= build.y + 1)\n", "                return 3;\n", "        }\n", "        return -1;\n", "    }\n", "\n", "    public byte relativeToEdge(Tile other) {\n", "        return relativeTo(Edges.getFacingEdge(other, tile));\n", "    }\n", "\n", "    public byte relativeTo(int cx, int cy) {\n", "        return tile.absoluteRelativeTo(cx, cy);\n", "    }\n", "\n", "    /**\n", "     * Multiblock front.\n", "     */\n", "    @Nullable\n", "    public Building front() {\n", "        int trns = block.size / 2 + 1;\n", "        return nearby(Geometry.d4(rotation).x * trns, Geometry.d4(rotation).y * trns);\n", "    }\n", "\n", "    /**\n", "     * Multiblock back.\n", "     */\n", "    @Nullable\n", "    public Building back() {\n", "        int trns = block.size / 2 + 1;\n", "        return nearby(Geometry.d4(rotation + 2).x * trns, Geometry.d4(rotation + 2).y * trns);\n", "    }\n", "\n", "    /**\n", "     * Multiblock left.\n", "     */\n", "    @Nullable\n", "    public Building left() {\n", "        int trns = block.size / 2 + 1;\n", "        return nearby(Geometry.d4(rotation + 1).x * trns, Geometry.d4(rotation + 1).y * trns);\n", "    }\n", "\n", "    /**\n", "     * Multiblock right.\n", "     */\n", "    @Nullable\n", "    public Building right() {\n", "        int trns = block.size / 2 + 1;\n", "        return nearby(Geometry.d4(rotation + 3).x * trns, Geometry.d4(rotation + 3).y * trns);\n", "    }\n", "\n", "    /**\n", "     * Any class that overrides this method and changes the value must call Vars.fogControl.forceUpdate(team).\n", "     */\n", "    public float fogRadius() {\n", "        return block.fogRadius;\n", "    }\n", "\n", "    public int pos() {\n", "        return tile.pos();\n", "    }\n", "\n", "    public float rotdeg() {\n", "        return rotation * 90;\n", "    }\n", "\n", "    /**\n", "     * @return preferred rotation of main texture region to be drawn\n", "     */\n", "    public float drawrot() {\n", "        return block.rotate && block.rotateDraw ? rotation * 90 : 0f;\n", "    }\n", "\n", "    public Floor floor() {\n", "        return tile.floor();\n", "    }\n", "\n", "    public boolean interactable(Team team) {\n", "        return state.teams.canInteract(team, team());\n", "    }\n", "\n", "    public float timeScale() {\n", "        return timeScale;\n", "    }\n", "\n", "    /**\n", "     * @return the building's 'warmup', a smooth value from 0 to 1.\n", "     * usually used for crafters and things that need to spin up before reaching full efficiency.\n", "     * many blocks will just return 0.\n", "     */\n", "    public float warmup() {\n", "        return 0f;\n", "    }\n", "\n", "    /**\n", "     * @return total time this block has been producing something; non-crafter blocks usually return Time.time.\n", "     */\n", "    public float totalProgress() {\n", "        return Time.time;\n", "    }\n", "\n", "    public float progress() {\n", "        return 0f;\n", "    }\n", "\n", "    /**\n", "     * @return whether this block is allowed to update based on team/environment\n", "     */\n", "    public boolean allowUpdate() {\n", "        return // check if outside map limit\n", "        team != Team.derelict && block.supportsEnv(state.rules.env) && (!state.rules.limitMapArea || !state.rules.disableOutsideArea || Rect.contains(state.rules.limitX, state.rules.limitY, state.rules.limitWidth, state.rules.limitHeight, tile.x, tile.y));\n", "    }\n", "\n", "    public BlockStatus status() {\n", "        if (!enabled) {\n", "            return BlockStatus.logicDisable;\n", "        }\n", "        if (!shouldConsume()) {\n", "            return BlockStatus.noOutput;\n", "        }\n", "        if (efficiency <= 0 || !productionValid()) {\n", "            return BlockStatus.noInput;\n", "        }\n", "        return BlockStatus.active;\n", "    }\n", "\n", "    /**\n", "     * Call when nothing is happening to the entity. This increments the internal sleep timer.\n", "     */\n", "    public void sleep() {\n", "        sleepTime += Time.delta;\n", "        if (!sleeping && sleepTime >= timeToSleep) {\n", "            remove();\n", "            sleeping = true;\n", "            sleepingEntities++;\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Call when this entity is updating. This wakes it up.\n", "     */\n", "    public void noSleep() {\n", "        sleepTime = 0f;\n", "        if (sleeping) {\n", "            add();\n", "            sleeping = false;\n", "            sleepingEntities--;\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Returns the version of this Building IO code.\n", "     */\n", "    public byte version() {\n", "        return 0;\n", "    }\n", "\n", "    // endregion\n", "    // region handler methods\n", "    /**\n", "     * @return whether the player can select (but not actually control) this building.\n", "     */\n", "    public boolean canControlSelect(Unit player) {\n", "        return false;\n", "    }\n", "\n", "    /**\n", "     * Called when a player control-selects this building - not called for ControlBlock subclasses.\n", "     */\n", "    public void onControlSelect(Unit player) {\n", "    }\n", "\n", "    /**\n", "     * Called when this building receives a position command. Requires a commandable block.\n", "     */\n", "    public void onCommand(Vec2 target) {\n", "    }\n", "\n", "    /**\n", "     * @return the position that this block points to for commands, or null.\n", "     */\n", "    @Nullable\n", "    public Vec2 getCommandPosition() {\n", "        return null;\n", "    }\n", "\n", "    public void handleUnitPayload(Unit unit, Cons<Payload> grabber) {\n", "        Fx.spawn.at(unit);\n", "        if (unit.isPlayer()) {\n", "            unit.getPlayer().clearUnit();\n", "        }\n", "        unit.remove();\n", "        // needs new ID as it is now a payload\n", "        if (net.client()) {\n", "            unit.id = EntityGroup.nextId();\n", "        } else {\n", "            // server-side, this needs to be delayed until next frame because otherwise the packets sent out right after this event would have the wrong unit ID, leading to ghosts\n", "            Core.app.post(() -> unit.id = EntityGroup.nextId());\n", "        }\n", "        grabber.get(new UnitPayload(unit));\n", "        Fx.unitDrop.at(unit);\n", "    }\n", "\n", "    public boolean canWithdraw() {\n", "        return true;\n", "    }\n", "\n", "    public boolean canUnload() {\n", "        return block.unloadable;\n", "    }\n", "\n", "    public boolean canResupply() {\n", "        return block.allowResupply;\n", "    }\n", "\n", "    public boolean payloadCheck(int conveyorRotation) {\n", "        return block.rotate && (rotation + 2) % 4 == conveyorRotation;\n", "    }\n", "\n", "    /**\n", "     * Called when an unloader takes an item.\n", "     */\n", "    public void itemTaken(Item item) {\n", "    }\n", "\n", "    /**\n", "     * Called when this block is dropped as a payload.\n", "     */\n", "    public void dropped() {\n", "    }\n", "\n", "    /**\n", "     * This is for logic blocks.\n", "     */\n", "    public void handleString(Object value) {\n", "    }\n", "\n", "    public void created() {\n", "    }\n", "\n", "    /**\n", "     * @return whether this block is currently \"active\" and should be consuming requirements.\n", "     */\n", "    public boolean shouldConsume() {\n", "        return enabled;\n", "    }\n", "\n", "    public boolean productionValid() {\n", "        return true;\n", "    }\n", "\n", "    /**\n", "     * @return whether this building is currently \"burning\" a trigger consumer (an item) - if true, valid() on those will return true.\n", "     */\n", "    public boolean consumeTriggerValid() {\n", "        return false;\n", "    }\n", "\n", "    public float getPowerProduction() {\n", "        return 0f;\n", "    }\n", "\n", "    /**\n", "     * Returns the amount of items this block can accept.\n", "     */\n", "    public int acceptStack(Item item, int amount, Teamc source) {\n", "        if (acceptItem(self(), item) && block.hasItems && (source == null || source.team() == team)) {\n", "            return Math.min(getMaximumAccepted(item) - items.get(item), amount);\n", "        } else {\n", "            return 0;\n", "        }\n", "    }\n", "\n", "    public int getMaximumAccepted(Item item) {\n", "        return block.itemCapacity;\n", "    }\n", "\n", "    /**\n", "     * Remove a stack from this inventory, and return the amount removed.\n", "     */\n", "    public int removeStack(Item item, int amount) {\n", "        if (items == null)\n", "            return 0;\n", "        amount = Math.min(amount, items.get(item));\n", "        noSleep();\n", "        items.remove(item, amount);\n", "        return amount;\n", "    }\n", "\n", "    /**\n", "     * Handle a stack input.\n", "     */\n", "    public void handleStack(Item item, int amount, @Nullable Teamc source) {\n", "        noSleep();\n", "        items.add(item, amount);\n", "    }\n", "\n", "    /**\n", "     * Returns offset for stack placement.\n", "     */\n", "    public void getStackOffset(Item item, Vec2 trns) {\n", "    }\n", "\n", "    public boolean acceptPayload(Building source, Payload payload) {\n", "        return false;\n", "    }\n", "\n", "    public void handlePayload(Building source, Payload payload) {\n", "    }\n", "\n", "    /**\n", "     * Tries moving a payload forwards.\n", "     * @param todump payload to dump.\n", "     * @return whether the payload was moved successfully\n", "     */\n", "    public boolean movePayload(Payload todump) {\n", "        int trns = block.size / 2 + 1;\n", "        Tile next = tile.nearby(Geometry.d4(rotation).x * trns, Geometry.d4(rotation).y * trns);\n", "        if (next != null && next.build != null && next.build.team == team && next.build.acceptPayload(self(), todump)) {\n", "            next.build.handlePayload(self(), todump);\n", "            return true;\n", "        }\n", "        return false;\n", "    }\n", "\n", "    /**\n", "     * Tries dumping a payload to any adjacent block.\n", "     * @param todump payload to dump.\n", "     * @return whether the payload was moved successfully\n", "     */\n", "    public boolean dumpPayload(Payload todump) {\n", "        if (proximity.size == 0)\n", "            return false;\n", "        int dump = this.cdump;\n", "        for (int i = 0; i < proximity.size; i++) {\n", "            Building other = proximity.get((i + dump) % proximity.size);\n", "            if (other.team == team && other.acceptPayload(self(), todump)) {\n", "                other.handlePayload(self(), todump);\n", "                incrementDump(proximity.size);\n", "                return true;\n", "            }\n", "            incrementDump(proximity.size);\n", "        }\n", "        return false;\n", "    }\n", "\n", "    public void handleItem(Building source, Item item) {\n", "        items.add(item, 1);\n", "    }\n", "\n", "    public boolean acceptItem(Building source, Item item) {\n", "        return block.consumesItem(item) && items.get(item) < getMaximumAccepted(item);\n", "    }\n", "\n", "    public boolean acceptLiquid(Building source, Liquid liquid) {\n", "        return block.hasLiquids && block.consumesLiquid(liquid);\n", "    }\n", "\n", "    public void handleLiquid(Building source, Liquid liquid, float amount) {\n", "        liquids.add(liquid, amount);\n", "    }\n", "\n", "    // TODO entire liquid system is awful\n", "    public void dumpLiquid(Liquid liquid) {\n", "        dumpLiquid(liquid, 2f);\n", "    }\n", "\n", "    public void dumpLiquid(Liquid liquid, float scaling) {\n", "        dumpLiquid(liquid, scaling, -1);\n", "    }\n", "\n", "    /**\n", "     * @param outputDir output liquid direction relative to rotation, or -1 to use any direction.\n", "     */\n", "    public void dumpLiquid(Liquid liquid, float scaling, int outputDir) {\n", "        int dump = this.cdump;\n", "        if (liquids.get(liquid) <= 0.0001f)\n", "            return;\n", "        if (!net.client() && state.isCampaign() && team == state.rules.defaultTeam)\n", "            liquid.unlock();\n", "        for (int i = 0; i < proximity.size; i++) {\n", "            incrementDump(proximity.size);\n", "            Building other = proximity.get((i + dump) % proximity.size);\n", "            if (outputDir != -1 && (outputDir + rotation) % 4 != relativeTo(other))\n", "                continue;\n", "            other = other.getLiquidDestination(self(), liquid);\n", "            if (other != null && other.team == team && other.block.hasLiquids && canDumpLiquid(other, liquid) && other.liquids != null) {\n", "                float ofract = other.liquids.get(liquid) / other.block.liquidCapacity;\n", "                float fract = liquids.get(liquid) / block.liquidCapacity;\n", "                if (ofract < fract)\n", "                    transferLiquid(other, (fract - ofract) * block.liquidCapacity / scaling, liquid);\n", "            }\n", "        }\n", "    }\n", "\n", "    public boolean canDumpLiquid(Building to, Liquid liquid) {\n", "        return true;\n", "    }\n", "\n", "    public void transferLiquid(Building next, float amount, Liquid liquid) {\n", "        float flow = Math.min(next.block.liquidCapacity - next.liquids.get(liquid), amount);\n", "        if (next.acceptLiquid(self(), liquid)) {\n", "            next.handleLiquid(self(), liquid, flow);\n", "            liquids.remove(liquid, flow);\n", "        }\n", "    }\n", "\n", "    public float moveLiquidForward(boolean leaks, Liquid liquid) {\n", "        Tile next = tile.nearby(rotation);\n", "        if (next == null)\n", "            return 0;\n", "        if (next.build != null) {\n", "            return moveLiquid(next.build, liquid);\n", "        } else if (leaks && !next.block().solid && !next.block().hasLiquids) {\n", "            float leakAmount = liquids.get(liquid) / 1.5f;\n", "            Puddles.deposit(next, tile, liquid, leakAmount, true, true);\n", "            liquids.remove(liquid, leakAmount);\n", "        }\n", "        return 0;\n", "    }\n", "\n", "    public float moveLiquid(Building next, Liquid liquid) {\n", "        if (next == null)\n", "            return 0;\n", "        next = next.getLiquidDestination(self(), liquid);\n", "        if (next.team == team && next.block.hasLiquids && liquids.get(liquid) > 0f) {\n", "            float ofract = next.liquids.get(liquid) / next.block.liquidCapacity;\n", "            float fract = liquids.get(liquid) / block.liquidCapacity * block.liquidPressure;\n", "            float flow = Math.min(Mathf.clamp((fract - ofract)) * (block.liquidCapacity), liquids.get(liquid));\n", "            flow = Math.min(flow, next.block.liquidCapacity - next.liquids.get(liquid));\n", "            if (flow > 0f && ofract <= fract && next.acceptLiquid(self(), liquid)) {\n", "                next.handleLiquid(self(), liquid, flow);\n", "                liquids.remove(liquid, flow);\n", "                return flow;\n", "                // handle reactions between different liquid types ▼\n", "            } else if (!next.block.consumesLiquid(liquid) && next.liquids.currentAmount() / next.block.liquidCapacity > 0.1f && fract > 0.1f) {\n", "                // TODO !IMPORTANT! uses current(), which is 1) wrong for multi-liquid blocks and 2) causes unwanted reactions, e.g. hydrogen + slag in pump\n", "                // TODO these are incorrect effect positions\n", "                float fx = (x + next.x) / 2f, fy = (y + next.y) / 2f;\n", "                Liquid other = next.liquids.current();\n", "                // TODO liquid reaction handler for extensibility\n", "                if ((other.flammability > 0.3f && liquid.temperature > 0.7f) || (liquid.flammability > 0.3f && other.temperature > 0.7f)) {\n", "                    damageContinuous(1);\n", "                    next.damageContinuous(1);\n", "                    if (Mathf.chanceDelta(0.1)) {\n", "                        Fx.fire.at(fx, fy);\n", "                    }\n", "                } else if ((liquid.temperature > 0.7f && other.temperature < 0.55f) || (other.temperature > 0.7f && liquid.temperature < 0.55f)) {\n", "                    liquids.remove(liquid, Math.min(liquids.get(liquid), 0.7f * Time.delta));\n", "                    if (Mathf.chanceDelta(0.2f)) {\n", "                        Fx.steam.at(fx, fy);\n", "                    }\n", "                }\n", "            }\n", "        }\n", "        return 0;\n", "    }\n", "\n", "    public Building getLiquidDestination(Building from, Liquid liquid) {\n", "        return self();\n", "    }\n", "\n", "    @Nullable\n", "    public Payload getPayload() {\n", "        return null;\n", "    }\n", "\n", "    /**\n", "     * Tries to take the payload. Returns null if no payload is present.\n", "     */\n", "    @Nullable\n", "    public Payload takePayload() {\n", "        return null;\n", "    }\n", "\n", "    @Nullable\n", "    public PayloadSeq getPayloads() {\n", "        return null;\n", "    }\n", "\n", "    /**\n", "     * Tries to put this item into a nearby container, if there are no available\n", "     * containers, it gets added to the block's inventory.\n", "     */\n", "    public void offload(Item item) {\n", "        produced(item, 1);\n", "        int dump = this.cdump;\n", "        for (int i = 0; i < proximity.size; i++) {\n", "            incrementDump(proximity.size);\n", "            Building other = proximity.get((i + dump) % proximity.size);\n", "            if (other.team == team && other.acceptItem(self(), item) && canDump(other, item)) {\n", "                other.handleItem(self(), item);\n", "                return;\n", "            }\n", "        }\n", "        handleItem(self(), item);\n", "    }\n", "\n", "    /**\n", "     * Tries to put this item into a nearby container. Returns success. Unlike #offload(), this method does not change the block inventory.\n", "     */\n", "    public boolean put(Item item) {\n", "        int dump = this.cdump;\n", "        for (int i = 0; i < proximity.size; i++) {\n", "            incrementDump(proximity.size);\n", "            Building other = proximity.get((i + dump) % proximity.size);\n", "            if (other.team == team && other.acceptItem(self(), item) && canDump(other, item)) {\n", "                other.handleItem(self(), item);\n", "                return true;\n", "            }\n", "        }\n", "        return false;\n", "    }\n", "\n", "    public void produced(Item item) {\n", "        produced(item, 1);\n", "    }\n", "\n", "    public void produced(Item item, int amount) {\n", "        if (Vars.state.rules.sector != null && team == state.rules.defaultTeam) {\n", "            Vars.state.rules.sector.info.handleProduction(item, amount);\n", "            if (!net.client())\n", "                item.unlock();\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Dumps any item with an accumulator. May dump multiple times per frame. Use with care.\n", "     */\n", "    public boolean dumpAccumulate() {\n", "        return dumpAccumulate(null);\n", "    }\n", "\n", "    /**\n", "     * Dumps any item with an accumulator. May dump multiple times per frame. Use with care.\n", "     */\n", "    public boolean dumpAccumulate(Item item) {\n", "        boolean res = false;\n", "        dumpAccum += delta();\n", "        while (dumpAccum >= 1f) {\n", "            res |= dump(item);\n", "            dumpAccum -= 1f;\n", "        }\n", "        return res;\n", "    }\n", "\n", "    /**\n", "     * Try dumping any item near the building.\n", "     */\n", "    public boolean dump() {\n", "        return dump(null);\n", "    }\n", "\n", "    /**\n", "     * Try dumping a specific item near the building.\n", "     * @param todump Item to dump. Can be null to dump anything.\n", "     */\n", "    public boolean dump(Item todump) {\n", "        if (!block.hasItems || items.total() == 0 || (todump != null && !items.has(todump)))\n", "            return false;\n", "        int dump = this.cdump;\n", "        if (proximity.size == 0)\n", "            return false;\n", "        for (int i = 0; i < proximity.size; i++) {\n", "            Building other = proximity.get((i + dump) % proximity.size);\n", "            if (todump == null) {\n", "                for (int ii = 0; ii < content.items().size; ii++) {\n", "                    Item item = content.item(ii);\n", "                    if (other.team == team && items.has(item) && other.acceptItem(self(), item) && canDump(other, item)) {\n", "                        other.handleItem(self(), item);\n", "                        items.remove(item, 1);\n", "                        incrementDump(proximity.size);\n", "                        return true;\n", "                    }\n", "                }\n", "            } else {\n", "                if (other.team == team && other.acceptItem(self(), todump) && canDump(other, todump)) {\n", "                    other.handleItem(self(), todump);\n", "                    items.remove(todump, 1);\n", "                    incrementDump(proximity.size);\n", "                    return true;\n", "                }\n", "            }\n", "            incrementDump(proximity.size);\n", "        }\n", "        return false;\n", "    }\n", "\n", "    public void incrementDump(int prox) {\n", "        cdump = ((cdump + 1) % prox);\n", "    }\n", "\n", "    /**\n", "     * Used for dumping items.\n", "     */\n", "    public boolean canDump(Building to, Item item) {\n", "        return true;\n", "    }\n", "\n", "    /**\n", "     * Try offloading an item to a nearby container in its facing direction. Returns true if success.\n", "     */\n", "    public boolean moveForward(Item item) {\n", "        Building other = front();\n", "        if (other != null && other.team == team && other.acceptItem(self(), item)) {\n", "            other.handleItem(self(), item);\n", "            return true;\n", "        }\n", "        return false;\n", "    }\n", "\n", "    /**\n", "     * Called shortly before this building is removed.\n", "     */\n", "    public void onProximityRemoved() {\n", "        if (power != null) {\n", "            powerGraphRemoved();\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Called after this building is created in the world. May be called multiple times, or when adjacent buildings change.\n", "     */\n", "    public void onProximityAdded() {\n", "        if (power != null) {\n", "            updatePowerGraph();\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Called when anything adjacent to this building is placed/removed, including itself.\n", "     */\n", "    public void onProximityUpdate() {\n", "        noSleep();\n", "    }\n", "\n", "    public void updatePowerGraph() {\n", "        for (Building other : getPowerConnections(tempBuilds)) {\n", "            if (other.power != null) {\n", "                other.power.graph.addGraph(power.graph);\n", "            }\n", "        }\n", "    }\n", "\n", "    public void powerGraphRemoved() {\n", "        if (power == null)\n", "            return;\n", "        power.graph.remove(self());\n", "        for (int i = 0; i < power.links.size; i++) {\n", "            Tile other = world.tile(power.links.get(i));\n", "            if (other != null && other.build != null && other.build.power != null) {\n", "                other.build.power.links.removeValue(pos());\n", "            }\n", "        }\n", "        power.links.clear();\n", "    }\n", "\n", "    public boolean conductsTo(Building other) {\n", "        return !block.insulated;\n", "    }\n", "\n", "    public Seq<Building> getPowerConnections(Seq<Building> out) {\n", "        out.clear();\n", "        if (power == null)\n", "            return out;\n", "        for (Building other : proximity) {\n", "            if (other != null && other.power != null && other.team == team && !(block.consumesPower && other.block.consumesPower && !block.outputsPower && !other.block.outputsPower && !block.conductivePower && !other.block.conductivePower) && conductsTo(other) && other.conductsTo(self()) && !power.links.contains(other.pos())) {\n", "                out.add(other);\n", "            }\n", "        }\n", "        for (int i = 0; i < power.links.size; i++) {\n", "            Tile link = world.tile(power.links.get(i));\n", "            if (link != null && link.build != null && link.build.power != null && link.build.team == team)\n", "                out.add(link.build);\n", "        }\n", "        return out;\n", "    }\n", "\n", "    public float getProgressIncrease(float baseTime) {\n", "        return 1f / baseTime * edelta();\n", "    }\n", "\n", "    public float getDisplayEfficiency() {\n", "        return getProgressIncrease(1f) / edelta();\n", "    }\n", "\n", "    /**\n", "     * @return whether this block should play its active sound.\n", "     */\n", "    public boolean shouldActiveSound() {\n", "        return false;\n", "    }\n", "\n", "    /**\n", "     * @return whether this block should play its idle sound.\n", "     */\n", "    public boolean shouldAmbientSound() {\n", "        return shouldConsume();\n", "    }\n", "\n", "    public void drawStatus() {\n", "        if (block.enableDrawStatus && block.consumers.length > 0) {\n", "            float multiplier = block.size > 1 ? 1 : 0.64f;\n", "            float brcx = x + (block.size * tilesize / 2f) - (tilesize * multiplier / 2f);\n", "            float brcy = y - (block.size * tilesize / 2f) + (tilesize * multiplier / 2f);\n", "            Draw.z(Layer.power + 1);\n", "            Draw.color(Pal.gray);\n", "            Fill.square(brcx, brcy, 2.5f * multiplier, 45);\n", "            Draw.color(status().color);\n", "            Fill.square(brcx, brcy, 1.5f * multiplier, 45);\n", "            Draw.color();\n", "        }\n", "    }\n", "\n", "    public void drawCracks() {\n", "        if (!block.drawCracks || !damaged() || block.size > BlockRenderer.maxCrackSize)\n", "            return;\n", "        int id = pos();\n", "        TextureRegion region = renderer.blocks.cracks[block.size - 1][Mathf.clamp((int) ((1f - healthf()) * BlockRenderer.crackRegions), 0, BlockRenderer.crackRegions - 1)];\n", "        Draw.colorl(0.2f, 0.1f + (1f - healthf()) * 0.6f);\n", "        // TODO could be random, flipped, pseudorandom, etc\n", "        Draw.rect(region, x, y, (id % 4) * 90);\n", "        Draw.color();\n", "    }\n", "\n", "    /**\n", "     * Draw the block overlay that is shown when a cursor is over the block.\n", "     */\n", "    public void drawSelect() {\n", "        block.drawOverlay(x, y, rotation);\n", "    }\n", "\n", "    public void drawDisabled() {\n", "        Draw.color(Color.scarlet);\n", "        Draw.alpha(0.8f);\n", "        float size = 6f;\n", "        Draw.rect(Icon.cancel.getRegion(), x, y, size, size);\n", "        Draw.reset();\n", "    }\n", "\n", "    public void draw() {\n", "        if (block.variants == 0 || block.variantRegions == null) {\n", "            Draw.rect(block.region, x, y, drawrot());\n", "        } else {\n", "            Draw.rect(block.variantRegions[Mathf.randomSeed(tile.pos(), 0, Math.max(0, block.variantRegions.length - 1))], x, y, drawrot());\n", "        }\n", "        drawTeamTop();\n", "    }\n", "\n", "    public void payloadDraw() {\n", "        draw();\n", "    }\n", "\n", "    public void drawTeamTop() {\n", "        if (block.teamRegion.found()) {\n", "            if (block.teamRegions[team.id] == block.teamRegion)\n", "                Draw.color(team.color);\n", "            Draw.rect(block.teamRegions[team.id], x, y);\n", "            Draw.color();\n", "        }\n", "    }\n", "\n", "    public void drawLight() {\n", "        if (block.hasLiquids && block.drawLiquidLight && liquids.current().lightColor.a > 0.001f) {\n", "            // yes, I am updating in draw()... but this is purely visual anyway, better have it here than in update() where it wastes time\n", "            visualLiquid = Mathf.lerpDelta(visualLiquid, liquids.currentAmount(), 0.07f);\n", "            drawLiquidLight(liquids.current(), visualLiquid);\n", "        }\n", "    }\n", "\n", "    public void drawLiquidLight(Liquid liquid, float amount) {\n", "        if (amount > 0.01f) {\n", "            Color color = liquid.lightColor;\n", "            float fract = 1f;\n", "            float opacity = color.a * fract;\n", "            if (opacity > 0.001f) {\n", "                Drawf.light(x, y, block.size * 30f * fract, color, opacity);\n", "            }\n", "        }\n", "    }\n", "\n", "    public void drawTeam() {\n", "        Draw.color(team.color);\n", "        Draw.rect(\"block-border\", x - block.size * tilesize / 2f + 4, y - block.size * tilesize / 2f + 4);\n", "        Draw.color();\n", "    }\n", "\n", "    /**\n", "     * @return whether a building has regen/healing suppressed; if so, spawns particles on it.\n", "     */\n", "    public boolean checkSuppression() {\n", "        if (isHealSuppressed()) {\n", "            if (Mathf.chanceDelta(0.03)) {\n", "                Fx.regenSuppressParticle.at(x + Mathf.range(block.size * tilesize / 2f - 1f), y + Mathf.range(block.size * tilesize / 2f - 1f));\n", "            }\n", "            return true;\n", "        }\n", "        return false;\n", "    }\n", "\n", "    /**\n", "     * Called after the block is placed by this client.\n", "     */\n", "    @CallSuper\n", "    public void playerPlaced(Object config) {\n", "    }\n", "\n", "    /**\n", "     * Called after the block is placed by anyone.\n", "     */\n", "    @CallSuper\n", "    public void placed() {\n", "        if (net.client())\n", "            return;\n", "        if ((block.consumesPower || block.outputsPower) && block.hasPower) {\n", "            PowerNode.getNodeLinks(tile, block, team, other -> {\n", "                if (!other.power.links.contains(pos())) {\n", "                    other.configureAny(pos());\n", "                }\n", "            });\n", "        }\n", "    }\n", "\n", "    /**\n", "     * @return whether this building is in a payload\n", "     */\n", "    public boolean isPayload() {\n", "        return tile == emptyTile;\n", "    }\n", "\n", "    /**\n", "     * Called when a block is placed over some other blocks. This seq will always have at least one item.\n", "     * Should load some previous state, if necessary.\n", "     */\n", "    public void overwrote(Seq<Building> previous) {\n", "    }\n", "\n", "    public void onRemoved() {\n", "    }\n", "\n", "    /**\n", "     * Called every frame a unit is on this\n", "     */\n", "    public void unitOn(Unit unit) {\n", "    }\n", "\n", "    /**\n", "     * Called when a unit that spawned at this tile is removed.\n", "     */\n", "    public void unitRemoved(Unit unit) {\n", "    }\n", "\n", "    /**\n", "     * Called when arbitrary configuration is applied to a tile.\n", "     */\n", "    public void configured(@Nullable Unit builder, @Nullable Object value) {\n", "        // null is of type void.class; anonymous classes use their superclass.\n", "        Class<?> type = value == null ? void.class : value.getClass().isAnonymousClass() ? value.getClass().getSuperclass() : value.getClass();\n", "        if (value instanceof Item)\n", "            type = Item.class;\n", "        if (value instanceof Block)\n", "            type = Block.class;\n", "        if (value instanceof Liquid)\n", "            type = Liquid.class;\n", "        if (value instanceof UnitType)\n", "            type = UnitType.class;\n", "        if (builder != null && builder.isPlayer()) {\n", "            lastAccessed = builder.getPlayer().coloredName();\n", "        }\n", "        Building build;\n", "        if (block.configurations.containsKey(type)) {\n", "            block.configurations.get(type).get(this, value);\n", "        } else if ((value instanceof Building && (build = (Building) value) == value)) {\n", "            // copy config of another building\n", "            var conf = build.config();\n", "            if (conf != null && !(conf instanceof Building)) {\n", "                configured(builder, conf);\n", "            }\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Called when the block is tapped by the local player.\n", "     */\n", "    public void tapped() {\n", "    }\n", "\n", "    /**\n", "     * Called *after* the tile has been removed.\n", "     */\n", "    public void afterDestroyed() {\n", "        if (block.destroyBullet != null) {\n", "            // I really do not like that the bullet will not destroy derelict\n", "            // but I can't do anything about it without using a random team\n", "            // which may or may not cause issues with servers and js\n", "            block.destroyBullet.create(this, Team.derelict, x, y, 0);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * @return the cap for item amount calculations, used when this block explodes.\n", "     */\n", "    public int explosionItemCap() {\n", "        return block.itemCapacity;\n", "    }\n", "\n", "    /**\n", "     * Called when the block is destroyed. The tile is still intact at this stage.\n", "     */\n", "    public void onDestroyed() {\n", "        float explosiveness = block.baseExplosiveness;\n", "        float flammability = 0f;\n", "        float power = 0f;\n", "        if (block.hasItems) {\n", "            for (Item item : content.items()) {\n", "                int amount = Math.min(items.get(item), explosionItemCap());\n", "                explosiveness += item.explosiveness * amount;\n", "                flammability += item.flammability * amount;\n", "                power += item.charge * Mathf.pow(amount, 1.1f) * 150f;\n", "            }\n", "        }\n", "        if (block.hasLiquids) {\n", "            flammability += liquids.sum((liquid, amount) -> liquid.flammability * amount / 2f);\n", "            explosiveness += liquids.sum((liquid, amount) -> liquid.explosiveness * amount / 2f);\n", "        }\n", "        if (block.consPower != null && block.consPower.buffered) {\n", "            power += this.power.status * block.consPower.capacity;\n", "        }\n", "        if (block.hasLiquids && state.rules.damageExplosions) {\n", "            liquids.each((liquid, amount) -> {\n", "                float splash = Mathf.clamp(amount / 4f, 0f, 10f);\n", "                for (int i = 0; i < Mathf.clamp(amount / 5, 0, 30); i++) {\n", "                    Time.run(i / 2f, () -> {\n", "                        Tile other = world.tileWorld(x + Mathf.range(block.size * tilesize / 2), y + Mathf.range(block.size * tilesize / 2));\n", "                        if (other != null) {\n", "                            Puddles.deposit(other, liquid, splash);\n", "                        }\n", "                    });\n", "                }\n", "            });\n", "        }\n", "        Damage.dynamicExplosion(x, y, flammability, explosiveness * 3.5f, power, tilesize * block.size / 2f, state.rules.damageExplosions, block.destroyEffect);\n", "        if (block.createRubble && !floor().solid && !floor().isLiquid) {\n", "            Effect.rubble(x, y, block.size);\n", "        }\n", "    }\n", "\n", "    public String getDisplayName() {\n", "        // derelict team icon currently doesn't display\n", "        return team == Team.derelict ? block.localizedName + \"\\n\" + Core.bundle.get(\"block.derelict\") : block.localizedName + (team == player.team() || team.emoji.isEmpty() ? \"\" : \" \" + team.emoji);\n", "    }\n", "\n", "    public TextureRegion getDisplayIcon() {\n", "        return block.uiIcon;\n", "    }\n", "\n", "    /**\n", "     * @return the item module to use for flow rate calculations\n", "     */\n", "    public ItemModule flowItems() {\n", "        return items;\n", "    }\n", "\n", "    @Override\n", "    public void display(Table table) {\n", "        // display the block stuff\n", "        // TODO duplicated code?\n", "        table.table(t -> {\n", "            t.left();\n", "            t.add(new Image(block.getDisplayIcon(tile))).size(8 * 4);\n", "            t.labelWrap(block.getDisplayName(tile)).left().width(190f).padLeft(5);\n", "        }).growX().left();\n", "        table.row();\n", "        // only display everything else if the team is the same\n", "        if (team == player.team()) {\n", "            table.table(bars -> {\n", "                bars.defaults().growX().height(18f).pad(4);\n", "                displayBars(bars);\n", "            }).growX();\n", "            table.row();\n", "            table.table(this::displayConsumption).growX();\n", "            boolean displayFlow = (block.category == Category.distribution || block.category == Category.liquid) && block.displayFlow;\n", "            if (displayFlow) {\n", "                String ps = \" \" + StatUnit.perSecond.localized();\n", "                var flowItems = flowItems();\n", "                if (flowItems != null) {\n", "                    table.row();\n", "                    table.left();\n", "                    table.table(l -> {\n", "                        Bits current = new Bits();\n", "                        Runnable rebuild = () -> {\n", "                            l.clearChildren();\n", "                            l.left();\n", "                            for (Item item : content.items()) {\n", "                                if (flowItems.hasFlowItem(item)) {\n", "                                    l.image(item.uiIcon).padRight(3f);\n", "                                    l.label(() -> flowItems.getFlowRate(item) < 0 ? \"...\" : Strings.fixed(flowItems.getFlowRate(item), 1) + ps).color(Color.lightGray);\n", "                                    l.row();\n", "                                }\n", "                            }\n", "                        };\n", "                        rebuild.run();\n", "                        l.update(() -> {\n", "                            for (Item item : content.items()) {\n", "                                if (flowItems.hasFlowItem(item) && !current.get(item.id)) {\n", "                                    current.set(item.id);\n", "                                    rebuild.run();\n", "                                }\n", "                            }\n", "                        });\n", "                    }).left();\n", "                }\n", "                if (liquids != null) {\n", "                    table.row();\n", "                    table.left();\n", "                    table.table(l -> {\n", "                        Bits current = new Bits();\n", "                        Runnable rebuild = () -> {\n", "                            l.clearChildren();\n", "                            l.left();\n", "                            for (var liquid : content.liquids()) {\n", "                                if (liquids.hasFlowLiquid(liquid)) {\n", "                                    l.image(liquid.uiIcon).padRight(3f);\n", "                                    l.label(() -> liquids.getFlowRate(liquid) < 0 ? \"...\" : Strings.fixed(liquids.getFlowRate(liquid), 1) + ps).color(Color.lightGray);\n", "                                    l.row();\n", "                                }\n", "                            }\n", "                        };\n", "                        rebuild.run();\n", "                        l.update(() -> {\n", "                            for (var liquid : content.liquids()) {\n", "                                if (liquids.hasFlowLiquid(liquid) && !current.get(liquid.id)) {\n", "                                    current.set(liquid.id);\n", "                                    rebuild.run();\n", "                                }\n", "                            }\n", "                        });\n", "                    }).left();\n", "                }\n", "            }\n", "            if (net.active() && lastAccessed != null) {\n", "                table.row();\n", "                table.add(Core.bundle.format(\"lastaccessed\", lastAccessed)).growX().wrap().left();\n", "            }\n", "            table.marginBottom(-5);\n", "        }\n", "    }\n", "\n", "    public void displayConsumption(Table table) {\n", "        table.left();\n", "        for (Consume cons : block.consumers) {\n", "            if (cons.optional && cons.booster)\n", "                continue;\n", "            cons.build(self(), table);\n", "        }\n", "    }\n", "\n", "    public void displayBars(Table table) {\n", "        for (Func<Building, Bar> bar : block.listBars()) {\n", "            var result = bar.get(self());\n", "            if (result == null)\n", "                continue;\n", "            table.add(result).growX();\n", "            table.row();\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Called when this block is tapped to build a UI on the table.\n", "     * configurable must be true for this to be called.\n", "     */\n", "    public void buildConfiguration(Table table) {\n", "    }\n", "\n", "    /**\n", "     * Update table alignment after configuring.\n", "     */\n", "    public void updateTableAlign(Table table) {\n", "        Vec2 pos = Core.input.mouseScreen(x, y - block.size * tilesize / 2f - 1);\n", "        table.setPosition(pos.x, pos.y, Align.top);\n", "    }\n", "\n", "    /**\n", "     * Returns whether a hand cursor should be shown over this block.\n", "     */\n", "    public Cursor getCursor() {\n", "        return block.configurable && interactable(player.team()) ? SystemCursor.hand : SystemCursor.arrow;\n", "    }\n", "\n", "    /**\n", "     * Called when another tile is tapped while this building is selected.\n", "     * @return whether this block should be deselected.\n", "     */\n", "    public boolean onConfigureBuildTapped(Building other) {\n", "        if (block.clearOnDoubleTap) {\n", "            if (self() == other) {\n", "                deselect();\n", "                configure(null);\n", "                return false;\n", "            }\n", "            return true;\n", "        }\n", "        return self() != other;\n", "    }\n", "\n", "    /**\n", "     * Called when a position is tapped while this building is selected.\n", "     *\n", "     * @return whether the tap event is consumed - if true, the player will not start shooting or interact with things under the cursor.\n", "     */\n", "    public boolean onConfigureTapped(float x, float y) {\n", "        return false;\n", "    }\n", "\n", "    /**\n", "     * Called when this block's config menu is closed.\n", "     */\n", "    public void onConfigureClosed() {\n", "    }\n", "\n", "    /**\n", "     * Returns whether this config menu should show when the specified player taps it.\n", "     */\n", "    public boolean shouldShowConfigure(Player player) {\n", "        return true;\n", "    }\n", "\n", "    /**\n", "     * Whether this configuration should be hidden now. Called every frame the config is open.\n", "     */\n", "    public boolean shouldHideConfigure(Player player) {\n", "        return false;\n", "    }\n", "\n", "    public void drawConfigure() {\n", "        Draw.color(Pal.accent);\n", "        Lines.stroke(1f);\n", "        Lines.square(x, y, block.size * tilesize / 2f + 1f);\n", "        Draw.reset();\n", "    }\n", "\n", "    public boolean checkSolid() {\n", "        return false;\n", "    }\n", "\n", "    public float handleDamage(float amount) {\n", "        return amount;\n", "    }\n", "\n", "    public boolean absorbLasers() {\n", "        return block.absorbLasers;\n", "    }\n", "\n", "    public boolean isInsulated() {\n", "        return block.insulated;\n", "    }\n", "\n", "    public boolean collide(Bullet other) {\n", "        return true;\n", "    }\n", "\n", "    /**\n", "     * Handle a bullet collision.\n", "     * @return whether the bullet should be removed.\n", "     */\n", "    public boolean collision(Bullet other) {\n", "        damage(other.team, other.damage() * other.type().buildingDamageMultiplier);\n", "        Events.fire(bulletDamageEvent.set(self(), other));\n", "        return true;\n", "    }\n", "\n", "    /**\n", "     * Used to handle damage from splash damage for certain types of blocks.\n", "     */\n", "    public void damage(@Nullable Team source, float damage) {\n", "        damage(damage);\n", "    }\n", "\n", "    /**\n", "     * Handles splash damage with a bullet source.\n", "     */\n", "    public void damage(Bullet bullet, Team source, float damage) {\n", "        damage(source, damage);\n", "        Events.fire(bulletDamageEvent.set(self(), bullet));\n", "    }\n", "\n", "    /**\n", "     * Changes this building's team in a safe manner.\n", "     */\n", "    public void changeTeam(Team next) {\n", "        if (this.team == next)\n", "            return;\n", "        Team last = this.team;\n", "        boolean was = isValid();\n", "        if (was)\n", "            indexer.removeIndex(tile);\n", "        this.team = next;\n", "        if (was) {\n", "            indexer.addIndex(tile);\n", "            Events.fire(teamChangeEvent.set(last, self()));\n", "        }\n", "    }\n", "\n", "    public boolean canPickup() {\n", "        return true;\n", "    }\n", "\n", "    /**\n", "     * Called right before this building is picked up.\n", "     */\n", "    public void pickedUp() {\n", "    }\n", "\n", "    /**\n", "     * Called right after this building is picked up.\n", "     */\n", "    public void afterPickedUp() {\n", "        if (power != null) {\n", "            // TODO can lead to ghost graphs?\n", "            power.graph = new PowerGraph();\n", "            power.links.clear();\n", "            if (block.consPower != null && !block.consPower.buffered) {\n", "                power.status = 0f;\n", "            }\n", "        }\n", "    }\n", "\n", "    public void removeFromProximity() {\n", "        onProximityRemoved();\n", "        tmpTiles.clear();\n", "        Point2[] nearby = Edges.getEdges(block.size);\n", "        for (Point2 point : nearby) {\n", "            Building other = world.build(tile.x + point.x, tile.y + point.y);\n", "            // remove this tile from all nearby tile's proximities\n", "            if (other != null) {\n", "                tmpTiles.add(other);\n", "            }\n", "        }\n", "        for (Building other : tmpTiles) {\n", "            other.proximity.remove(self(), true);\n", "            other.onProximityUpdate();\n", "        }\n", "        proximity.clear();\n", "    }\n", "\n", "    public void updateProximity() {\n", "        tmpTiles.clear();\n", "        proximity.clear();\n", "        Point2[] nearby = Edges.getEdges(block.size);\n", "        for (Point2 point : nearby) {\n", "            Building other = world.build(tile.x + point.x, tile.y + point.y);\n", "            if (other == null || !(other.tile.interactable(team)))\n", "                continue;\n", "            other.proximity.addUnique(self());\n", "            tmpTiles.add(other);\n", "        }\n", "        // using a set to prevent duplicates\n", "        for (Building tile : tmpTiles) {\n", "            proximity.add(tile);\n", "        }\n", "        onProximityAdded();\n", "        onProximityUpdate();\n", "        for (Building other : tmpTiles) {\n", "            other.onProximityUpdate();\n", "        }\n", "    }\n", "\n", "    // TODO probably should not have a shouldConsume() check? should you even *use* consValid?\n", "    public void consume() {\n", "        for (Consume cons : block.consumers) {\n", "            cons.trigger(self());\n", "        }\n", "    }\n", "\n", "    public boolean canConsume() {\n", "        return potentialEfficiency > 0;\n", "    }\n", "\n", "    /**\n", "     * Scaled delta.\n", "     */\n", "    public float delta() {\n", "        return Time.delta * timeScale;\n", "    }\n", "\n", "    /**\n", "     * Efficiency * delta.\n", "     */\n", "    public float edelta() {\n", "        return efficiency * delta();\n", "    }\n", "\n", "    /**\n", "     * Called after efficiency is updated but before consumers are updated. Use to apply your own multiplier.\n", "     */\n", "    public void updateEfficiencyMultiplier() {\n", "    }\n", "\n", "    public void updateConsumption() {\n", "        // everything is valid when cheating\n", "        if (!block.hasConsumers || cheating()) {\n", "            potentialEfficiency = efficiency = optionalEfficiency = enabled ? 1f : 0f;\n", "            return;\n", "        }\n", "        // disabled -> nothing works\n", "        if (!enabled) {\n", "            potentialEfficiency = efficiency = optionalEfficiency = 0f;\n", "            return;\n", "        }\n", "        // TODO why check for old state?\n", "        boolean prevValid = efficiency > 0, update = shouldConsume() && productionValid();\n", "        float minEfficiency = 1f;\n", "        // assume efficiency is 1 for the calculations below\n", "        efficiency = optionalEfficiency = 1f;\n", "        // first pass: get the minimum efficiency of any consumer\n", "        for (var cons : block.nonOptionalConsumers) {\n", "            minEfficiency = Math.min(minEfficiency, cons.efficiency(self()));\n", "        }\n", "        // same for optionals\n", "        for (var cons : block.optionalConsumers) {\n", "            optionalEfficiency = Math.min(optionalEfficiency, cons.efficiency(self()));\n", "        }\n", "        // efficiency is now this minimum value\n", "        efficiency = minEfficiency;\n", "        optionalEfficiency = Math.min(optionalEfficiency, minEfficiency);\n", "        // assign \"potential\"\n", "        potentialEfficiency = efficiency;\n", "        // no updating means zero efficiency\n", "        if (!update) {\n", "            efficiency = optionalEfficiency = 0f;\n", "        }\n", "        updateEfficiencyMultiplier();\n", "        // second pass: update every consumer based on efficiency\n", "        if (update && prevValid && efficiency > 0) {\n", "            for (var cons : block.updateConsumers) {\n", "                cons.update(self());\n", "            }\n", "        }\n", "    }\n", "\n", "    public void updatePayload(@Nullable Unit unitHolder, @Nullable Building buildingHolder) {\n", "        update();\n", "    }\n", "\n", "    public void updateTile() {\n", "    }\n", "\n", "    /**\n", "     * @return ambient sound volume scale.\n", "     */\n", "    public float ambientVolume() {\n", "        return efficiency;\n", "    }\n", "\n", "    // endregion\n", "    // region overrides\n", "    /**\n", "     * Tile configuration. Defaults to null. Used for block rebuilding.\n", "     */\n", "    @Nullable\n", "    public Object config() {\n", "        return null;\n", "    }\n", "\n", "    @Replace\n", "    @Override\n", "    public boolean isValid() {\n", "        return tile.build == self() && !dead();\n", "    }\n", "\n", "    @MethodPriority(100)\n", "    @Override\n", "    public void heal() {\n", "        healthChanged();\n", "    }\n", "\n", "    @MethodPriority(100)\n", "    @Override\n", "    public void heal(float amount) {\n", "        healthChanged();\n", "    }\n", "\n", "    @Override\n", "    public float hitSize() {\n", "        return tile.block().size * tilesize;\n", "    }\n", "\n", "    @Replace\n", "    @Override\n", "    public void kill() {\n", "        Call.buildDestroyed(self());\n", "    }\n", "\n", "    @Replace\n", "    @Override\n", "    public void damage(float damage) {\n", "        if (dead())\n", "            return;\n", "        float dm = state.rules.blockHealth(team);\n", "        lastDamageTime = Time.time;\n", "        if (Mathf.zero(dm)) {\n", "            damage = health + 1;\n", "        } else {\n", "            damage = Damage.applyArmor(damage, block.armor) / dm;\n", "        }\n", "        // TODO handle this better on the client.\n", "        if (!net.client()) {\n", "            health -= handleDamage(damage);\n", "        }\n", "        healthChanged();\n", "        if (health <= 0) {\n", "            Call.buildDestroyed(self());\n", "        }\n", "    }\n", "\n", "    public void healthChanged() {\n", "        // server-side, health updates are batched.\n", "        if (net.server()) {\n", "            netServer.buildHealthUpdate(self());\n", "        }\n", "        indexer.notifyHealthChanged(self());\n", "    }\n", "\n", "    @Override\n", "    public double sense(LAccess sensor) {\n", "        Ranged r;\n", "        ControlBlock c;\n", "        switch(sensor) {\n", "            case x:\n", "                return World.conv(x);\n", "            case y:\n", "                return World.conv(y);\n", "            case color:\n", "                return Color.toDoubleBits(team.color.r, team.color.g, team.color.b, 1f);\n", "            case dead:\n", "                return !isValid() ? 1 : 0;\n", "            case team:\n", "                return team.id;\n", "            case health:\n", "                return health;\n", "            case maxHealth:\n", "                return maxHealth;\n", "            case efficiency:\n", "                return efficiency;\n", "            case timescale:\n", "                return timeScale;\n", "            case range:\n", "                return (this instanceof Ranged && (r = (Ranged) this) == this) ? r.range() / tilesize : 0;\n", "            case rotation:\n", "                return rotation;\n", "            case totalItems:\n", "                return items == null ? 0 : items.total();\n", "            // totalLiquids is inherently bad design, but unfortunately it is useful for conduits/tanks\n", "            case totalLiquids:\n", "                return liquids == null ? 0 : liquids.currentAmount();\n", "            case totalPower:\n", "                return power == null || block.consPower == null ? 0 : power.status * (block.consPower.buffered ? block.consPower.capacity : 1f);\n", "            case itemCapacity:\n", "                return block.hasItems ? block.itemCapacity : 0;\n", "            case liquidCapacity:\n", "                return block.hasLiquids ? block.liquidCapacity : 0;\n", "            case powerCapacity:\n", "                return block.consPower != null ? block.consPower.capacity : 0f;\n", "            case powerNetIn:\n", "                return power == null ? 0 : power.graph.getLastScaledPowerIn() * 60;\n", "            case powerNetOut:\n", "                return power == null ? 0 : power.graph.getLastScaledPowerOut() * 60;\n", "            case powerNetStored:\n", "                return power == null ? 0 : power.graph.getLastPowerStored();\n", "            case powerNetCapacity:\n", "                return power == null ? 0 : power.graph.getLastCapacity();\n", "            case enabled:\n", "                return enabled ? 1 : 0;\n", "            case controlled:\n", "                return (this instanceof ControlBlock && (c = (ControlBlock) this) == this) && c.isControlled() ? GlobalVars.ctrlPlayer : 0;\n", "            case payloadCount:\n", "                return getPayload() != null ? 1 : 0;\n", "            case size:\n", "                return block.size;\n", "            // gets converted to null in logic\n", "            default:\n", "                return Float.NaN;\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public Object senseObject(LAccess sensor) {\n", "        UnitPayload p1;\n", "        BuildPayload p2;\n", "        switch(sensor) {\n", "            case type:\n", "                return block;\n", "            case firstItem:\n", "                return items == null ? null : items.first();\n", "            case config:\n", "                return block.configSenseable() ? config() : null;\n", "            case payloadType:\n", "                return (getPayload() instanceof UnitPayload && (p1 = (UnitPayload) getPayload()) == getPayload()) ? p1.unit.type : (getPayload() instanceof BuildPayload && (p2 = (BuildPayload) getPayload()) == getPayload()) ? p2.block() : null;\n", "            default:\n", "                return noSensed;\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public double sense(Content content) {\n", "        Item i;\n", "        if ((content instanceof Item && (i = (Item) content) == content) && items != null)\n", "            return items.get(i);\n", "        Liquid l;\n", "        if ((content instanceof Liquid && (l = (Liquid) content) == content) && liquids != null)\n", "            return liquids.get(l);\n", "        // invalid sense\n", "        return Float.NaN;\n", "    }\n", "\n", "    @Override\n", "    public void control(LAccess type, double p1, double p2, double p3, double p4) {\n", "        if (type == LAccess.enabled) {\n", "            enabled = !Mathf.zero((float) p1);\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void control(LAccess type, Object p1, double p2, double p3, double p4) {\n", "        // don't execute configure instructions that copy logic building configures; this can cause extreme lag\n", "        if (type == LAccess.config && block.logicConfigurable && !(p1 instanceof LogicBuild)) {\n", "            // change config only if it's new\n", "            configured(null, p1);\n", "        }\n", "    }\n", "\n", "    @Replace\n", "    @Override\n", "    public boolean inFogTo(Team viewer) {\n", "        if (team == viewer || !state.rules.fog)\n", "            return false;\n", "        int size = block.size, of = block.sizeOffset, tx = tile.x, ty = tile.y;\n", "        for (int x = 0; x < size; x++) {\n", "            for (int y = 0; y < size; y++) {\n", "                if (fogControl.isVisibleTile(viewer, tx + x + of, ty + y + of)) {\n", "                    return false;\n", "                }\n", "            }\n", "        }\n", "        return true;\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "        if (sound != null) {\n", "            sound.stop();\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void killed() {\n", "        Events.fire(new BlockDestroyEvent(tile));\n", "        block.destroySound.at(tile);\n", "        onDestroyed();\n", "        if (tile != emptyTile) {\n", "            tile.remove();\n", "        }\n", "        remove();\n", "        afterDestroyed();\n", "    }\n", "\n", "    // TODO atrocious method and should be squished\n", "    @Final\n", "    @Replace\n", "    @Override\n", "    public void update() {\n", "        // TODO should just avoid updating buildings instead\n", "        if (state.isEditor())\n", "            return;\n", "        // TODO refactor to timestamp-based system?\n", "        if ((timeScaleDuration -= Time.delta) <= 0f || !block.canOverdrive) {\n", "            timeScale = 1f;\n", "        }\n", "        if (!allowUpdate()) {\n", "            enabled = false;\n", "        }\n", "        // TODO separate system for sound? AudioSource, etc\n", "        if (!headless) {\n", "            if (sound != null) {\n", "                sound.update(x, y, shouldActiveSound());\n", "            }\n", "            if (block.ambientSound != Sounds.none && shouldAmbientSound()) {\n", "                control.sound.loop(block.ambientSound, self(), block.ambientSoundVolume * ambientVolume());\n", "            }\n", "        }\n", "        updateConsumption();\n", "        // TODO just handle per-block instead\n", "        if (enabled || !block.noUpdateDisabled) {\n", "            updateTile();\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void hitbox(Rect out) {\n", "        out.setCentered(x, y, block.size * tilesize, block.size * tilesize);\n", "    }\n", "    // endregion\n", "}\n" }));
        compMap.put("BuildingTetherComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import mindustry.type.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "/**\n", " * A unit that depends on a building's existence; if that building is removed, it despawns.\n", " */\n", "@Component\n", "abstract class BuildingTetherComp implements Unitc {\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    @Import\n", "    Team team;\n", "\n", "    @Nullable\n", "    public Building building;\n", "\n", "    @Override\n", "    public void update() {\n", "        if (building == null || !building.isValid() || building.team != team) {\n", "            Call.unitDespawn(self());\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("BulletComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.func.*;\n", "import arc.graphics.g2d.*;\n", "import arc.math.*;\n", "import arc.math.geom.*;\n", "import arc.struct.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.core.*;\n", "import mindustry.entities.*;\n", "import mindustry.entities.bullet.*;\n", "import mindustry.game.*;\n", "import mindustry.game.Teams.*;\n", "import mindustry.gen.*;\n", "import mindustry.graphics.*;\n", "import mindustry.world.*;\n", "import mindustry.world.blocks.environment.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { Bulletc.class }, pooled = true, serialize = false)\n", "@Component(base = true)\n", "abstract class BulletComp implements Timedc, Damagec, Hitboxc, Teamc, Posc, Drawc, Shielderc, Ownerc, Velc, Bulletc, Timerc {\n", "\n", "    @Import\n", "    Team team;\n", "\n", "    @Import\n", "    Entityc owner;\n", "\n", "    @Import\n", "    float x, y, damage, lastX, lastY, time, lifetime;\n", "\n", "    @Import\n", "    Vec2 vel;\n", "\n", "    IntSeq collided = new IntSeq(6);\n", "\n", "    BulletType type;\n", "\n", "    Object data;\n", "\n", "    float fdata;\n", "\n", "    @ReadOnly\n", "    private float rotation;\n", "\n", "    // setting this variable to true prevents lifetime from decreasing for a frame.\n", "    transient boolean keepAlive;\n", "\n", "    @Nullable\n", "    transient Tile aimTile;\n", "\n", "    transient float aimX, aimY;\n", "\n", "    transient float originX, originY;\n", "\n", "    @Nullable\n", "    transient Mover mover;\n", "\n", "    transient boolean absorbed, hit;\n", "\n", "    @Nullable\n", "    transient Trail trail;\n", "\n", "    @Override\n", "    public void getCollisions(Cons<QuadTree> consumer) {\n", "        Seq<TeamData> data = state.teams.present;\n", "        for (int i = 0; i < data.size; i++) {\n", "            if (data.items[i].team != team) {\n", "                consumer.get(data.items[i].tree());\n", "            }\n", "        }\n", "    }\n", "\n", "    // bullets always considered local\n", "    @Override\n", "    @Replace\n", "    public boolean isLocal() {\n", "        return true;\n", "    }\n", "\n", "    @Override\n", "    public void add() {\n", "        type.init(self());\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "        if (Groups.isClearing)\n", "            return;\n", "        // 'despawned' only counts when the bullet is killed externally or reaches the end of life\n", "        if (!hit) {\n", "            type.despawned(self());\n", "        }\n", "        type.removed(self());\n", "        collided.clear();\n", "    }\n", "\n", "    @Override\n", "    public float damageMultiplier() {\n", "        Unit u;\n", "        if ((owner instanceof Unit && (u = (Unit) owner) == owner))\n", "            return u.damageMultiplier() * state.rules.unitDamage(team);\n", "        if (owner instanceof Building)\n", "            return state.rules.blockDamage(team);\n", "        return 1f;\n", "    }\n", "\n", "    @Override\n", "    public void absorb() {\n", "        absorbed = true;\n", "        remove();\n", "    }\n", "\n", "    public boolean hasCollided(int id) {\n", "        return collided.size != 0 && collided.contains(id);\n", "    }\n", "\n", "    @Replace\n", "    public float clipSize() {\n", "        return type.drawSize;\n", "    }\n", "\n", "    @Replace\n", "    @Override\n", "    public boolean collides(Hitboxc other) {\n", "        Teamc t;\n", "        Flyingc f;\n", "        return // prevent multiple collisions\n", "        type.collides && ((other instanceof Teamc && (t = (Teamc) other) == other) && t.team() != team) && !((other instanceof Flyingc && (f = (Flyingc) other) == other) && !f.checkTarget(type.collidesAir, type.collidesGround)) && !(type.pierce && hasCollided(other.id()));\n", "    }\n", "\n", "    @MethodPriority(100)\n", "    @Override\n", "    public void collision(Hitboxc other, float x, float y) {\n", "        type.hit(self(), x, y);\n", "        // must be last.\n", "        if (!type.pierce) {\n", "            hit = true;\n", "            remove();\n", "        } else {\n", "            collided.add(other.id());\n", "        }\n", "        Healthc h;\n", "        type.hitEntity(self(), other, (other instanceof Healthc && (h = (Healthc) other) == other) ? h.health() : 0f);\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        if (mover != null) {\n", "            mover.move(self());\n", "        }\n", "        type.update(self());\n", "        if (type.collidesTiles && type.collides && type.collidesGround) {\n", "            tileRaycast(World.toTile(lastX), World.toTile(lastY), tileX(), tileY());\n", "        }\n", "        if (type.removeAfterPierce && type.pierceCap != -1 && collided.size >= type.pierceCap) {\n", "            hit = true;\n", "            remove();\n", "        }\n", "        if (keepAlive) {\n", "            time -= Time.delta;\n", "            keepAlive = false;\n", "        }\n", "    }\n", "\n", "    public void moveRelative(float x, float y) {\n", "        float rot = rotation();\n", "        this.x += Angles.trnsx(rot, x * Time.delta, y * Time.delta);\n", "        this.y += Angles.trnsy(rot, x * Time.delta, y * Time.delta);\n", "    }\n", "\n", "    public void turn(float x, float y) {\n", "        float ang = vel.angle();\n", "        vel.add(Angles.trnsx(ang, x * Time.delta, y * Time.delta), Angles.trnsy(ang, x * Time.delta, y * Time.delta)).limit(type.speed);\n", "    }\n", "\n", "    public boolean checkUnderBuild(Building build, float x, float y) {\n", "        return (// direct hit on correct tile\n", "        !build.block.underBullets || // same team has no 'under build' mechanics\n", "        (aimTile != null && aimTile.build == build) || // a piercing bullet overshot the aim tile, it's fine to hit things now\n", "        (build.team == team) || // there was nothing to aim at\n", "        (type.pierce && aimTile != null && Mathf.dst(x, y, originX, originY) > aimTile.dst(originX, originY) + 2f) || (aimX == -1f && aimY == -1f));\n", "    }\n", "\n", "    // copy-paste of World#raycastEach, inlined for lambda capture performance.\n", "    @Override\n", "    public void tileRaycast(int x1, int y1, int x2, int y2) {\n", "        int x = x1, dx = Math.abs(x2 - x), sx = x < x2 ? 1 : -1;\n", "        int y = y1, dy = Math.abs(y2 - y), sy = y < y2 ? 1 : -1;\n", "        int e2, err = dx - dy;\n", "        int ww = world.width(), wh = world.height();\n", "        while (x >= 0 && y >= 0 && x < ww && y < wh) {\n", "            Building build = world.build(x, y);\n", "            if (type.collideFloor || type.collideTerrain) {\n", "                Tile tile = world.tile(x, y);\n", "                if (type.collideFloor && (tile == null || tile.floor().hasSurface() || tile.block() != Blocks.air) || type.collideTerrain && tile != null && tile.block() instanceof StaticWall) {\n", "                    remove();\n", "                    hit = true;\n", "                    return;\n", "                }\n", "            }\n", "            if (build != null && isAdded() && checkUnderBuild(build, x, y) && build.collide(self()) && type.testCollision(self(), build) && !build.dead() && (type.collidesTeam || build.team != team) && !(type.pierceBuilding && hasCollided(build.id))) {\n", "                boolean remove = false;\n", "                float health = build.health;\n", "                if (build.team != team) {\n", "                    remove = build.collision(self());\n", "                }\n", "                if (remove || type.collidesTeam) {\n", "                    if (Mathf.dst2(lastX, lastY, x * tilesize, y * tilesize) < Mathf.dst2(lastX, lastY, this.x, this.y)) {\n", "                        this.x = x * tilesize;\n", "                        this.y = y * tilesize;\n", "                    }\n", "                    if (!type.pierceBuilding) {\n", "                        hit = true;\n", "                        remove();\n", "                    } else {\n", "                        collided.add(build.id);\n", "                    }\n", "                }\n", "                type.hitTile(self(), build, x * tilesize, y * tilesize, health, true);\n", "                // stop raycasting when building is hit\n", "                if (type.pierceBuilding)\n", "                    return;\n", "            }\n", "            if (x == x2 && y == y2)\n", "                break;\n", "            e2 = 2 * err;\n", "            if (e2 > -dy) {\n", "                err -= dy;\n", "                x += sx;\n", "            }\n", "            if (e2 < dx) {\n", "                err += dx;\n", "                y += sy;\n", "            }\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void draw() {\n", "        Draw.z(type.layer);\n", "        type.draw(self());\n", "        type.drawLight(self());\n", "        Draw.reset();\n", "    }\n", "\n", "    public void initVel(float angle, float amount) {\n", "        vel.trns(angle, amount);\n", "        rotation = angle;\n", "    }\n", "\n", "    /**\n", "     * Sets the bullet's rotation in degrees.\n", "     */\n", "    @Override\n", "    public void rotation(float angle) {\n", "        vel.setAngle(rotation = angle);\n", "    }\n", "\n", "    /**\n", "     * @return the bullet's rotation.\n", "     */\n", "    @Override\n", "    public float rotation() {\n", "        return vel.isZero(0.001f) ? rotation : vel.angle();\n", "    }\n", "}\n" }));
        compMap.put("ChildComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.math.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class ChildComp implements Posc, Rotc {\n", "\n", "    @Import\n", "    float x, y, rotation;\n", "\n", "    @Nullable\n", "    Posc parent;\n", "\n", "    boolean rotWithParent;\n", "\n", "    float offsetX, offsetY, offsetPos, offsetRot;\n", "\n", "    @Override\n", "    public void add() {\n", "        Rotc r;\n", "        if (parent != null) {\n", "            offsetX = x - parent.getX();\n", "            offsetY = y - parent.getY();\n", "            if (rotWithParent && (parent instanceof Rotc && (r = (Rotc) parent) == parent)) {\n", "                offsetPos = -r.rotation();\n", "                offsetRot = rotation - r.rotation();\n", "            }\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        Rotc r;\n", "        if (parent != null) {\n", "            if (rotWithParent && (parent instanceof Rotc && (r = (Rotc) parent) == parent)) {\n", "                x = parent.getX() + Angles.trnsx(r.rotation() + offsetPos, offsetX, offsetY);\n", "                y = parent.getY() + Angles.trnsy(r.rotation() + offsetPos, offsetX, offsetY);\n", "                rotation = r.rotation() + offsetRot;\n", "            } else {\n", "                x = parent.getX() + offsetX;\n", "                y = parent.getY() + offsetY;\n", "            }\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("CrawlComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.math.*;\n", "import arc.math.geom.*;\n", "import arc.util.*;\n", "import mindustry.*;\n", "import mindustry.ai.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.entities.*;\n", "import mindustry.entities.EntityCollisions.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import mindustry.type.*;\n", "import mindustry.world.*;\n", "import mindustry.world.blocks.environment.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class CrawlComp implements Posc, Rotc, Hitboxc, Unitc {\n", "\n", "    @Import\n", "    float x, y, speedMultiplier, rotation, hitSize;\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    @Import\n", "    Team team;\n", "\n", "    @Import\n", "    Vec2 vel;\n", "\n", "    transient Floor lastDeepFloor;\n", "\n", "    transient float lastCrawlSlowdown = 1f;\n", "\n", "    transient float segmentRot, crawlTime = Mathf.random(100f);\n", "\n", "    @Replace\n", "    @Override\n", "    public SolidPred solidity() {\n", "        return EntityCollisions::legsSolid;\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public int pathType() {\n", "        return Pathfinder.costLegs;\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public float floorSpeedMultiplier() {\n", "        Floor on = isFlying() ? Blocks.air.asFloor() : floorOn();\n", "        // TODO take into account extra blocks\n", "        return (on.isDeep() ? 0.45f : on.speedMultiplier) * speedMultiplier * lastCrawlSlowdown;\n", "    }\n", "\n", "    @Override\n", "    public void add() {\n", "        // reset segment rotation on add\n", "        segmentRot = rotation;\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public Floor drownFloor() {\n", "        return lastDeepFloor;\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        if (moving()) {\n", "            segmentRot = Angles.moveToward(segmentRot, rotation, type.segmentRotSpeed);\n", "            int radius = (int) Math.max(0, hitSize / tilesize * 2f);\n", "            int count = 0, solids = 0, deeps = 0;\n", "            lastDeepFloor = null;\n", "            // calculate tiles under this unit, and apply slowdown + particle effects\n", "            for (int cx = -radius; cx <= radius; cx++) {\n", "                for (int cy = -radius; cy <= radius; cy++) {\n", "                    if (cx * cx + cy * cy <= radius) {\n", "                        count++;\n", "                        Tile t = Vars.world.tileWorld(x + cx * tilesize, y + cy * tilesize);\n", "                        if (t != null) {\n", "                            if (t.solid()) {\n", "                                solids++;\n", "                            }\n", "                            if (t.floor().isDeep()) {\n", "                                deeps++;\n", "                                lastDeepFloor = t.floor();\n", "                            }\n", "                            // TODO area damage to units\n", "                            if (t.build != null && t.build.team != team) {\n", "                                t.build.damage(team, type.crushDamage * Time.delta);\n", "                            }\n", "                            if (Mathf.chanceDelta(0.025)) {\n", "                                Fx.crawlDust.at(t.worldx(), t.worldy(), t.floor().mapColor);\n", "                            }\n", "                        } else {\n", "                            solids++;\n", "                        }\n", "                    }\n", "                }\n", "            }\n", "            // when most blocks under this unit cannot be drowned in, do not drown\n", "            if ((float) deeps / count < 0.75f) {\n", "                lastDeepFloor = null;\n", "            }\n", "            lastCrawlSlowdown = Mathf.lerp(1f, type.crawlSlowdown, Mathf.clamp((float) solids / count / type.crawlSlowdownFrac));\n", "        }\n", "        segmentRot = Angles.clampRange(segmentRot, rotation, type.segmentMaxRot);\n", "        crawlTime += vel.len();\n", "    }\n", "}\n" }));
        compMap.put("DamageComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import mindustry.annotations.Annotations.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class DamageComp {\n", "\n", "    float damage;\n", "}\n" }));
        compMap.put("DecalComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.graphics.*;\n", "import arc.graphics.g2d.*;\n", "import arc.math.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import mindustry.graphics.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { Decalc.class }, pooled = true, serialize = false)\n", "@Component(base = true)\n", "abstract class DecalComp implements Drawc, Timedc, Rotc, Posc {\n", "\n", "    @Import\n", "    float x, y, rotation;\n", "\n", "    Color color = new Color(1, 1, 1, 1);\n", "\n", "    TextureRegion region;\n", "\n", "    @Override\n", "    public void draw() {\n", "        Draw.z(Layer.scorch);\n", "        Draw.mixcol(color, color.a);\n", "        Draw.alpha(1f - Mathf.curve(fin(), 0.98f));\n", "        Draw.rect(region, x, y, rotation);\n", "        Draw.reset();\n", "    }\n", "\n", "    @Replace\n", "    public float clipSize() {\n", "        return region.width * 2;\n", "    }\n", "}\n" }));
        compMap.put("DrawComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class DrawComp implements Posc {\n", "\n", "    float clipSize() {\n", "        return Float.MAX_VALUE;\n", "    }\n", "\n", "    void draw() {\n", "    }\n", "}\n" }));
        compMap.put("EffectStateComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.graphics.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.entities.*;\n", "import mindustry.gen.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { EffectStatec.class, Childc.class }, pooled = true, serialize = false)\n", "@Component(base = true)\n", "abstract class EffectStateComp implements Posc, Drawc, Timedc, Rotc, Childc {\n", "\n", "    @Import\n", "    float time, lifetime, rotation, x, y;\n", "\n", "    @Import\n", "    int id;\n", "\n", "    Color color = new Color(Color.white);\n", "\n", "    Effect effect;\n", "\n", "    Object data;\n", "\n", "    @Override\n", "    public void draw() {\n", "        lifetime = effect.render(id, color, time, lifetime, rotation, x, y, data);\n", "    }\n", "\n", "    @Replace\n", "    public float clipSize() {\n", "        return effect.clip;\n", "    }\n", "}\n" }));
        compMap.put("ElevationMoveComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.entities.*;\n", "import mindustry.entities.EntityCollisions.*;\n", "import mindustry.gen.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class ElevationMoveComp implements Velc, Posc, Flyingc, Hitboxc {\n", "\n", "    @Import\n", "    float x, y;\n", "\n", "    @Replace\n", "    @Override\n", "    public SolidPred solidity() {\n", "        return isFlying() ? null : EntityCollisions::solid;\n", "    }\n", "}\n" }));
        compMap.put("EntityComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.util.io.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.entities.*;\n", "import mindustry.gen.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "@BaseComponent\n", "abstract class EntityComp {\n", "\n", "    private transient boolean added;\n", "\n", "    transient int id = EntityGroup.nextId();\n", "\n", "    boolean isAdded() {\n", "        return added;\n", "    }\n", "\n", "    void update() {\n", "    }\n", "\n", "    void remove() {\n", "        added = false;\n", "    }\n", "\n", "    void add() {\n", "        added = true;\n", "    }\n", "\n", "    boolean isLocal() {\n", "        Unitc u;\n", "        return ((Object) this) == player || (((Object) this) instanceof Unitc && (u = (Unitc) ((Object) this)) == ((Object) this)) && u.controller() == player;\n", "    }\n", "\n", "    boolean isRemote() {\n", "        Unitc u;\n", "        return (((Object) this) instanceof Unitc && (u = (Unitc) ((Object) this)) == ((Object) this)) && u.isPlayer() && !isLocal();\n", "    }\n", "\n", "    boolean isNull() {\n", "        return false;\n", "    }\n", "\n", "    /**\n", "     * Replaced with `this` after code generation.\n", "     */\n", "    <T extends Entityc> T self() {\n", "        return (T) this;\n", "    }\n", "\n", "    <T> T as() {\n", "        return (T) this;\n", "    }\n", "\n", "    @InternalImpl\n", "    abstract int classId();\n", "\n", "    @InternalImpl\n", "    abstract boolean serialize();\n", "\n", "    @MethodPriority(1)\n", "    void read(Reads read) {\n", "        afterRead();\n", "    }\n", "\n", "    void write(Writes write) {\n", "    }\n", "\n", "    void afterRead() {\n", "    }\n", "}\n" }));
        compMap.put("FireComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.*;\n", "import arc.graphics.g2d.*;\n", "import arc.math.*;\n", "import arc.math.geom.*;\n", "import arc.util.*;\n", "import mindustry.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.entities.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import mindustry.graphics.*;\n", "import mindustry.world.*;\n", "import mindustry.world.meta.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { Firec.class }, pooled = true)\n", "@Component(base = true)\n", "abstract class FireComp implements Timedc, Posc, Syncc, Drawc {\n", "\n", "    public static final int frames = 40, duration = 90;\n", "\n", "    private static final float spreadDelay = 22f, fireballDelay = 40f, ticksPerFrame = (float) duration / frames, warmupDuration = 20f, damageDelay = 40f, tileDamage = 1.8f, unitDamage = 3f;\n", "\n", "    public static final TextureRegion[] regions = new TextureRegion[frames];\n", "\n", "    @Import\n", "    float time, lifetime, x, y;\n", "\n", "    Tile tile;\n", "\n", "    private transient Block block;\n", "\n", "    private transient float baseFlammability = -1, puddleFlammability, damageTimer = Mathf.random(40f), spreadTimer = Mathf.random(spreadDelay), fireballTimer = Mathf.random(fireballDelay), warmup = 0f, animation = Mathf.random(frames - 1);\n", "\n", "    @Override\n", "    public void update() {\n", "        animation += Time.delta / ticksPerFrame;\n", "        warmup += Time.delta;\n", "        animation %= frames;\n", "        if (!headless) {\n", "            control.sound.loop(Sounds.fire, this, 0.07f);\n", "        }\n", "        // faster updates -> disappears more quickly\n", "        float speedMultiplier = 1f + Math.max(state.envAttrs.get(Attribute.water) * 10f, 0);\n", "        time = Mathf.clamp(time + Time.delta * speedMultiplier, 0, lifetime);\n", "        if (Vars.net.client()) {\n", "            return;\n", "        }\n", "        if (time >= lifetime || tile == null || Float.isNaN(lifetime)) {\n", "            remove();\n", "            return;\n", "        }\n", "        Building entity = tile.build;\n", "        boolean damage = entity != null;\n", "        if (baseFlammability < 0 || block != tile.block()) {\n", "            baseFlammability = tile.getFlammability();\n", "            block = tile.block();\n", "        }\n", "        float flammability = baseFlammability + puddleFlammability;\n", "        if (!damage && flammability <= 0) {\n", "            time += Time.delta * 8;\n", "        }\n", "        if (damage) {\n", "            lifetime += Mathf.clamp(flammability / 8f, 0f, 0.6f) * Time.delta;\n", "        }\n", "        if (flammability > 1f && (spreadTimer += Time.delta * Mathf.clamp(flammability / 5f, 0.3f, 2f)) >= spreadDelay) {\n", "            spreadTimer = 0f;\n", "            Point2 p = Geometry.d4[Mathf.random(3)];\n", "            Tile other = world.tile(tile.x + p.x, tile.y + p.y);\n", "            Fires.create(other);\n", "        }\n", "        if (flammability > 0 && (fireballTimer += Time.delta * Mathf.clamp(flammability / 10f, 0f, 0.5f)) >= fireballDelay) {\n", "            fireballTimer = 0f;\n", "            Bullets.fireball.createNet(Team.derelict, x, y, Mathf.random(360f), -1f, 1, 1);\n", "        }\n", "        // apply damage to nearby units & building\n", "        if ((damageTimer += Time.delta) >= damageDelay) {\n", "            damageTimer = 0f;\n", "            Puddlec p = Puddles.get(tile);\n", "            puddleFlammability = p != null ? p.getFlammability() / 3f : 0;\n", "            if (damage) {\n", "                entity.damage(tileDamage);\n", "            }\n", "            Damage.damageUnits(null, tile.worldx(), tile.worldy(), tilesize, unitDamage, unit -> !unit.isFlying() && !unit.isImmune(StatusEffects.burning), unit -> unit.apply(StatusEffects.burning, 60 * 5));\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void draw() {\n", "        if (regions[0] == null) {\n", "            for (int i = 0; i < frames; i++) {\n", "                regions[i] = Core.atlas.find(\"fire\" + i);\n", "            }\n", "        }\n", "        Draw.color(1f, 1f, 1f, Mathf.clamp(warmup / warmupDuration));\n", "        Draw.z(Layer.effect);\n", "        Draw.rect(regions[Math.min((int) animation, regions.length - 1)], x + Mathf.randomSeedRange((int) y, 2), y + Mathf.randomSeedRange((int) x, 2));\n", "        Draw.reset();\n", "        Drawf.light(x, y, 50f + Mathf.absin(5f, 5f), Pal.lightFlame, 0.6f * Mathf.clamp(warmup / warmupDuration));\n", "    }\n", "\n", "    @Replace\n", "    @Override\n", "    public float clipSize() {\n", "        return 25;\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "        Fx.fireRemove.at(x, y, animation);\n", "        Fires.remove(tile);\n", "    }\n", "\n", "    @Override\n", "    public void afterRead() {\n", "        Fires.register(self());\n", "    }\n", "\n", "    @Override\n", "    public void afterSync() {\n", "        Fires.register(self());\n", "    }\n", "}\n" }));
        compMap.put("FlyingComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.*;\n", "import arc.math.*;\n", "import arc.math.geom.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.game.EventType.*;\n", "import mindustry.gen.*;\n", "import mindustry.type.*;\n", "import mindustry.world.blocks.environment.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class FlyingComp implements Posc, Velc, Healthc, Hitboxc {\n", "\n", "    private static final Vec2 tmp1 = new Vec2(), tmp2 = new Vec2();\n", "\n", "    @Import\n", "    float x, y, speedMultiplier, hitSize;\n", "\n", "    @Import\n", "    Vec2 vel;\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    @SyncLocal\n", "    float elevation;\n", "\n", "    private transient boolean wasFlying;\n", "\n", "    transient boolean hovering;\n", "\n", "    transient float drownTime;\n", "\n", "    transient float splashTimer;\n", "\n", "    @Nullable\n", "    transient Floor lastDrownFloor;\n", "\n", "    boolean checkTarget(boolean targetAir, boolean targetGround) {\n", "        return (isGrounded() && targetGround) || (isFlying() && targetAir);\n", "    }\n", "\n", "    boolean isGrounded() {\n", "        return elevation < 0.001f;\n", "    }\n", "\n", "    boolean isFlying() {\n", "        return elevation >= 0.09f;\n", "    }\n", "\n", "    boolean canDrown() {\n", "        return isGrounded() && !hovering;\n", "    }\n", "\n", "    @Nullable\n", "    Floor drownFloor() {\n", "        return canDrown() ? floorOn() : null;\n", "    }\n", "\n", "    boolean emitWalkSound() {\n", "        return true;\n", "    }\n", "\n", "    void landed() {\n", "    }\n", "\n", "    void wobble() {\n", "        x += Mathf.sin(Time.time + (id() % 10) * 12, 25f, 0.05f) * Time.delta * elevation;\n", "        y += Mathf.cos(Time.time + (id() % 10) * 12, 25f, 0.05f) * Time.delta * elevation;\n", "    }\n", "\n", "    void moveAt(Vec2 vector, float acceleration) {\n", "        // target vector\n", "        Vec2 t = tmp1.set(vector);\n", "        // delta vector\n", "        tmp2.set(t).sub(vel).limit(acceleration * vector.len() * Time.delta);\n", "        vel.add(tmp2);\n", "    }\n", "\n", "    float floorSpeedMultiplier() {\n", "        Floor on = isFlying() || hovering ? Blocks.air.asFloor() : floorOn();\n", "        return on.speedMultiplier * speedMultiplier;\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        Floor floor = floorOn();\n", "        if (isFlying() != wasFlying) {\n", "            if (wasFlying) {\n", "                if (tileOn() != null) {\n", "                    Fx.unitLand.at(x, y, floorOn().isLiquid ? 1f : 0.5f, tileOn().floor().mapColor);\n", "                }\n", "            }\n", "            wasFlying = isFlying();\n", "        }\n", "        if (!hovering && isGrounded()) {\n", "            if ((splashTimer += Mathf.dst(deltaX(), deltaY())) >= (7f + hitSize() / 8f)) {\n", "                floor.walkEffect.at(x, y, hitSize() / 8f, floor.mapColor);\n", "                splashTimer = 0f;\n", "                if (emitWalkSound()) {\n", "                    floor.walkSound.at(x, y, Mathf.random(floor.walkSoundPitchMin, floor.walkSoundPitchMax), floor.walkSoundVolume);\n", "                }\n", "            }\n", "        }\n", "        updateDrowning();\n", "    }\n", "\n", "    public void updateDrowning() {\n", "        Floor floor = drownFloor();\n", "        if (floor != null && floor.isLiquid && floor.drownTime > 0) {\n", "            lastDrownFloor = floor;\n", "            drownTime += Time.delta / floor.drownTime / type.drownTimeMultiplier;\n", "            if (Mathf.chanceDelta(0.05f)) {\n", "                floor.drownUpdateEffect.at(x, y, hitSize, floor.mapColor);\n", "            }\n", "            if (drownTime >= 0.999f && !net.client()) {\n", "                kill();\n", "                Events.fire(new UnitDrownEvent(self()));\n", "            }\n", "        } else {\n", "            drownTime -= Time.delta / 50f;\n", "        }\n", "        drownTime = Mathf.clamp(drownTime);\n", "    }\n", "}\n" }));
        compMap.put("HealthComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class HealthComp implements Entityc, Posc {\n", "\n", "    static final float hitDuration = 9f;\n", "\n", "    float health;\n", "\n", "    transient float hitTime;\n", "\n", "    transient float maxHealth = 1f;\n", "\n", "    transient boolean dead;\n", "\n", "    boolean isValid() {\n", "        return !dead && isAdded();\n", "    }\n", "\n", "    float healthf() {\n", "        return health / maxHealth;\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        hitTime -= Time.delta / hitDuration;\n", "    }\n", "\n", "    void killed() {\n", "        // implement by other components\n", "    }\n", "\n", "    void kill() {\n", "        if (dead)\n", "            return;\n", "        health = Math.min(health, 0);\n", "        dead = true;\n", "        killed();\n", "        remove();\n", "    }\n", "\n", "    void heal() {\n", "        dead = false;\n", "        health = maxHealth;\n", "    }\n", "\n", "    boolean damaged() {\n", "        return health < maxHealth - 0.001f;\n", "    }\n", "\n", "    /**\n", "     * Damage and pierce armor.\n", "     */\n", "    void damagePierce(float amount, boolean withEffect) {\n", "        damage(amount, withEffect);\n", "    }\n", "\n", "    /**\n", "     * Damage and pierce armor.\n", "     */\n", "    void damagePierce(float amount) {\n", "        damagePierce(amount, true);\n", "    }\n", "\n", "    void damage(float amount) {\n", "        health -= amount;\n", "        hitTime = 1f;\n", "        if (health <= 0 && !dead) {\n", "            kill();\n", "        }\n", "    }\n", "\n", "    void damage(float amount, boolean withEffect) {\n", "        float pre = hitTime;\n", "        damage(amount);\n", "        if (!withEffect) {\n", "            hitTime = pre;\n", "        }\n", "    }\n", "\n", "    void damageContinuous(float amount) {\n", "        damage(amount * Time.delta, hitTime <= -10 + hitDuration);\n", "    }\n", "\n", "    void damageContinuousPierce(float amount) {\n", "        damagePierce(amount * Time.delta, hitTime <= -20 + hitDuration);\n", "    }\n", "\n", "    void clampHealth() {\n", "        health = Math.min(health, maxHealth);\n", "    }\n", "\n", "    /**\n", "     * Heals by a flat amount.\n", "     */\n", "    void heal(float amount) {\n", "        health += amount;\n", "        clampHealth();\n", "    }\n", "\n", "    /**\n", "     * Heals by a 0-1 fraction of max health.\n", "     */\n", "    void healFract(float amount) {\n", "        heal(amount * maxHealth);\n", "    }\n", "}\n" }));
        compMap.put("HitboxComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.func.*;\n", "import arc.math.*;\n", "import arc.math.geom.*;\n", "import arc.math.geom.QuadTree.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.entities.*;\n", "import mindustry.gen.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class HitboxComp implements Posc, Sized, QuadTreeObject {\n", "\n", "    @Import\n", "    float x, y;\n", "\n", "    transient float lastX, lastY, deltaX, deltaY, hitSize;\n", "\n", "    @Override\n", "    public void update() {\n", "    }\n", "\n", "    @Override\n", "    public void add() {\n", "        updateLastPosition();\n", "    }\n", "\n", "    @Override\n", "    public void afterRead() {\n", "        updateLastPosition();\n", "    }\n", "\n", "    @Override\n", "    public float hitSize() {\n", "        return hitSize;\n", "    }\n", "\n", "    void getCollisions(Cons<QuadTree> consumer) {\n", "    }\n", "\n", "    void updateLastPosition() {\n", "        deltaX = x - lastX;\n", "        deltaY = y - lastY;\n", "        lastX = x;\n", "        lastY = y;\n", "    }\n", "\n", "    void collision(Hitboxc other, float x, float y) {\n", "    }\n", "\n", "    float deltaLen() {\n", "        return Mathf.len(deltaX, deltaY);\n", "    }\n", "\n", "    float deltaAngle() {\n", "        return Mathf.angle(deltaX, deltaY);\n", "    }\n", "\n", "    boolean collides(Hitboxc other) {\n", "        return true;\n", "    }\n", "\n", "    @Override\n", "    public void hitbox(Rect rect) {\n", "        rect.setCentered(x, y, hitSize, hitSize);\n", "    }\n", "\n", "    public void hitboxTile(Rect rect) {\n", "        // tile hitboxes are never bigger than a tile, otherwise units get stuck\n", "        float size = Math.min(hitSize * 0.66f, 7.9f);\n", "        // TODO: better / more accurate version is\n", "        // float size = hitSize * 0.85f;\n", "        // - for tanks?\n", "        rect.setCentered(x, y, size, size);\n", "    }\n", "}\n" }));
        compMap.put("ItemsComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.math.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import mindustry.type.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class ItemsComp implements Posc {\n", "\n", "    ItemStack stack = new ItemStack();\n", "\n", "    transient float itemTime;\n", "\n", "    abstract int itemCapacity();\n", "\n", "    @Override\n", "    public void update() {\n", "        stack.amount = Mathf.clamp(stack.amount, 0, itemCapacity());\n", "        itemTime = Mathf.lerpDelta(itemTime, Mathf.num(hasItem()), 0.05f);\n", "    }\n", "\n", "    Item item() {\n", "        return stack.item;\n", "    }\n", "\n", "    void clearItem() {\n", "        stack.amount = 0;\n", "    }\n", "\n", "    boolean acceptsItem(Item item) {\n", "        return !hasItem() || item == stack.item && stack.amount + 1 <= itemCapacity();\n", "    }\n", "\n", "    boolean hasItem() {\n", "        return stack.amount > 0;\n", "    }\n", "\n", "    void addItem(Item item) {\n", "        addItem(item, 1);\n", "    }\n", "\n", "    void addItem(Item item, int amount) {\n", "        stack.amount = stack.item == item ? stack.amount + amount : amount;\n", "        stack.item = item;\n", "        stack.amount = Mathf.clamp(stack.amount, 0, itemCapacity());\n", "    }\n", "\n", "    int maxAccepted(Item item) {\n", "        return stack.item != item && stack.amount > 0 ? 0 : itemCapacity() - stack.amount;\n", "    }\n", "}\n" }));
        compMap.put("LaunchCoreComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.graphics.g2d.*;\n", "import arc.math.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.gen.*;\n", "import mindustry.graphics.*;\n", "import mindustry.world.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = LaunchCorec.class, serialize = false)\n", "@Component\n", "abstract class LaunchCoreComp implements Drawc, Timedc {\n", "\n", "    @Import\n", "    float x, y;\n", "\n", "    transient Interval in = new Interval();\n", "\n", "    Block block;\n", "\n", "    @Override\n", "    public void draw() {\n", "        float alpha = fout(Interp.pow5Out);\n", "        float scale = (1f - alpha) * 1.4f + 1f;\n", "        float cx = cx(), cy = cy();\n", "        float rotation = fin() * (140f + Mathf.randomSeedRange(id(), 50f));\n", "        Draw.z(Layer.effect + 0.001f);\n", "        Draw.color(Pal.engine);\n", "        float rad = 0.2f + fslope();\n", "        float rscl = (block.size - 1) * 0.85f;\n", "        Fill.light(cx, cy, 10, 25f * (rad + scale - 1f) * rscl, Tmp.c2.set(Pal.engine).a(alpha), Tmp.c1.set(Pal.engine).a(0f));\n", "        Draw.alpha(alpha);\n", "        for (int i = 0; i < 4; i++) {\n", "            Drawf.tri(cx, cy, 6f * rscl, 40f * (rad + scale - 1f) * rscl, i * 90f + rotation);\n", "        }\n", "        Draw.color();\n", "        Draw.z(Layer.weather - 1);\n", "        TextureRegion region = block.fullIcon;\n", "        float rw = region.width * Draw.scl * scale, rh = region.height * Draw.scl * scale;\n", "        Draw.alpha(alpha);\n", "        Draw.rect(region, cx, cy, rw, rh, rotation - 45);\n", "        Tmp.v1.trns(225f, fin(Interp.pow3In) * 250f);\n", "        Draw.z(Layer.flyingUnit + 1);\n", "        Draw.color(0, 0, 0, 0.22f * alpha);\n", "        Draw.rect(region, cx + Tmp.v1.x, cy + Tmp.v1.y, rw, rh, rotation - 45);\n", "        Draw.reset();\n", "    }\n", "\n", "    float cx() {\n", "        return x + fin(Interp.pow2In) * (12f + Mathf.randomSeedRange(id() + 3, 4f));\n", "    }\n", "\n", "    float cy() {\n", "        return y + fin(Interp.pow5In) * (100f + Mathf.randomSeedRange(id() + 2, 30f));\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        float r = 4f;\n", "        if (in.get(3f - fin() * 2f)) {\n", "            Fx.rocketSmokeLarge.at(cx() + Mathf.range(r), cy() + Mathf.range(r), fin());\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("LegsComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.math.*;\n", "import arc.math.geom.*;\n", "import arc.util.*;\n", "import mindustry.*;\n", "import mindustry.ai.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.entities.*;\n", "import mindustry.entities.EntityCollisions.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import mindustry.graphics.*;\n", "import mindustry.type.*;\n", "import mindustry.world.blocks.environment.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class LegsComp implements Posc, Rotc, Hitboxc, Flyingc, Unitc {\n", "\n", "    private static final Vec2 straightVec = new Vec2();\n", "\n", "    @Import\n", "    float x, y, rotation, speedMultiplier;\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    @Import\n", "    Team team;\n", "\n", "    transient Leg[] legs = {};\n", "\n", "    transient float totalLength;\n", "\n", "    transient float moveSpace;\n", "\n", "    transient float baseRotation;\n", "\n", "    transient Floor lastDeepFloor;\n", "\n", "    transient Vec2 curMoveOffset = new Vec2();\n", "\n", "    @Replace\n", "    @Override\n", "    public SolidPred solidity() {\n", "        return type.allowLegStep ? EntityCollisions::legsSolid : EntityCollisions::solid;\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public int pathType() {\n", "        return type.allowLegStep ? Pathfinder.costLegs : Pathfinder.costGround;\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public Floor drownFloor() {\n", "        return lastDeepFloor;\n", "    }\n", "\n", "    @Override\n", "    public void add() {\n", "        resetLegs();\n", "    }\n", "\n", "    @Override\n", "    public void unloaded() {\n", "        resetLegs(1f);\n", "    }\n", "\n", "    @MethodPriority(-1)\n", "    @Override\n", "    public void destroy() {\n", "        if (!isAdded() || Vars.headless)\n", "            return;\n", "        float legExplodeRad = type.legRegion.height / 4f / 1.45f;\n", "        // create effects for legs being destroyed\n", "        for (int i = 0; i < legs.length; i++) {\n", "            Leg l = legs[i];\n", "            Vec2 base = legOffset(Tmp.v1, i).add(x, y);\n", "            Tmp.v2.set(l.base).sub(l.joint).inv().setLength(type.legExtension);\n", "            for (Vec2 vec : new Vec2[] { base, l.joint, l.base }) {\n", "                Damage.dynamicExplosion(vec.x, vec.y, 0f, 0f, 0f, legExplodeRad, state.rules.damageExplosions, false, team, type.deathExplosionEffect);\n", "            }\n", "            Fx.legDestroy.at(base.x, base.y, 0f, new LegDestroyData(base.cpy(), l.joint, type.legRegion));\n", "            Fx.legDestroy.at(l.joint.x, l.joint.y, 0f, new LegDestroyData(l.joint.cpy().add(Tmp.v2), l.base, type.legBaseRegion));\n", "        }\n", "    }\n", "\n", "    public void resetLegs() {\n", "        resetLegs(type.legLength);\n", "    }\n", "\n", "    public void resetLegs(float legLength) {\n", "        int count = type.legCount;\n", "        this.legs = new Leg[count];\n", "        if (type.lockLegBase) {\n", "            baseRotation = rotation;\n", "        }\n", "        for (int i = 0; i < legs.length; i++) {\n", "            Leg l = new Leg();\n", "            float dstRot = legAngle(i);\n", "            Vec2 baseOffset = legOffset(Tmp.v5, i).add(x, y);\n", "            l.joint.trns(dstRot, legLength / 2f).add(baseOffset);\n", "            l.base.trns(dstRot, legLength).add(baseOffset);\n", "            legs[i] = l;\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        if (Mathf.dst(deltaX(), deltaY()) > 0.001f) {\n", "            baseRotation = Angles.moveToward(baseRotation, Mathf.angle(deltaX(), deltaY()), type.rotateSpeed);\n", "        }\n", "        if (type.lockLegBase) {\n", "            baseRotation = rotation;\n", "        }\n", "        float legLength = type.legLength;\n", "        // set up initial leg positions\n", "        if (legs.length != type.legCount) {\n", "            resetLegs();\n", "        }\n", "        float moveSpeed = type.legSpeed;\n", "        int div = Math.max(legs.length / type.legGroupSize, 2);\n", "        moveSpace = legLength / 1.6f / (div / 2f) * type.legMoveSpace;\n", "        // TODO should move legs even when still, based on speed. also, to prevent \"slipping\", make sure legs move when they are too far from their destination\n", "        totalLength += type.legContinuousMove ? type.speed * speedMultiplier * Time.delta : Mathf.dst(deltaX(), deltaY());\n", "        float trns = moveSpace * 0.85f * type.legForwardScl;\n", "        // rotation + offset vector\n", "        boolean moving = moving();\n", "        Vec2 moveOffset = !moving ? Tmp.v4.setZero() : Tmp.v4.trns(Angles.angle(deltaX(), deltaY()), trns);\n", "        // make it smooth, not jumpy\n", "        moveOffset = curMoveOffset.lerpDelta(moveOffset, 0.1f);\n", "        lastDeepFloor = null;\n", "        int deeps = 0;\n", "        for (int i = 0; i < legs.length; i++) {\n", "            float dstRot = legAngle(i);\n", "            Vec2 baseOffset = legOffset(Tmp.v5, i).add(x, y);\n", "            Leg l = legs[i];\n", "            // TODO is limiting twice necessary?\n", "            l.joint.sub(baseOffset).clampLength(type.legMinLength * legLength / 2f, type.legMaxLength * legLength / 2f).add(baseOffset);\n", "            l.base.sub(baseOffset).clampLength(type.legMinLength * legLength, type.legMaxLength * legLength).add(baseOffset);\n", "            float stageF = (totalLength + i * type.legPairOffset) / moveSpace;\n", "            int stage = (int) stageF;\n", "            int group = stage % div;\n", "            boolean move = i % div == group;\n", "            boolean side = i < legs.length / 2;\n", "            // back legs have reversed directions\n", "            boolean backLeg = Math.abs((i + 0.5f) - legs.length / 2f) <= 0.501f;\n", "            if (backLeg && type.flipBackLegs)\n", "                side = !side;\n", "            if (type.flipLegSide)\n", "                side = !side;\n", "            l.moving = move;\n", "            l.stage = moving ? stageF % 1f : Mathf.lerpDelta(l.stage, 0f, 0.1f);\n", "            Floor floor = Vars.world.floorWorld(l.base.x, l.base.y);\n", "            if (floor.isDeep()) {\n", "                deeps++;\n", "                lastDeepFloor = floor;\n", "            }\n", "            if (l.group != group) {\n", "                // create effect when transitioning to a group it can't move in\n", "                if (!move && (moving || !type.legContinuousMove) && i % div == l.group) {\n", "                    if (!headless && !inFogTo(player.team())) {\n", "                        if (floor.isLiquid) {\n", "                            floor.walkEffect.at(l.base.x, l.base.y, type.rippleScale, floor.mapColor);\n", "                            floor.walkSound.at(x, y, 1f, floor.walkSoundVolume);\n", "                        } else {\n", "                            Fx.unitLandSmall.at(l.base.x, l.base.y, type.rippleScale, floor.mapColor);\n", "                        }\n", "                        // shake when legs contact ground\n", "                        if (type.stepShake > 0) {\n", "                            Effect.shake(type.stepShake, type.stepShake, l.base);\n", "                        }\n", "                    }\n", "                    if (type.legSplashDamage > 0) {\n", "                        Damage.damage(team, l.base.x, l.base.y, type.legSplashRange, type.legSplashDamage, false, true);\n", "                    }\n", "                }\n", "                l.group = group;\n", "            }\n", "            // leg destination\n", "            Vec2 legDest = Tmp.v1.trns(dstRot, legLength * type.legLengthScl).add(baseOffset).add(moveOffset);\n", "            // join destination\n", "            Vec2 jointDest = Tmp.v2;\n", "            InverseKinematics.solve(legLength / 2f, legLength / 2f, Tmp.v6.set(l.base).sub(baseOffset), side, jointDest);\n", "            jointDest.add(baseOffset);\n", "            Tmp.v6.set(baseOffset).lerp(l.base, 0.5f);\n", "            if (move) {\n", "                float moveFract = stageF % 1f;\n", "                l.base.lerpDelta(legDest, moveFract);\n", "                l.joint.lerpDelta(jointDest, moveFract / 2f);\n", "            }\n", "            l.joint.lerpDelta(jointDest, moveSpeed / 4f);\n", "            // limit again after updating\n", "            l.joint.sub(baseOffset).clampLength(type.legMinLength * legLength / 2f, type.legMaxLength * legLength / 2f).add(baseOffset);\n", "            l.base.sub(baseOffset).clampLength(type.legMinLength * legLength, type.legMaxLength * legLength).add(baseOffset);\n", "        }\n", "        // when at least 1 leg is touching land, it can't drown\n", "        if (deeps != legs.length || !floorOn().isDeep()) {\n", "            lastDeepFloor = null;\n", "        }\n", "    }\n", "\n", "    Vec2 legOffset(Vec2 out, int index) {\n", "        out.trns(defaultLegAngle(index), type.legBaseOffset);\n", "        if (type.legStraightness > 0) {\n", "            straightVec.trns(defaultLegAngle(index) - baseRotation, type.legBaseOffset);\n", "            straightVec.y = Mathf.sign(straightVec.y) * type.legBaseOffset * type.legStraightLength;\n", "            straightVec.rotate(baseRotation);\n", "            out.lerp(straightVec, type.baseLegStraightness);\n", "        }\n", "        return out;\n", "    }\n", "\n", "    /**\n", "     * @return outwards facing angle of leg at the specified index.\n", "     */\n", "    float legAngle(int index) {\n", "        if (type.legStraightness > 0) {\n", "            return Mathf.slerp(defaultLegAngle(index), (index >= legs.length / 2 ? -90 : 90f) + baseRotation, type.legStraightness);\n", "        }\n", "        return defaultLegAngle(index);\n", "    }\n", "\n", "    float defaultLegAngle(int index) {\n", "        return baseRotation + 360f / legs.length * index + (360f / legs.length / 2f);\n", "    }\n", "}\n" }));
        compMap.put("MechComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.math.*;\n", "import arc.math.geom.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.entities.*;\n", "import mindustry.gen.*;\n", "import mindustry.type.*;\n", "import mindustry.world.blocks.environment.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class MechComp implements Posc, Flyingc, Hitboxc, Unitc, Mechc, ElevationMovec {\n", "\n", "    @Import\n", "    float x, y, hitSize;\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    @SyncField(false)\n", "    @SyncLocal\n", "    float baseRotation;\n", "\n", "    transient float walkTime, walkExtension;\n", "\n", "    transient private boolean walked;\n", "\n", "    @Override\n", "    public void update() {\n", "        // trigger animation only when walking manually\n", "        if (walked || net.client()) {\n", "            float len = deltaLen();\n", "            baseRotation = Angles.moveToward(baseRotation, deltaAngle(), type().baseRotateSpeed * Mathf.clamp(len / type().speed / Time.delta) * Time.delta);\n", "            walkTime += len;\n", "            walked = false;\n", "        }\n", "        // update mech effects\n", "        float extend = walkExtend(false);\n", "        float base = walkExtend(true);\n", "        float extendScl = base % 1f;\n", "        float lastExtend = walkExtension;\n", "        if (!headless && extendScl < lastExtend && base % 2f > 1f && !isFlying() && !inFogTo(player.team())) {\n", "            int side = -Mathf.sign(extend);\n", "            float width = hitSize / 2f * side, length = type.mechStride * 1.35f;\n", "            float cx = x + Angles.trnsx(baseRotation, length, width), cy = y + Angles.trnsy(baseRotation, length, width);\n", "            if (type.stepShake > 0) {\n", "                Effect.shake(type.stepShake, type.stepShake, cx, cy);\n", "            }\n", "            if (type.mechStepParticles) {\n", "                Effect.floorDust(cx, cy, hitSize / 8f);\n", "            }\n", "        }\n", "        walkExtension = extendScl;\n", "    }\n", "\n", "    @Replace\n", "    @Override\n", "    @Nullable\n", "    public Floor drownFloor() {\n", "        // large mechs can only drown when all the nearby floors are deep\n", "        if (hitSize >= 12 && canDrown()) {\n", "            for (Point2 p : Geometry.d8) {\n", "                Floor f = world.floorWorld(x + p.x * tilesize, y + p.y * tilesize);\n", "                if (!f.isDeep()) {\n", "                    return null;\n", "                }\n", "            }\n", "        }\n", "        return canDrown() ? floorOn() : null;\n", "    }\n", "\n", "    public float walkExtend(boolean scaled) {\n", "        // now ranges from -maxExtension to maxExtension*3\n", "        float raw = walkTime % (type.mechStride * 4);\n", "        if (scaled)\n", "            return raw / type.mechStride;\n", "        if (raw > type.mechStride * 3)\n", "            raw = raw - type.mechStride * 4;\n", "        else if (raw > type.mechStride * 2)\n", "            raw = type.mechStride * 2 - raw;\n", "        else if (raw > type.mechStride)\n", "            raw = type.mechStride * 2 - raw;\n", "        return raw;\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public void rotateMove(Vec2 vec) {\n", "        // mechs use baseRotation to rotate, not rotation.\n", "        moveAt(Tmp.v2.trns(baseRotation, vec.len()));\n", "        if (!vec.isZero()) {\n", "            baseRotation = Angles.moveToward(baseRotation, vec.angle(), type.rotateSpeed * Math.max(Time.delta, 1));\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void moveAt(Vec2 vector, float acceleration) {\n", "        // mark walking state when moving in a controlled manner\n", "        if (!vector.isZero()) {\n", "            walked = true;\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void approach(Vec2 vector) {\n", "        // mark walking state when moving in a controlled manner\n", "        if (!vector.isZero(0.001f)) {\n", "            walked = true;\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("MinerComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.*;\n", "import arc.graphics.*;\n", "import arc.graphics.g2d.*;\n", "import arc.math.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.gen.*;\n", "import mindustry.graphics.*;\n", "import mindustry.input.*;\n", "import mindustry.type.*;\n", "import mindustry.world.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class MinerComp implements Itemsc, Posc, Teamc, Rotc, Drawc {\n", "\n", "    @Import\n", "    float x, y, rotation, hitSize;\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    transient float mineTimer;\n", "\n", "    @Nullable\n", "    @SyncLocal\n", "    Tile mineTile;\n", "\n", "    public boolean canMine(@Nullable Item item) {\n", "        if (item == null)\n", "            return false;\n", "        return type.mineTier >= item.hardness;\n", "    }\n", "\n", "    public boolean offloadImmediately() {\n", "        return this.<Unit>self().isPlayer();\n", "    }\n", "\n", "    boolean mining() {\n", "        return mineTile != null && !this.<Unit>self().activelyBuilding();\n", "    }\n", "\n", "    @Nullable\n", "    public Item getMineResult(@Nullable Tile tile) {\n", "        if (tile == null)\n", "            return null;\n", "        Item result;\n", "        if (type.mineFloor && tile.block() == Blocks.air) {\n", "            result = tile.drop();\n", "        } else if (type.mineWalls) {\n", "            result = tile.wallDrop();\n", "        } else {\n", "            return null;\n", "        }\n", "        return canMine(result) ? result : null;\n", "    }\n", "\n", "    public boolean validMine(Tile tile, boolean checkDst) {\n", "        if (tile == null)\n", "            return false;\n", "        if (checkDst && !within(tile.worldx(), tile.worldy(), type.mineRange)) {\n", "            return false;\n", "        }\n", "        return getMineResult(tile) != null;\n", "    }\n", "\n", "    public boolean validMine(Tile tile) {\n", "        return validMine(tile, true);\n", "    }\n", "\n", "    public boolean canMine() {\n", "        return type.mineSpeed > 0 && type.mineTier >= 0;\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        if (mineTile == null)\n", "            return;\n", "        Building core = closestCore();\n", "        Item item = getMineResult(mineTile);\n", "        if (core != null && item != null && !acceptsItem(item) && within(core, mineTransferRange) && !offloadImmediately()) {\n", "            int accepted = core.acceptStack(item(), stack().amount, this);\n", "            if (accepted > 0) {\n", "                Call.transferItemTo(self(), item(), accepted, mineTile.worldx() + Mathf.range(tilesize / 2f), mineTile.worldy() + Mathf.range(tilesize / 2f), core);\n", "                clearItem();\n", "            }\n", "        }\n", "        if ((!net.client() || isLocal()) && !validMine(mineTile)) {\n", "            mineTile = null;\n", "            mineTimer = 0f;\n", "        } else if (mining() && item != null) {\n", "            mineTimer += Time.delta * type.mineSpeed;\n", "            if (Mathf.chance(0.06 * Time.delta)) {\n", "                Fx.pulverizeSmall.at(mineTile.worldx() + Mathf.range(tilesize / 2f), mineTile.worldy() + Mathf.range(tilesize / 2f), 0f, item.color);\n", "            }\n", "            if (mineTimer >= 50f + (type.mineHardnessScaling ? item.hardness * 15f : 15f)) {\n", "                mineTimer = 0;\n", "                if (state.rules.sector != null && team() == state.rules.defaultTeam)\n", "                    state.rules.sector.info.handleProduction(item, 1);\n", "                if (core != null && within(core, mineTransferRange) && core.acceptStack(item, 1, this) == 1 && offloadImmediately()) {\n", "                    // add item to inventory before it is transferred\n", "                    if (item() == item && !net.client())\n", "                        addItem(item);\n", "                    Call.transferItemTo(self(), item, 1, mineTile.worldx() + Mathf.range(tilesize / 2f), mineTile.worldy() + Mathf.range(tilesize / 2f), core);\n", "                } else if (acceptsItem(item)) {\n", "                    // this is clientside, since items are synced anyway\n", "                    InputHandler.transferItemToUnit(item, mineTile.worldx() + Mathf.range(tilesize / 2f), mineTile.worldy() + Mathf.range(tilesize / 2f), this);\n", "                } else {\n", "                    mineTile = null;\n", "                    mineTimer = 0f;\n", "                }\n", "            }\n", "            if (!headless) {\n", "                control.sound.loop(type.mineSound, this, type.mineSoundVolume);\n", "            }\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void draw() {\n", "        if (!mining())\n", "            return;\n", "        float focusLen = hitSize / 2f + Mathf.absin(Time.time, 1.1f, 0.5f);\n", "        float swingScl = 12f, swingMag = tilesize / 8f;\n", "        float flashScl = 0.3f;\n", "        float px = x + Angles.trnsx(rotation, focusLen);\n", "        float py = y + Angles.trnsy(rotation, focusLen);\n", "        float ex = mineTile.worldx() + Mathf.sin(Time.time + 48, swingScl, swingMag);\n", "        float ey = mineTile.worldy() + Mathf.sin(Time.time + 48, swingScl + 2f, swingMag);\n", "        Draw.z(Layer.flyingUnit + 0.1f);\n", "        Draw.color(Color.lightGray, Color.white, 1f - flashScl + Mathf.absin(Time.time, 0.5f, flashScl));\n", "        Drawf.laser(Core.atlas.find(\"minelaser\"), Core.atlas.find(\"minelaser-end\"), px, py, ex, ey, 0.75f);\n", "        if (isLocal()) {\n", "            Lines.stroke(1f, Pal.accent);\n", "            Lines.poly(mineTile.worldx(), mineTile.worldy(), 4, tilesize / 2f * Mathf.sqrt2, Time.time);\n", "        }\n", "        Draw.color();\n", "    }\n", "}\n" }));
        compMap.put("OwnerComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "class OwnerComp {\n", "\n", "    Entityc owner;\n", "}\n" }));
        compMap.put("PayloadComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.*;\n", "import arc.math.*;\n", "import arc.scene.ui.layout.*;\n", "import arc.struct.*;\n", "import arc.util.*;\n", "import mindustry.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.core.*;\n", "import mindustry.entities.*;\n", "import mindustry.game.EventType.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import mindustry.type.*;\n", "import mindustry.world.*;\n", "import mindustry.world.blocks.payloads.*;\n", "import mindustry.world.blocks.power.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "/**\n", " * An entity that holds a payload.\n", " */\n", "@Component\n", "abstract class PayloadComp implements Posc, Rotc, Hitboxc, Unitc {\n", "\n", "    @Import\n", "    float x, y, rotation;\n", "\n", "    @Import\n", "    Team team;\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    Seq<Payload> payloads = new Seq<>();\n", "\n", "    @Nullable\n", "    private transient PowerGraph payloadPower;\n", "\n", "    @Override\n", "    public void update() {\n", "        if (payloadPower != null) {\n", "            payloadPower.clear();\n", "        }\n", "        // update power graph first, resolve everything\n", "        for (Payload pay : payloads) {\n", "            if (pay instanceof BuildPayload pb && pb.build.power != null) {\n", "                if (payloadPower == null)\n", "                    payloadPower = new PowerGraph();\n", "                // pb.build.team = team;\n", "                pb.build.power.graph = null;\n", "                payloadPower.add(pb.build);\n", "            }\n", "        }\n", "        if (payloadPower != null) {\n", "            payloadPower.update();\n", "        }\n", "        for (Payload pay : payloads) {\n", "            // apparently BasedUser doesn't want this and several plugins use it\n", "            // if(pay instanceof BuildPayload build){\n", "            // build.build.team = team;\n", "            // }\n", "            pay.set(x, y, rotation);\n", "            pay.update(self(), null);\n", "        }\n", "    }\n", "\n", "    float payloadUsed() {\n", "        return payloads.sumf(p -> p.size() * p.size());\n", "    }\n", "\n", "    boolean canPickup(Unit unit) {\n", "        return type.pickupUnits && payloadUsed() + unit.hitSize * unit.hitSize <= type.payloadCapacity + 0.001f && unit.team == team() && unit.isAI();\n", "    }\n", "\n", "    boolean canPickup(Building build) {\n", "        return payloadUsed() + build.block.size * build.block.size * Vars.tilesize * Vars.tilesize <= type.payloadCapacity + 0.001f && build.canPickup();\n", "    }\n", "\n", "    boolean canPickupPayload(Payload pay) {\n", "        return payloadUsed() + pay.size() * pay.size() <= type.payloadCapacity + 0.001f && (type.pickupUnits || !(pay instanceof UnitPayload));\n", "    }\n", "\n", "    boolean hasPayload() {\n", "        return payloads.size > 0;\n", "    }\n", "\n", "    void addPayload(Payload load) {\n", "        payloads.add(load);\n", "    }\n", "\n", "    void pickup(Unit unit) {\n", "        unit.remove();\n", "        addPayload(new UnitPayload(unit));\n", "        Fx.unitPickup.at(unit);\n", "        if (Vars.net.client()) {\n", "            Vars.netClient.clearRemovedEntity(unit.id);\n", "        }\n", "        Events.fire(new PickupEvent(self(), unit));\n", "    }\n", "\n", "    void pickup(Building tile) {\n", "        tile.pickedUp();\n", "        tile.tile.remove();\n", "        tile.afterPickedUp();\n", "        addPayload(new BuildPayload(tile));\n", "        Fx.unitPickup.at(tile);\n", "        Events.fire(new PickupEvent(self(), tile));\n", "    }\n", "\n", "    boolean dropLastPayload() {\n", "        if (payloads.isEmpty())\n", "            return false;\n", "        Payload load = payloads.peek();\n", "        if (tryDropPayload(load)) {\n", "            payloads.pop();\n", "            return true;\n", "        }\n", "        return false;\n", "    }\n", "\n", "    boolean tryDropPayload(Payload payload) {\n", "        Tile on = tileOn();\n", "        UnitPayload u;\n", "        // clear removed state of unit so it can be synced\n", "        if (Vars.net.client() && (payload instanceof UnitPayload && (u = (UnitPayload) payload) == payload)) {\n", "            Vars.netClient.clearRemovedEntity(u.unit.id);\n", "        }\n", "        // drop off payload on an acceptor if possible\n", "        if (on != null && on.build != null && on.build.acceptPayload(on.build, payload)) {\n", "            Fx.unitDrop.at(on.build);\n", "            on.build.handlePayload(on.build, payload);\n", "            return true;\n", "        }\n", "        BuildPayload b;\n", "        UnitPayload p;\n", "        if ((payload instanceof BuildPayload && (b = (BuildPayload) payload) == payload)) {\n", "            return dropBlock(b);\n", "        } else if ((payload instanceof UnitPayload && (p = (UnitPayload) payload) == payload)) {\n", "            return dropUnit(p);\n", "        }\n", "        return false;\n", "    }\n", "\n", "    boolean dropUnit(UnitPayload payload) {\n", "        Unit u = payload.unit;\n", "        // can't drop ground units\n", "        if (!u.canPass(tileX(), tileY()) || Units.count(x, y, u.physicSize(), o -> o.isGrounded()) > 1) {\n", "            return false;\n", "        }\n", "        Fx.unitDrop.at(this);\n", "        // clients do not drop payloads\n", "        if (Vars.net.client())\n", "            return true;\n", "        u.set(this);\n", "        u.trns(Tmp.v1.rnd(Mathf.random(2f)));\n", "        u.rotation(rotation);\n", "        // reset the ID to a new value to make sure it's synced\n", "        u.id = EntityGroup.nextId();\n", "        // decrement count to prevent double increment\n", "        if (!u.isAdded())\n", "            u.team.data().updateCount(u.type, -1);\n", "        u.add();\n", "        u.unloaded();\n", "        Events.fire(new PayloadDropEvent(self(), u));\n", "        return true;\n", "    }\n", "\n", "    /**\n", "     * @return whether the tile has been successfully placed.\n", "     */\n", "    boolean dropBlock(BuildPayload payload) {\n", "        Building tile = payload.build;\n", "        int tx = World.toTile(x - tile.block.offset), ty = World.toTile(y - tile.block.offset);\n", "        Tile on = Vars.world.tile(tx, ty);\n", "        if (on != null && Build.validPlace(tile.block, tile.team, tx, ty, tile.rotation, false)) {\n", "            int rot = (int) ((rotation + 45f) / 90f) % 4;\n", "            payload.place(on, rot);\n", "            Events.fire(new PayloadDropEvent(self(), tile));\n", "            if (getControllerName() != null) {\n", "                payload.build.lastAccessed = getControllerName();\n", "            }\n", "            Fx.unitDrop.at(tile);\n", "            Fx.placeBlock.at(on.drawx(), on.drawy(), on.block().size);\n", "            return true;\n", "        }\n", "        return false;\n", "    }\n", "\n", "    void contentInfo(Table table, float itemSize, float width) {\n", "        table.clear();\n", "        table.top().left();\n", "        float pad = 0;\n", "        float items = payloads.size;\n", "        if (itemSize * items + pad * items > width) {\n", "            pad = (width - (itemSize) * items) / items;\n", "        }\n", "        for (Payload p : payloads) {\n", "            table.image(p.icon()).size(itemSize).padRight(pad);\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("PhysicsComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.math.*;\n", "import arc.math.geom.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.async.PhysicsProcess.*;\n", "import mindustry.gen.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "/**\n", " * Affected by physics.\n", " * Will bounce off of other objects that are at similar elevations.\n", " * Has mass.\n", " */\n", "@Component\n", "abstract class PhysicsComp implements Velc, Hitboxc, Flyingc {\n", "\n", "    @Import\n", "    float hitSize, x, y;\n", "\n", "    @Import\n", "    Vec2 vel;\n", "\n", "    transient PhysicRef physref;\n", "\n", "    // mass is simply the area of this object\n", "    float mass() {\n", "        return hitSize * hitSize * Mathf.pi;\n", "    }\n", "\n", "    void impulse(float x, float y) {\n", "        float mass = mass();\n", "        vel.add(x / mass, y / mass);\n", "    }\n", "\n", "    void impulse(Vec2 v) {\n", "        impulse(v.x, v.y);\n", "    }\n", "\n", "    void impulseNet(Vec2 v) {\n", "        impulse(v.x, v.y);\n", "        // manually move units to simulate velocity for remote players\n", "        if (isRemote()) {\n", "            float mass = mass();\n", "            move(v.x / mass, v.y / mass);\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("PlayerComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.*;\n", "import arc.graphics.*;\n", "import arc.graphics.g2d.*;\n", "import arc.math.*;\n", "import arc.scene.ui.layout.*;\n", "import arc.util.*;\n", "import arc.util.pooling.*;\n", "import mindustry.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.entities.units.*;\n", "import mindustry.game.EventType.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import mindustry.graphics.*;\n", "import mindustry.net.Administration.*;\n", "import mindustry.net.*;\n", "import mindustry.net.Packets.*;\n", "import mindustry.ui.*;\n", "import mindustry.world.blocks.storage.*;\n", "import mindustry.world.blocks.storage.CoreBlock.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { Playerc.class }, serialize = false)\n", "@Component(base = true)\n", "abstract class PlayerComp implements UnitController, Entityc, Syncc, Timerc, Drawc {\n", "\n", "    static final float deathDelay = 60f;\n", "\n", "    @Import\n", "    float x, y;\n", "\n", "    @ReadOnly\n", "    Unit unit = Nulls.unit;\n", "\n", "    @Nullable\n", "    transient NetConnection con;\n", "\n", "    @ReadOnly\n", "    Team team = Team.sharded;\n", "\n", "    @SyncLocal\n", "    boolean typing, shooting, boosting;\n", "\n", "    @SyncLocal\n", "    float mouseX, mouseY;\n", "\n", "    boolean admin;\n", "\n", "    String name = \"frog\";\n", "\n", "    Color color = new Color();\n", "\n", "    transient String locale = \"en\";\n", "\n", "    transient float deathTimer;\n", "\n", "    transient String lastText = \"\";\n", "\n", "    transient float textFadeTime;\n", "\n", "    transient private Unit lastReadUnit = Nulls.unit;\n", "\n", "    transient private int wrongReadUnits;\n", "\n", "    @Nullable\n", "    transient Unit justSwitchFrom, justSwitchTo;\n", "\n", "    public boolean isBuilder() {\n", "        return unit.canBuild();\n", "    }\n", "\n", "    @Nullable\n", "    public CoreBuild closestCore() {\n", "        return state.teams.closestCore(x, y, team);\n", "    }\n", "\n", "    @Nullable\n", "    public CoreBuild core() {\n", "        return team.core();\n", "    }\n", "\n", "    /**\n", "     * @return largest/closest core, with largest cores getting priority\n", "     */\n", "    @Nullable\n", "    public CoreBuild bestCore() {\n", "        return team.cores().min(Structs.comps(Structs.comparingInt(c -> -c.block.size), Structs.comparingFloat(c -> c.dst(x, y))));\n", "    }\n", "\n", "    public TextureRegion icon() {\n", "        // display default icon for dead players\n", "        if (dead())\n", "            return core() == null ? UnitTypes.alpha.fullIcon : ((CoreBlock) bestCore().block).unitType.fullIcon;\n", "        return unit.icon();\n", "    }\n", "\n", "    public boolean displayAmmo() {\n", "        return unit instanceof BlockUnitc || state.rules.unitAmmo;\n", "    }\n", "\n", "    public void reset() {\n", "        team = state.rules.defaultTeam;\n", "        admin = typing = false;\n", "        textFadeTime = 0f;\n", "        x = y = 0f;\n", "        if (!dead()) {\n", "            unit.resetController();\n", "            unit = Nulls.unit;\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public boolean isValidController() {\n", "        return isAdded();\n", "    }\n", "\n", "    @Replace\n", "    public float clipSize() {\n", "        return unit.isNull() ? 20 : unit.type.hitSize * 2f;\n", "    }\n", "\n", "    @Override\n", "    public void afterSync() {\n", "        // fix rubberbanding:\n", "        // when the player recs a unit that they JUST transitioned away from, use the new unit instead\n", "        // reason: we know the server is lying here, essentially skip the unit snapshot because we know the client's information is more recent\n", "        if (isLocal() && unit == justSwitchFrom && justSwitchFrom != null && justSwitchTo != null) {\n", "            unit = justSwitchTo;\n", "            // if several snapshots have passed and this unit is still incorrect, something's wrong\n", "            if (++wrongReadUnits >= 2) {\n", "                justSwitchFrom = null;\n", "                wrongReadUnits = 0;\n", "            }\n", "        } else {\n", "            justSwitchFrom = null;\n", "            justSwitchTo = null;\n", "            wrongReadUnits = 0;\n", "        }\n", "        // simulate a unit change after sync\n", "        Unit set = unit;\n", "        unit = lastReadUnit;\n", "        unit(set);\n", "        lastReadUnit = unit;\n", "        unit.aim(mouseX, mouseY);\n", "        // this is only necessary when the thing being controlled isn't synced\n", "        unit.controlWeapons(shooting, shooting);\n", "        // extra precaution, necessary for non-synced things\n", "        unit.controller(this);\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        if (!unit.isValid()) {\n", "            clearUnit();\n", "        }\n", "        CoreBuild core;\n", "        if (!dead()) {\n", "            set(unit);\n", "            unit.team(team);\n", "            deathTimer = 0;\n", "            // update some basic state to sync things\n", "            if (unit.type.canBoost) {\n", "                unit.elevation = Mathf.approachDelta(unit.elevation, unit.onSolid() || boosting || (unit.isFlying() && !unit.canLand()) ? 1f : 0f, unit.type.riseSpeed);\n", "            }\n", "        } else if ((core = bestCore()) != null) {\n", "            // have a small delay before death to prevent the camera from jumping around too quickly\n", "            // (this is not for balance, it just looks better this way)\n", "            deathTimer += Time.delta;\n", "            if (deathTimer >= deathDelay) {\n", "                // request spawn - this happens serverside only\n", "                core.requestSpawn(self());\n", "                deathTimer = 0;\n", "            }\n", "        }\n", "        textFadeTime -= Time.delta / (60 * 5);\n", "    }\n", "\n", "    public void checkSpawn() {\n", "        CoreBuild core = bestCore();\n", "        if (core != null) {\n", "            core.requestSpawn(self());\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "        // clear unit upon removal\n", "        if (!unit.isNull()) {\n", "            clearUnit();\n", "        }\n", "    }\n", "\n", "    public void team(Team team) {\n", "        this.team = team;\n", "        unit.team(team);\n", "    }\n", "\n", "    public void clearUnit() {\n", "        unit(Nulls.unit);\n", "    }\n", "\n", "    public Unit unit() {\n", "        return unit;\n", "    }\n", "\n", "    public void unit(Unit unit) {\n", "        // refuse to switch when the unit was just transitioned from\n", "        if (isLocal() && unit == justSwitchFrom && justSwitchFrom != null && justSwitchTo != null) {\n", "            return;\n", "        }\n", "        if (unit == null)\n", "            throw new IllegalArgumentException(\"Unit cannot be null. Use clearUnit() instead.\");\n", "        if (this.unit == unit)\n", "            return;\n", "        if (this.unit != Nulls.unit) {\n", "            // un-control the old unit\n", "            this.unit.resetController();\n", "        }\n", "        this.unit = unit;\n", "        if (unit != Nulls.unit) {\n", "            unit.team(team);\n", "            unit.controller(this);\n", "            // this player just became remote, snap the interpolation so it doesn't go wild\n", "            if (unit.isRemote()) {\n", "                unit.snapInterpolation();\n", "            }\n", "            // reset selected block when switching units\n", "            if (!headless && isLocal()) {\n", "                control.input.block = null;\n", "            }\n", "        }\n", "        Events.fire(new UnitChangeEvent(self(), unit));\n", "    }\n", "\n", "    boolean dead() {\n", "        return unit.isNull() || !unit.isValid();\n", "    }\n", "\n", "    String ip() {\n", "        return con == null ? \"localhost\" : con.address;\n", "    }\n", "\n", "    String uuid() {\n", "        return con == null ? \"[LOCAL]\" : con.uuid;\n", "    }\n", "\n", "    String usid() {\n", "        return con == null ? \"[LOCAL]\" : con.usid;\n", "    }\n", "\n", "    void kick(KickReason reason) {\n", "        con.kick(reason);\n", "    }\n", "\n", "    void kick(KickReason reason, long duration) {\n", "        con.kick(reason, duration);\n", "    }\n", "\n", "    void kick(String reason) {\n", "        con.kick(reason);\n", "    }\n", "\n", "    void kick(String reason, long duration) {\n", "        con.kick(reason, duration);\n", "    }\n", "\n", "    @Override\n", "    public void draw() {\n", "        if (unit != null && unit.inFogTo(Vars.player.team()))\n", "            return;\n", "        Draw.z(Layer.playerName);\n", "        float z = Drawf.text();\n", "        Font font = Fonts.outline;\n", "        GlyphLayout layout = Pools.obtain(GlyphLayout.class, GlyphLayout::new);\n", "        final float nameHeight = 11;\n", "        final float textHeight = 15;\n", "        boolean ints = font.usesIntegerPositions();\n", "        font.setUseIntegerPositions(false);\n", "        font.getData().setScale(0.25f / Scl.scl(1f));\n", "        layout.setText(font, name);\n", "        if (!isLocal()) {\n", "            Draw.color(0f, 0f, 0f, 0.3f);\n", "            Fill.rect(unit.x, unit.y + nameHeight - layout.height / 2, layout.width + 2, layout.height + 3);\n", "            Draw.color();\n", "            font.setColor(color);\n", "            font.draw(name, unit.x, unit.y + nameHeight, 0, Align.center, false);\n", "            if (admin) {\n", "                float s = 3f;\n", "                Draw.color(color.r * 0.5f, color.g * 0.5f, color.b * 0.5f, 1f);\n", "                Draw.rect(Icon.adminSmall.getRegion(), unit.x + layout.width / 2f + 2 + 1, unit.y + nameHeight - 1.5f, s, s);\n", "                Draw.color(color);\n", "                Draw.rect(Icon.adminSmall.getRegion(), unit.x + layout.width / 2f + 2 + 1, unit.y + nameHeight - 1f, s, s);\n", "            }\n", "        }\n", "        if (Core.settings.getBool(\"playerchat\") && ((textFadeTime > 0 && lastText != null) || typing)) {\n", "            String text = textFadeTime <= 0 || lastText == null ? \"[lightgray]\" + Strings.animated(Time.time, 4, 15f, \".\") : lastText;\n", "            float width = 100f;\n", "            float visualFadeTime = 1f - Mathf.curve(1f - textFadeTime, 0.9f);\n", "            font.setColor(1f, 1f, 1f, textFadeTime <= 0 || lastText == null ? 1f : visualFadeTime);\n", "            layout.setText(font, text, Color.white, width, Align.bottom, true);\n", "            Draw.color(0f, 0f, 0f, 0.3f * (textFadeTime <= 0 || lastText == null ? 1f : visualFadeTime));\n", "            Fill.rect(unit.x, unit.y + textHeight + layout.height - layout.height / 2f, layout.width + 2, layout.height + 3);\n", "            font.draw(text, unit.x - width / 2f, unit.y + textHeight + layout.height, width, Align.center, true);\n", "        }\n", "        Draw.reset();\n", "        Pools.free(layout);\n", "        font.getData().setScale(1f);\n", "        font.setColor(Color.white);\n", "        font.setUseIntegerPositions(ints);\n", "        Draw.z(z);\n", "    }\n", "\n", "    /**\n", "     * @return name with a markup color prefix\n", "     */\n", "    String coloredName() {\n", "        return \"[#\" + color.toString().toUpperCase() + \"]\" + name;\n", "    }\n", "\n", "    String plainName() {\n", "        return Strings.stripColors(name);\n", "    }\n", "\n", "    void sendMessage(String text) {\n", "        if (isLocal()) {\n", "            if (ui != null) {\n", "                ui.chatfrag.addMessage(text);\n", "            }\n", "        } else {\n", "            Call.sendMessage(con, text, null, null);\n", "        }\n", "    }\n", "\n", "    void sendMessage(String text, Player from) {\n", "        sendMessage(text, from, null);\n", "    }\n", "\n", "    void sendMessage(String text, Player from, String unformatted) {\n", "        if (isLocal()) {\n", "            if (ui != null) {\n", "                ui.chatfrag.addMessage(text);\n", "            }\n", "        } else {\n", "            Call.sendMessage(con, text, unformatted, from);\n", "        }\n", "    }\n", "\n", "    PlayerInfo getInfo() {\n", "        if (isLocal()) {\n", "            throw new IllegalArgumentException(\"Local players cannot be traced and do not have info.\");\n", "        } else {\n", "            return netServer.admins.getInfo(uuid());\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("PosComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.math.geom.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.core.*;\n", "import mindustry.gen.*;\n", "import mindustry.world.*;\n", "import mindustry.world.blocks.environment.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class PosComp implements Position {\n", "\n", "    @SyncField(true)\n", "    @SyncLocal\n", "    float x, y;\n", "\n", "    void set(float x, float y) {\n", "        this.x = x;\n", "        this.y = y;\n", "    }\n", "\n", "    void set(Position pos) {\n", "        set(pos.getX(), pos.getY());\n", "    }\n", "\n", "    void trns(float x, float y) {\n", "        set(this.x + x, this.y + y);\n", "    }\n", "\n", "    void trns(Position pos) {\n", "        trns(pos.getX(), pos.getY());\n", "    }\n", "\n", "    int tileX() {\n", "        return World.toTile(x);\n", "    }\n", "\n", "    int tileY() {\n", "        return World.toTile(y);\n", "    }\n", "\n", "    /**\n", "     * Returns air if this unit is on a non-air top block.\n", "     */\n", "    Floor floorOn() {\n", "        Tile tile = tileOn();\n", "        return tile == null || tile.block() != Blocks.air ? (Floor) Blocks.air : tile.floor();\n", "    }\n", "\n", "    Block blockOn() {\n", "        Tile tile = tileOn();\n", "        return tile == null ? Blocks.air : tile.block();\n", "    }\n", "\n", "    @Nullable\n", "    Building buildOn() {\n", "        return world.buildWorld(x, y);\n", "    }\n", "\n", "    @Nullable\n", "    Tile tileOn() {\n", "        return world.tileWorld(x, y);\n", "    }\n", "\n", "    boolean onSolid() {\n", "        Tile tile = tileOn();\n", "        return tile == null || tile.solid();\n", "    }\n", "\n", "    @Override\n", "    public float getX() {\n", "        return x;\n", "    }\n", "\n", "    @Override\n", "    public float getY() {\n", "        return y;\n", "    }\n", "}\n" }));
        compMap.put("PosTeamDef",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "// dummy target definition\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = Teamc.class, genio = false, isFinal = false)\n", "public class PosTeamDef {\n", "}\n" }));
        compMap.put("PowerGraphUpdaterComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import mindustry.world.blocks.power.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = PowerGraphUpdaterc.class, serialize = false, genio = false)\n", "@Component\n", "abstract class PowerGraphUpdaterComp implements Entityc {\n", "\n", "    public transient PowerGraph graph;\n", "\n", "    @Override\n", "    public void update() {\n", "        graph.update();\n", "    }\n", "}\n" }));
        compMap.put("PuddleComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.func.*;\n", "import arc.graphics.g2d.*;\n", "import arc.math.*;\n", "import arc.math.geom.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.entities.*;\n", "import mindustry.gen.*;\n", "import mindustry.graphics.*;\n", "import mindustry.type.*;\n", "import mindustry.world.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.entities.Puddles.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { Puddlec.class }, pooled = true)\n", "@Component(base = true)\n", "abstract class PuddleComp implements Posc, Puddlec, Drawc {\n", "\n", "    private static final Rect rect = new Rect(), rect2 = new Rect();\n", "\n", "    private static Puddle paramPuddle;\n", "\n", "    private static Cons<Unit> unitCons = unit -> {\n", "        if (unit.isGrounded() && !unit.hovering) {\n", "            unit.hitbox(rect2);\n", "            if (rect.overlaps(rect2)) {\n", "                unit.apply(paramPuddle.liquid.effect, 60 * 2);\n", "                if (unit.vel.len2() > 0.1f * 0.1f) {\n", "                    Fx.ripple.at(unit.x, unit.y, unit.type.rippleScale, paramPuddle.liquid.color);\n", "                }\n", "            }\n", "        }\n", "    };\n", "\n", "    @Import\n", "    int id;\n", "\n", "    @Import\n", "    float x, y;\n", "\n", "    @Import\n", "    boolean added;\n", "\n", "    transient float accepting, updateTime, lastRipple = Time.time + Mathf.random(40f), effectTime = Mathf.random(50f);\n", "\n", "    float amount;\n", "\n", "    Tile tile;\n", "\n", "    Liquid liquid;\n", "\n", "    public float getFlammability() {\n", "        return liquid.flammability * amount;\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        float addSpeed = accepting > 0 ? 3f : 0f;\n", "        amount -= Time.delta * (1f - liquid.viscosity) / (5f + addSpeed);\n", "        amount += accepting;\n", "        accepting = 0f;\n", "        if (amount >= maxLiquid / 1.5f) {\n", "            float deposited = Math.min((amount - maxLiquid / 1.5f) / 4f, 0.3f * Time.delta);\n", "            int targets = 0;\n", "            for (Point2 point : Geometry.d4) {\n", "                Tile other = world.tile(tile.x + point.x, tile.y + point.y);\n", "                if (other != null && (other.block() == Blocks.air || liquid.moveThroughBlocks)) {\n", "                    targets++;\n", "                    Puddles.deposit(other, tile, liquid, deposited, false);\n", "                }\n", "            }\n", "            amount -= deposited * targets;\n", "        }\n", "        if (liquid.capPuddles) {\n", "            amount = Mathf.clamp(amount, 0, maxLiquid);\n", "        }\n", "        if (amount <= 0f) {\n", "            remove();\n", "            return;\n", "        }\n", "        if (Puddles.get(tile) != self() && added) {\n", "            // force removal without pool free\n", "            Groups.all.remove(self());\n", "            Groups.draw.remove(self());\n", "            Groups.puddle.remove(self());\n", "            added = false;\n", "            return;\n", "        }\n", "        // effects-only code\n", "        if (amount >= maxLiquid / 2f && updateTime <= 0f) {\n", "            paramPuddle = self();\n", "            Units.nearby(rect.setSize(Mathf.clamp(amount / (maxLiquid / 1.5f)) * 10f).setCenter(x, y), unitCons);\n", "            if (liquid.temperature > 0.7f && tile.build != null && Mathf.chance(0.5)) {\n", "                Fires.create(tile);\n", "            }\n", "            updateTime = 40f;\n", "        }\n", "        if (!headless && liquid.particleEffect != Fx.none) {\n", "            if ((effectTime += Time.delta) >= liquid.particleSpacing) {\n", "                float size = Mathf.clamp(amount / (maxLiquid / 1.5f)) * 4f;\n", "                liquid.particleEffect.at(x + Mathf.range(size), y + Mathf.range(size));\n", "                effectTime = 0f;\n", "            }\n", "        }\n", "        updateTime -= Time.delta;\n", "        liquid.update(self());\n", "    }\n", "\n", "    @Override\n", "    public void draw() {\n", "        Draw.z(Layer.debris - 1);\n", "        liquid.drawPuddle(self());\n", "    }\n", "\n", "    @Replace\n", "    public float clipSize() {\n", "        return 20;\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "        Puddles.remove(tile);\n", "    }\n", "\n", "    @Override\n", "    public void afterRead() {\n", "        Puddles.register(self());\n", "    }\n", "}\n" }));
        compMap.put("RotComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class RotComp implements Entityc {\n", "\n", "    @SyncField(false)\n", "    @SyncLocal\n", "    float rotation;\n", "}\n" }));
        compMap.put("ShieldComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.entities.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import mindustry.type.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class ShieldComp implements Healthc, Posc {\n", "\n", "    @Import\n", "    float health, hitTime, x, y, healthMultiplier;\n", "\n", "    @Import\n", "    boolean dead;\n", "\n", "    @Import\n", "    Team team;\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    /**\n", "     * Absorbs health damage.\n", "     */\n", "    float shield;\n", "\n", "    /**\n", "     * Subtracts an amount from damage. No need to save.\n", "     */\n", "    transient float armor;\n", "\n", "    /**\n", "     * Shield opacity.\n", "     */\n", "    transient float shieldAlpha = 0f;\n", "\n", "    @Replace\n", "    @Override\n", "    public void damage(float amount) {\n", "        // apply armor and scaling effects\n", "        rawDamage(Damage.applyArmor(amount, armor) / healthMultiplier);\n", "    }\n", "\n", "    @Replace\n", "    @Override\n", "    public void damagePierce(float amount, boolean withEffect) {\n", "        float pre = hitTime;\n", "        rawDamage(amount);\n", "        if (!withEffect) {\n", "            hitTime = pre;\n", "        }\n", "    }\n", "\n", "    private void rawDamage(float amount) {\n", "        boolean hadShields = shield > 0.0001f;\n", "        if (hadShields) {\n", "            shieldAlpha = 1f;\n", "        }\n", "        float shieldDamage = Math.min(Math.max(shield, 0), amount);\n", "        shield -= shieldDamage;\n", "        hitTime = 1f;\n", "        amount -= shieldDamage;\n", "        if (amount > 0 && type.killable) {\n", "            health -= amount;\n", "            if (health <= 0 && !dead) {\n", "                kill();\n", "            }\n", "            if (hadShields && shield <= 0.0001f) {\n", "                Fx.unitShieldBreak.at(x, y, 0, team.color, this);\n", "            }\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        shieldAlpha -= Time.delta / 15f;\n", "        if (shieldAlpha < 0)\n", "            shieldAlpha = 0f;\n", "    }\n", "}\n" }));
        compMap.put("ShielderComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class ShielderComp implements Damagec, Teamc, Posc {\n", "\n", "    void absorb() {\n", "    }\n", "}\n" }));
        compMap.put("StatusComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.graphics.*;\n", "import arc.struct.*;\n", "import arc.util.*;\n", "import arc.util.pooling.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.ctype.*;\n", "import mindustry.entities.units.*;\n", "import mindustry.gen.*;\n", "import mindustry.type.*;\n", "import mindustry.world.blocks.environment.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class StatusComp implements Posc, Flyingc {\n", "\n", "    private Seq<StatusEntry> statuses = new Seq<>();\n", "\n", "    private transient Bits applied = new Bits(content.getBy(ContentType.status).size);\n", "\n", "    // these are considered read-only\n", "    transient float speedMultiplier = 1, damageMultiplier = 1, healthMultiplier = 1, reloadMultiplier = 1, buildSpeedMultiplier = 1, dragMultiplier = 1;\n", "\n", "    transient boolean disarmed = false;\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    /**\n", "     * Apply a status effect for 1 tick (for permanent effects) *\n", "     */\n", "    void apply(StatusEffect effect) {\n", "        apply(effect, 1);\n", "    }\n", "\n", "    /**\n", "     * Adds a status effect to this unit.\n", "     */\n", "    void apply(StatusEffect effect, float duration) {\n", "        // don't apply empty or immune effects\n", "        if (effect == StatusEffects.none || effect == null || isImmune(effect))\n", "            return;\n", "        // unlock status effects regardless of whether they were applied to friendly units\n", "        if (state.isCampaign()) {\n", "            effect.unlock();\n", "        }\n", "        if (statuses.size > 0) {\n", "            // check for opposite effects\n", "            for (int i = 0; i < statuses.size; i++) {\n", "                StatusEntry entry = statuses.get(i);\n", "                // extend effect\n", "                if (entry.effect == effect) {\n", "                    entry.time = Math.max(entry.time, duration);\n", "                    return;\n", "                } else if (entry.effect.applyTransition(self(), effect, entry, duration)) {\n", "                    // find reaction\n", "                    // TODO effect may react with multiple other effects\n", "                    // stop looking when one is found\n", "                    return;\n", "                }\n", "            }\n", "        }\n", "        if (!effect.reactive) {\n", "            // otherwise, no opposites found, add direct effect\n", "            StatusEntry entry = Pools.obtain(StatusEntry.class, StatusEntry::new);\n", "            entry.set(effect, duration);\n", "            statuses.add(entry);\n", "        }\n", "    }\n", "\n", "    float getDuration(StatusEffect effect) {\n", "        var entry = statuses.find(e -> e.effect == effect);\n", "        return entry == null ? 0 : entry.time;\n", "    }\n", "\n", "    void clearStatuses() {\n", "        statuses.clear();\n", "    }\n", "\n", "    /**\n", "     * Removes a status effect.\n", "     */\n", "    void unapply(StatusEffect effect) {\n", "        statuses.remove(e -> {\n", "            if (e.effect == effect) {\n", "                Pools.free(e);\n", "                return true;\n", "            }\n", "            return false;\n", "        });\n", "    }\n", "\n", "    boolean isBoss() {\n", "        return hasEffect(StatusEffects.boss);\n", "    }\n", "\n", "    abstract boolean isImmune(StatusEffect effect);\n", "\n", "    Color statusColor() {\n", "        if (statuses.size == 0) {\n", "            return Tmp.c1.set(Color.white);\n", "        }\n", "        float r = 1f, g = 1f, b = 1f, total = 0f;\n", "        for (StatusEntry entry : statuses) {\n", "            float intensity = entry.time < 10f ? entry.time / 10f : 1f;\n", "            r += entry.effect.color.r * intensity;\n", "            g += entry.effect.color.g * intensity;\n", "            b += entry.effect.color.b * intensity;\n", "            total += intensity;\n", "        }\n", "        float count = statuses.size + total;\n", "        return Tmp.c1.set(r / count, g / count, b / count, 1f);\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        Floor floor = floorOn();\n", "        if (isGrounded() && !type.hovering) {\n", "            // apply effect\n", "            apply(floor.status, floor.statusDuration);\n", "        }\n", "        applied.clear();\n", "        speedMultiplier = damageMultiplier = healthMultiplier = reloadMultiplier = buildSpeedMultiplier = dragMultiplier = 1f;\n", "        disarmed = false;\n", "        if (statuses.isEmpty())\n", "            return;\n", "        int index = 0;\n", "        while (index < statuses.size) {\n", "            StatusEntry entry = statuses.get(index++);\n", "            entry.time = Math.max(entry.time - Time.delta, 0);\n", "            if (entry.effect == null || (entry.time <= 0 && !entry.effect.permanent)) {\n", "                Pools.free(entry);\n", "                index--;\n", "                statuses.remove(index);\n", "            } else {\n", "                applied.set(entry.effect.id);\n", "                speedMultiplier *= entry.effect.speedMultiplier;\n", "                healthMultiplier *= entry.effect.healthMultiplier;\n", "                damageMultiplier *= entry.effect.damageMultiplier;\n", "                reloadMultiplier *= entry.effect.reloadMultiplier;\n", "                buildSpeedMultiplier *= entry.effect.buildSpeedMultiplier;\n", "                dragMultiplier *= entry.effect.dragMultiplier;\n", "                disarmed |= entry.effect.disarm;\n", "                entry.effect.update(self(), entry.time);\n", "            }\n", "        }\n", "    }\n", "\n", "    public Bits statusBits() {\n", "        return applied;\n", "    }\n", "\n", "    public void draw() {\n", "        for (StatusEntry e : statuses) {\n", "            e.effect.draw(self(), e.time);\n", "        }\n", "    }\n", "\n", "    boolean hasEffect(StatusEffect effect) {\n", "        return applied.get(effect.id);\n", "    }\n", "}\n" }));
        compMap.put("SyncComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.util.io.*;\n", "import mindustry.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import java.nio.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class SyncComp implements Entityc {\n", "\n", "    transient long lastUpdated, updateSpacing;\n", "\n", "    // all these method bodies are internally generated\n", "    void snapSync() {\n", "    }\n", "\n", "    void snapInterpolation() {\n", "    }\n", "\n", "    void readSync(Reads read) {\n", "    }\n", "\n", "    void writeSync(Writes write) {\n", "    }\n", "\n", "    void readSyncManual(FloatBuffer buffer) {\n", "    }\n", "\n", "    void writeSyncManual(FloatBuffer buffer) {\n", "    }\n", "\n", "    void afterSync() {\n", "    }\n", "\n", "    void interpolate() {\n", "    }\n", "\n", "    boolean isSyncHidden(Player player) {\n", "        return false;\n", "    }\n", "\n", "    void handleSyncHidden() {\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        // interpolate the player if:\n", "        // - this is a client and the entity is everything except the local player\n", "        // - this is a server and the entity is a remote player\n", "        if ((Vars.net.client() && !isLocal()) || isRemote()) {\n", "            interpolate();\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "        // notify client of removal\n", "        if (Vars.net.client()) {\n", "            Vars.netClient.addRemovedEntity(id());\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("TankComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.math.*;\n", "import arc.math.geom.*;\n", "import arc.util.*;\n", "import mindustry.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.entities.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import mindustry.type.*;\n", "import mindustry.world.*;\n", "import mindustry.world.blocks.environment.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class TankComp implements Posc, Flyingc, Hitboxc, Unitc, ElevationMovec {\n", "\n", "    @Import\n", "    float x, y, hitSize, rotation, speedMultiplier;\n", "\n", "    @Import\n", "    boolean hovering;\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    @Import\n", "    Team team;\n", "\n", "    transient private float treadEffectTime, lastSlowdown = 1f;\n", "\n", "    transient float treadTime;\n", "\n", "    transient boolean walked;\n", "\n", "    @Override\n", "    public void update() {\n", "        // dust\n", "        if (walked && !headless && !inFogTo(player.team())) {\n", "            treadEffectTime += Time.delta;\n", "            if (treadEffectTime >= 6f && type.treadRects.length > 0) {\n", "                // first rect should always be at the back\n", "                var treadRect = type.treadRects[0];\n", "                float xOffset = (-(treadRect.x + treadRect.width / 2f)) / 4f;\n", "                float yOffset = (-(treadRect.y + treadRect.height / 2f)) / 4f;\n", "                for (int i : Mathf.signs) {\n", "                    Tmp.v1.set(xOffset * i, yOffset - treadRect.height / 2f / 4f).rotate(rotation - 90);\n", "                    // TODO could fin for a while\n", "                    Effect.floorDustAngle(type.treadEffect, Tmp.v1.x + x, Tmp.v1.y + y, rotation + 180f);\n", "                }\n", "                treadEffectTime = 0f;\n", "            }\n", "        }\n", "        // calculate overlapping tiles so it slows down when going \"over\" walls\n", "        int r = Math.max(Math.round(hitSize * 0.6f / tilesize), 1);\n", "        int solids = 0, total = (r * 2 + 1) * (r * 2 + 1);\n", "        for (int dx = -r; dx <= r; dx++) {\n", "            for (int dy = -r; dy <= r; dy++) {\n", "                Tile t = Vars.world.tileWorld(x + dx * tilesize, y + dy * tilesize);\n", "                if (t == null || t.solid()) {\n", "                    solids++;\n", "                }\n", "                // TODO should this apply to the player team(s)? currently PvE due to balancing\n", "                if (// damage radius is 1 tile smaller to prevent it from just touching walls as it passes\n", "                type.crushDamage > 0 && walked && t != null && t.build != null && t.build.team != team && Math.max(Math.abs(dx), Math.abs(dy)) <= r - 1) {\n", "                    t.build.damage(team, type.crushDamage * Time.delta * t.block().crushDamageMultiplier);\n", "                }\n", "            }\n", "        }\n", "        lastSlowdown = Mathf.lerp(1f, type.crawlSlowdown, Mathf.clamp((float) solids / total / type.crawlSlowdownFrac));\n", "        // trigger animation only when walking manually\n", "        if (walked || net.client()) {\n", "            float len = deltaLen();\n", "            treadTime += len;\n", "            walked = false;\n", "        }\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public float floorSpeedMultiplier() {\n", "        Floor on = isFlying() || hovering ? Blocks.air.asFloor() : floorOn();\n", "        // TODO take into account extra blocks\n", "        return on.speedMultiplier * speedMultiplier * lastSlowdown;\n", "    }\n", "\n", "    @Replace\n", "    @Override\n", "    @Nullable\n", "    public Floor drownFloor() {\n", "        // tanks can only drown when all the nearby floors are deep\n", "        // TODO implement properly\n", "        if (hitSize >= 12 && canDrown()) {\n", "            for (Point2 p : Geometry.d8) {\n", "                Floor f = world.floorWorld(x + p.x * tilesize, y + p.y * tilesize);\n", "                if (!f.isDeep()) {\n", "                    return null;\n", "                }\n", "            }\n", "        }\n", "        return canDrown() ? floorOn() : null;\n", "    }\n", "\n", "    @Override\n", "    public void moveAt(Vec2 vector, float acceleration) {\n", "        // mark walking state when moving in a controlled manner\n", "        if (!vector.isZero(0.001f)) {\n", "            walked = true;\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void approach(Vec2 vector) {\n", "        // mark walking state when moving in a controlled manner\n", "        if (!vector.isZero(0.001f)) {\n", "            walked = true;\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("TeamComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import mindustry.world.blocks.storage.CoreBlock.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class TeamComp implements Posc {\n", "\n", "    @Import\n", "    float x, y;\n", "\n", "    Team team = Team.derelict;\n", "\n", "    public boolean cheating() {\n", "        return team.rules().cheat;\n", "    }\n", "\n", "    /**\n", "     * @return whether the center of this entity is visible to the viewing team.\n", "     */\n", "    boolean inFogTo(Team viewer) {\n", "        return this.team != viewer && !fogControl.isVisible(viewer, x, y);\n", "    }\n", "\n", "    @Nullable\n", "    public CoreBuild core() {\n", "        return team.core();\n", "    }\n", "\n", "    @Nullable\n", "    public CoreBuild closestCore() {\n", "        return state.teams.closestCore(x, y, team);\n", "    }\n", "\n", "    @Nullable\n", "    public CoreBuild closestEnemyCore() {\n", "        return state.teams.closestEnemyCore(x, y, team);\n", "    }\n", "}\n" }));
        compMap.put("TimedComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.math.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class TimedComp implements Entityc, Scaled {\n", "\n", "    float time, lifetime;\n", "\n", "    // called last so pooling and removal happens then.\n", "    @MethodPriority(100)\n", "    @Override\n", "    public void update() {\n", "        time = Math.min(time + Time.delta, lifetime);\n", "        if (time >= lifetime) {\n", "            remove();\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public float fin() {\n", "        return time / lifetime;\n", "    }\n", "}\n" }));
        compMap.put("TimedKillComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.math.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "// basically just TimedComp but kills instead of removing.\n", "@Component\n", "abstract class TimedKillComp implements Entityc, Healthc, Scaled {\n", "\n", "    float time, lifetime;\n", "\n", "    // called last so pooling and removal happens then.\n", "    @MethodPriority(100)\n", "    @Override\n", "    public void update() {\n", "        time = Math.min(time + Time.delta, lifetime);\n", "        if (time >= lifetime) {\n", "            kill();\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public float fin() {\n", "        return time / lifetime;\n", "    }\n", "}\n" }));
        compMap.put("TimerComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class TimerComp {\n", "\n", "    transient Interval timer = new Interval(6);\n", "\n", "    public boolean timer(int index, float time) {\n", "        if (Float.isInfinite(time))\n", "            return false;\n", "        return timer.get(index, time);\n", "    }\n", "}\n" }));
        compMap.put("UnitComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.*;\n", "import arc.graphics.*;\n", "import arc.graphics.g2d.*;\n", "import arc.math.*;\n", "import arc.math.geom.*;\n", "import arc.scene.ui.layout.*;\n", "import arc.util.*;\n", "import mindustry.ai.*;\n", "import mindustry.ai.types.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.core.*;\n", "import mindustry.ctype.*;\n", "import mindustry.entities.*;\n", "import mindustry.entities.abilities.*;\n", "import mindustry.entities.units.*;\n", "import mindustry.game.EventType.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import mindustry.graphics.*;\n", "import mindustry.logic.*;\n", "import mindustry.type.*;\n", "import mindustry.ui.*;\n", "import mindustry.world.*;\n", "import mindustry.world.blocks.environment.*;\n", "import mindustry.world.blocks.payloads.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.GlobalVars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component(base = true)\n", "abstract class UnitComp implements Healthc, Physicsc, Hitboxc, Statusc, Teamc, Itemsc, Rotc, Unitc, Weaponsc, Drawc, Boundedc, Syncc, Shieldc, Displayable, Senseable, Ranged, Minerc, Builderc {\n", "\n", "    @Import\n", "    boolean hovering, dead, disarmed;\n", "\n", "    @Import\n", "    float x, y, rotation, elevation, maxHealth, drag, armor, hitSize, health, ammo, dragMultiplier;\n", "\n", "    @Import\n", "    Team team;\n", "\n", "    @Import\n", "    int id;\n", "\n", "    @Import\n", "    @Nullable\n", "    Tile mineTile;\n", "\n", "    @Import\n", "    Vec2 vel;\n", "\n", "    @Import\n", "    WeaponMount[] mounts;\n", "\n", "    private UnitController controller;\n", "\n", "    Ability[] abilities = {};\n", "\n", "    UnitType type = UnitTypes.alpha;\n", "\n", "    boolean spawnedByCore;\n", "\n", "    double flag;\n", "\n", "    @Nullable\n", "    transient Trail trail;\n", "\n", "    // TODO could be better represented as a unit\n", "    @Nullable\n", "    transient UnitType dockedType;\n", "\n", "    transient String lastCommanded;\n", "\n", "    transient float shadowAlpha = -1f, healTime;\n", "\n", "    transient int lastFogPos;\n", "\n", "    private transient float resupplyTime = Mathf.random(10f);\n", "\n", "    private transient boolean wasPlayer;\n", "\n", "    private transient boolean wasHealed;\n", "\n", "    /**\n", "     * Called when this unit was unloaded from a factory or spawn point.\n", "     */\n", "    public void unloaded() {\n", "    }\n", "\n", "    /**\n", "     * Move based on preferred unit movement type.\n", "     */\n", "    public void movePref(Vec2 movement) {\n", "        if (type.omniMovement) {\n", "            moveAt(movement);\n", "        } else {\n", "            rotateMove(movement);\n", "        }\n", "    }\n", "\n", "    public void moveAt(Vec2 vector) {\n", "        moveAt(vector, type.accel);\n", "    }\n", "\n", "    public void approach(Vec2 vector) {\n", "        vel.approachDelta(vector, type.accel * speed());\n", "    }\n", "\n", "    public void rotateMove(Vec2 vec) {\n", "        moveAt(Tmp.v2.trns(rotation, vec.len()));\n", "        if (!vec.isZero()) {\n", "            rotation = Angles.moveToward(rotation, vec.angle(), type.rotateSpeed * Time.delta);\n", "        }\n", "    }\n", "\n", "    public void aimLook(Position pos) {\n", "        aim(pos);\n", "        lookAt(pos);\n", "    }\n", "\n", "    public void aimLook(float x, float y) {\n", "        aim(x, y);\n", "        lookAt(x, y);\n", "    }\n", "\n", "    /**\n", "     * @return approx. square size of the physical hitbox for physics\n", "     */\n", "    public float physicSize() {\n", "        return hitSize * 0.7f;\n", "    }\n", "\n", "    /**\n", "     * @return whether there is solid, un-occupied ground under this unit.\n", "     */\n", "    public boolean canLand() {\n", "        return !onSolid() && Units.count(x, y, physicSize(), f -> f != self() && f.isGrounded()) == 0;\n", "    }\n", "\n", "    public boolean inRange(Position other) {\n", "        return within(other, type.range);\n", "    }\n", "\n", "    public boolean hasWeapons() {\n", "        return type.hasWeapons();\n", "    }\n", "\n", "    /**\n", "     * @return speed with boost & floor multipliers factored in.\n", "     */\n", "    public float speed() {\n", "        float strafePenalty = isGrounded() || !isPlayer() ? 1f : Mathf.lerp(1f, type.strafePenalty, Angles.angleDist(vel().angle(), rotation) / 180f);\n", "        float boost = Mathf.lerp(1f, type.canBoost ? type.boostMultiplier : 1f, elevation);\n", "        return type.speed * strafePenalty * boost * floorSpeedMultiplier();\n", "    }\n", "\n", "    /**\n", "     * @return where the unit wants to look at.\n", "     */\n", "    public float prefRotation() {\n", "        if (activelyBuilding() && type.rotateToBuilding) {\n", "            return angleTo(buildPlan());\n", "        } else if (mineTile != null) {\n", "            return angleTo(mineTile);\n", "        } else if (moving() && type.omniMovement) {\n", "            return vel().angle();\n", "        }\n", "        return rotation;\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public boolean isSyncHidden(Player player) {\n", "        // shooting reveals position so bullets can be seen\n", "        return !isShooting() && inFogTo(player.team());\n", "    }\n", "\n", "    @Override\n", "    public void handleSyncHidden() {\n", "        remove();\n", "        netClient.clearRemovedEntity(id);\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public boolean inFogTo(Team viewer) {\n", "        if (this.team == viewer || !state.rules.fog)\n", "            return false;\n", "        if (hitSize <= 16f) {\n", "            return !fogControl.isVisible(viewer, x, y);\n", "        } else {\n", "            // for large hitsizes, check around the unit instead\n", "            float trns = hitSize / 2f;\n", "            for (var p : Geometry.d8) {\n", "                if (fogControl.isVisible(viewer, x + p.x * trns, y + p.y * trns)) {\n", "                    return false;\n", "                }\n", "            }\n", "        }\n", "        return true;\n", "    }\n", "\n", "    @Override\n", "    public float range() {\n", "        return type.maxRange;\n", "    }\n", "\n", "    @Replace\n", "    public float clipSize() {\n", "        if (isBuilding()) {\n", "            return state.rules.infiniteResources ? Float.MAX_VALUE : Math.max(type.clipSize, type.region.width) + type.buildRange + tilesize * 4f;\n", "        }\n", "        if (mining()) {\n", "            return type.clipSize + type.mineRange;\n", "        }\n", "        return type.clipSize;\n", "    }\n", "\n", "    @Override\n", "    public double sense(LAccess sensor) {\n", "        CommandAI command;\n", "        Payloadc pay;\n", "        switch(sensor) {\n", "            case totalItems:\n", "                return stack().amount;\n", "            case itemCapacity:\n", "                return type.itemCapacity;\n", "            case rotation:\n", "                return rotation;\n", "            case health:\n", "                return health;\n", "            case maxHealth:\n", "                return maxHealth;\n", "            case ammo:\n", "                return !state.rules.unitAmmo ? type.ammoCapacity : ammo;\n", "            case ammoCapacity:\n", "                return type.ammoCapacity;\n", "            case x:\n", "                return World.conv(x);\n", "            case y:\n", "                return World.conv(y);\n", "            case dead:\n", "                return dead || !isAdded() ? 1 : 0;\n", "            case team:\n", "                return team.id;\n", "            case shooting:\n", "                return isShooting() ? 1 : 0;\n", "            case boosting:\n", "                return type.canBoost && isFlying() ? 1 : 0;\n", "            case range:\n", "                return range() / tilesize;\n", "            case shootX:\n", "                return World.conv(aimX());\n", "            case shootY:\n", "                return World.conv(aimY());\n", "            case mining:\n", "                return mining() ? 1 : 0;\n", "            case mineX:\n", "                return mining() ? mineTile.x : -1;\n", "            case mineY:\n", "                return mining() ? mineTile.y : -1;\n", "            case flag:\n", "                return flag;\n", "            case speed:\n", "                return type.speed * 60f / tilesize;\n", "            case controlled:\n", "                return !isValid() ? 0 : controller instanceof LogicAI ? ctrlProcessor : controller instanceof Player ? ctrlPlayer : (controller instanceof CommandAI && (command = (CommandAI) controller) == controller) && command.hasCommand() ? ctrlCommand : 0;\n", "            case payloadCount:\n", "                return (((Object) this) instanceof Payloadc && (pay = (Payloadc) ((Object) this)) == ((Object) this)) ? pay.payloads().size : 0;\n", "            case size:\n", "                return hitSize / tilesize;\n", "            case color:\n", "                return Color.toDoubleBits(team.color.r, team.color.g, team.color.b, 1f);\n", "            default:\n", "                return Float.NaN;\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public Object senseObject(LAccess sensor) {\n", "        Player p;\n", "        LogicAI log;\n", "        Payloadc pay;\n", "        UnitPayload p1;\n", "        BuildPayload p2;\n", "        switch(sensor) {\n", "            case type:\n", "                return type;\n", "            case name:\n", "                return (controller instanceof Player && (p = (Player) controller) == controller) ? p.name : null;\n", "            case firstItem:\n", "                return stack().amount == 0 ? null : item();\n", "            case controller:\n", "                return !isValid() ? null : (controller instanceof LogicAI && (log = (LogicAI) controller) == controller) ? log.controller : this;\n", "            case payloadType:\n", "                return (((Object) this) instanceof Payloadc && (pay = (Payloadc) ((Object) this)) == ((Object) this)) ? (pay.payloads().isEmpty() ? null : (pay.payloads().peek() instanceof UnitPayload && (p1 = (UnitPayload) pay.payloads().peek()) == pay.payloads().peek()) ? p1.unit.type : (pay.payloads().peek() instanceof BuildPayload && (p2 = (BuildPayload) pay.payloads().peek()) == pay.payloads().peek()) ? p2.block() : null) : null;\n", "            default:\n", "                return noSensed;\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public double sense(Content content) {\n", "        if (content == stack().item)\n", "            return stack().amount;\n", "        return Float.NaN;\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public boolean canDrown() {\n", "        return isGrounded() && !hovering && type.canDrown;\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public boolean canShoot() {\n", "        // cannot shoot while boosting\n", "        return !disarmed && !(type.canBoost && isFlying());\n", "    }\n", "\n", "    public boolean isEnemy() {\n", "        return type.isEnemy;\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public boolean collides(Hitboxc other) {\n", "        return hittable();\n", "    }\n", "\n", "    @Override\n", "    public void collision(Hitboxc other, float x, float y) {\n", "        Bullet bullet;\n", "        if ((other instanceof Bullet && (bullet = (Bullet) other) == other)) {\n", "            controller.hit(bullet);\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public int itemCapacity() {\n", "        return type.itemCapacity;\n", "    }\n", "\n", "    @Override\n", "    public float bounds() {\n", "        return hitSize * 2f;\n", "    }\n", "\n", "    @Override\n", "    public void controller(UnitController next) {\n", "        this.controller = next;\n", "        if (controller.unit() != self())\n", "            controller.unit(self());\n", "    }\n", "\n", "    @Override\n", "    public UnitController controller() {\n", "        return controller;\n", "    }\n", "\n", "    public void resetController() {\n", "        controller(type.createController(self()));\n", "    }\n", "\n", "    @Override\n", "    public void set(UnitType def, UnitController controller) {\n", "        if (this.type != def) {\n", "            setType(def);\n", "        }\n", "        controller(controller);\n", "    }\n", "\n", "    /**\n", "     * @return pathfinder path type for calculating costs\n", "     */\n", "    public int pathType() {\n", "        return Pathfinder.costGround;\n", "    }\n", "\n", "    public void lookAt(float angle) {\n", "        rotation = Angles.moveToward(rotation, angle, type.rotateSpeed * Time.delta * speedMultiplier());\n", "    }\n", "\n", "    public void lookAt(Position pos) {\n", "        lookAt(angleTo(pos));\n", "    }\n", "\n", "    public void lookAt(float x, float y) {\n", "        lookAt(angleTo(x, y));\n", "    }\n", "\n", "    public boolean isAI() {\n", "        return controller instanceof AIController;\n", "    }\n", "\n", "    public boolean isCommandable() {\n", "        return controller instanceof CommandAI;\n", "    }\n", "\n", "    public CommandAI command() {\n", "        CommandAI ai;\n", "        if ((controller instanceof CommandAI && (ai = (CommandAI) controller) == controller)) {\n", "            return ai;\n", "        } else {\n", "            throw new IllegalArgumentException(\"Unit cannot be commanded - check isCommandable() first.\");\n", "        }\n", "    }\n", "\n", "    public int count() {\n", "        return team.data().countType(type);\n", "    }\n", "\n", "    public int cap() {\n", "        return Units.getCap(team);\n", "    }\n", "\n", "    public void setType(UnitType type) {\n", "        this.type = type;\n", "        this.maxHealth = type.health;\n", "        this.drag = type.drag;\n", "        this.armor = type.armor;\n", "        this.hitSize = type.hitSize;\n", "        this.hovering = type.hovering;\n", "        if (controller == null)\n", "            controller(type.createController(self()));\n", "        if (mounts().length != type.weapons.size)\n", "            setupWeapons(type);\n", "        if (abilities.length != type.abilities.size) {\n", "            abilities = new Ability[type.abilities.size];\n", "            for (int i = 0; i < type.abilities.size; i++) {\n", "                abilities[i] = type.abilities.get(i).copy();\n", "            }\n", "        }\n", "    }\n", "\n", "    public boolean targetable(Team targeter) {\n", "        return type.targetable(self(), targeter);\n", "    }\n", "\n", "    public boolean hittable() {\n", "        return type.hittable(self());\n", "    }\n", "\n", "    @Override\n", "    public void afterSync() {\n", "        // set up type info after reading\n", "        setType(this.type);\n", "        controller.unit(self());\n", "    }\n", "\n", "    @Override\n", "    public void afterRead() {\n", "        afterSync();\n", "        AIController ai;\n", "        // reset controller state\n", "        if (!((controller instanceof AIController && (ai = (AIController) controller) == controller) && ai.keepState())) {\n", "            controller(type.createController(self()));\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void add() {\n", "        team.data().updateCount(type, 1);\n", "        // check if over unit cap\n", "        if (type.useUnitCap && count() > cap() && !spawnedByCore && !dead && !state.rules.editor) {\n", "            Call.unitCapDeath(self());\n", "            team.data().updateCount(type, -1);\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "        team.data().updateCount(type, -1);\n", "        controller.removed(self());\n", "        // make sure trail doesn't just go poof\n", "        if (trail != null && trail.size() > 0) {\n", "            Fx.trailFade.at(x, y, trail.width(), type.trailColor == null ? team.color : type.trailColor, trail.copy());\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void landed() {\n", "        if (type.mechLandShake > 0f) {\n", "            Effect.shake(type.mechLandShake, type.mechLandShake, this);\n", "        }\n", "        type.landed(self());\n", "    }\n", "\n", "    @Override\n", "    public void heal(float amount) {\n", "        if (health < maxHealth && amount > 0) {\n", "            wasHealed = true;\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        type.update(self());\n", "        if (wasHealed && healTime <= -1f) {\n", "            healTime = 1f;\n", "        }\n", "        healTime -= Time.delta / 20f;\n", "        wasHealed = false;\n", "        // check if environment is unsupported\n", "        if (!type.supportsEnv(state.rules.env) && !dead) {\n", "            Call.unitEnvDeath(self());\n", "            team.data().updateCount(type, -1);\n", "        }\n", "        if (state.rules.unitAmmo && ammo < type.ammoCapacity - 0.0001f) {\n", "            resupplyTime += Time.delta;\n", "            // resupply only at a fixed interval to prevent lag\n", "            if (resupplyTime > 10f) {\n", "                type.ammoType.resupply(self());\n", "                resupplyTime = 0f;\n", "            }\n", "        }\n", "        for (Ability a : abilities) {\n", "            a.update(self());\n", "        }\n", "        if (trail != null) {\n", "            trail.length = type.trailLength;\n", "            float scale = type.useEngineElevation ? elevation : 1f;\n", "            float offset = type.engineOffset / 2f + type.engineOffset / 2f * scale;\n", "            float cx = x + Angles.trnsx(rotation + 180, offset), cy = y + Angles.trnsy(rotation + 180, offset);\n", "            trail.update(cx, cy);\n", "        }\n", "        drag = type.drag * (isGrounded() ? (floorOn().dragMultiplier) : 1f) * dragMultiplier * state.rules.dragMultiplier;\n", "        // apply knockback based on spawns\n", "        if (team != state.rules.waveTeam && state.hasSpawns() && (!net.client() || isLocal())) {\n", "            float relativeSize = state.rules.dropZoneRadius + hitSize / 2f + 1f;\n", "            for (Tile spawn : spawner.getSpawns()) {\n", "                if (within(spawn.worldx(), spawn.worldy(), relativeSize)) {\n", "                    velAddNet(Tmp.v1.set(this).sub(spawn.worldx(), spawn.worldy()).setLength(0.1f + 1f - dst(spawn) / relativeSize).scl(0.45f * Time.delta));\n", "                }\n", "            }\n", "        }\n", "        // simulate falling down\n", "        if (dead || health <= 0) {\n", "            // less drag when dead\n", "            drag = 0.01f;\n", "            // standard fall smoke\n", "            if (Mathf.chanceDelta(0.1)) {\n", "                Tmp.v1.rnd(Mathf.range(hitSize));\n", "                type.fallEffect.at(x + Tmp.v1.x, y + Tmp.v1.y);\n", "            }\n", "            // thruster fall trail\n", "            if (Mathf.chanceDelta(0.2)) {\n", "                float offset = type.engineOffset / 2f + type.engineOffset / 2f * elevation;\n", "                float range = Mathf.range(type.engineSize);\n", "                type.fallEngineEffect.at(x + Angles.trnsx(rotation + 180, offset) + Mathf.range(range), y + Angles.trnsy(rotation + 180, offset) + Mathf.range(range), Mathf.random());\n", "            }\n", "            // move down\n", "            elevation -= type.fallSpeed * Time.delta;\n", "            if (isGrounded() || health <= -maxHealth) {\n", "                Call.unitDestroy(id);\n", "            }\n", "        }\n", "        Tile tile = tileOn();\n", "        Floor floor = floorOn();\n", "        if (tile != null && isGrounded() && !type.hovering) {\n", "            // unit block update\n", "            if (tile.build != null) {\n", "                tile.build.unitOn(self());\n", "            }\n", "            // apply damage\n", "            if (floor.damageTaken > 0f) {\n", "                damageContinuous(floor.damageTaken);\n", "            }\n", "        }\n", "        // kill entities on tiles that are solid to them\n", "        if (tile != null && !canPassOn()) {\n", "            // boost if possible\n", "            if (type.canBoost) {\n", "                elevation = 1f;\n", "            } else if (!net.client()) {\n", "                kill();\n", "            }\n", "        }\n", "        // AI only updates on the server\n", "        if (!net.client() && !dead) {\n", "            controller.updateUnit();\n", "        }\n", "        // clear controller when it becomes invalid\n", "        if (!controller.isValidController()) {\n", "            resetController();\n", "        }\n", "        // remove units spawned by the core\n", "        if (spawnedByCore && !isPlayer() && !dead) {\n", "            Call.unitDespawn(self());\n", "        }\n", "    }\n", "\n", "    /**\n", "     * @return a preview icon for this unit.\n", "     */\n", "    public TextureRegion icon() {\n", "        return type.fullIcon;\n", "    }\n", "\n", "    /**\n", "     * Actually destroys the unit, removing it and creating explosions. *\n", "     */\n", "    public void destroy() {\n", "        if (!isAdded() || !type.killable)\n", "            return;\n", "        float explosiveness = 2f + item().explosiveness * stack().amount * 1.53f;\n", "        float flammability = item().flammability * stack().amount / 1.9f;\n", "        float power = item().charge * Mathf.pow(stack().amount, 1.11f) * 160f;\n", "        if (!spawnedByCore) {\n", "            Damage.dynamicExplosion(x, y, flammability, explosiveness, power, (bounds() + type.legLength / 1.7f) / 2f, state.rules.damageExplosions, item().flammability > 1, team, type.deathExplosionEffect);\n", "        } else {\n", "            type.deathExplosionEffect.at(x, y, bounds() / 2f / 8f);\n", "        }\n", "        float shake = hitSize / 3f;\n", "        if (type.createScorch) {\n", "            Effect.scorch(x, y, (int) (hitSize / 5));\n", "        }\n", "        Effect.shake(shake, shake, this);\n", "        type.deathSound.at(this);\n", "        Events.fire(new UnitDestroyEvent(self()));\n", "        if (explosiveness > 7f && (isLocal() || wasPlayer)) {\n", "            Events.fire(Trigger.suicideBomb);\n", "        }\n", "        for (WeaponMount mount : mounts) {\n", "            if (mount.weapon.shootOnDeath && !(mount.weapon.bullet.killShooter && mount.totalShots > 0)) {\n", "                mount.reload = 0f;\n", "                mount.shoot = true;\n", "                mount.weapon.update(self(), mount);\n", "            }\n", "        }\n", "        // if this unit crash landed (was flying), damage stuff in a radius\n", "        if (type.flying && !spawnedByCore && type.createWreck) {\n", "            Damage.damage(team, x, y, Mathf.pow(hitSize, 0.94f) * 1.25f, Mathf.pow(hitSize, 0.75f) * type.crashDamageMultiplier * 5f, true, false, true);\n", "        }\n", "        if (!headless && type.createScorch) {\n", "            for (int i = 0; i < type.wreckRegions.length; i++) {\n", "                if (type.wreckRegions[i].found()) {\n", "                    float range = type.hitSize / 4f;\n", "                    Tmp.v1.rnd(range);\n", "                    Effect.decal(type.wreckRegions[i], x + Tmp.v1.x, y + Tmp.v1.y, rotation - 90);\n", "                }\n", "            }\n", "        }\n", "        for (Ability a : abilities) {\n", "            a.death(self());\n", "        }\n", "        type.killed(self());\n", "        remove();\n", "    }\n", "\n", "    /**\n", "     * @return name of direct or indirect player controller.\n", "     */\n", "    @Override\n", "    @Nullable\n", "    public String getControllerName() {\n", "        if (isPlayer())\n", "            return getPlayer().name;\n", "        {\n", "            LogicAI ai;\n", "            if ((controller instanceof LogicAI && (ai = (LogicAI) controller) == controller) && ai.controller != null)\n", "                return ai.controller.lastAccessed;\n", "        }\n", "        return null;\n", "    }\n", "\n", "    @Override\n", "    public void display(Table table) {\n", "        type.display(self(), table);\n", "    }\n", "\n", "    @Override\n", "    public boolean isImmune(StatusEffect effect) {\n", "        return type.immunities.contains(effect);\n", "    }\n", "\n", "    @Override\n", "    public void draw() {\n", "        type.draw(self());\n", "    }\n", "\n", "    @Override\n", "    public boolean isPlayer() {\n", "        return controller instanceof Player;\n", "    }\n", "\n", "    @Nullable\n", "    public Player getPlayer() {\n", "        return isPlayer() ? (Player) controller : null;\n", "    }\n", "\n", "    @Override\n", "    public void killed() {\n", "        wasPlayer = isLocal();\n", "        health = Math.min(health, 0);\n", "        dead = true;\n", "        // don't waste time when the unit is already on the ground, just destroy it\n", "        if (!type.flying || !type.createWreck) {\n", "            destroy();\n", "        }\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public void kill() {\n", "        if (dead || net.client() || !type.killable)\n", "            return;\n", "        // deaths are synced; this calls killed()\n", "        Call.unitDeath(id);\n", "    }\n", "}\n" }));
        compMap.put("UnitTetherComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.game.*;\n", "import mindustry.gen.*;\n", "import mindustry.type.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "/**\n", " * A unit that depends on a units's existence; if that unit is removed, it despawns.\n", " */\n", "@Component\n", "abstract class UnitTetherComp implements Unitc {\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    @Import\n", "    Team team;\n", "\n", "    // spawner unit cannot be read directly for technical reasons.\n", "    @Nullable\n", "    public transient Unit spawner;\n", "\n", "    public int spawnerUnitId = -1;\n", "\n", "    @Override\n", "    public void afterRead() {\n", "        if (spawnerUnitId != -1)\n", "            spawner = Groups.unit.getByID(spawnerUnitId);\n", "        spawnerUnitId = -1;\n", "    }\n", "\n", "    @Override\n", "    public void afterSync() {\n", "        if (spawnerUnitId != -1)\n", "            spawner = Groups.unit.getByID(spawnerUnitId);\n", "        spawnerUnitId = -1;\n", "    }\n", "\n", "    @Override\n", "    public void update() {\n", "        if (spawner == null || !spawner.isValid() || spawner.team != team) {\n", "            Call.unitDespawn(self());\n", "        } else {\n", "            spawnerUnitId = spawner.id;\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("VelComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.math.*;\n", "import arc.math.geom.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.entities.EntityCollisions.*;\n", "import mindustry.gen.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class VelComp implements Posc {\n", "\n", "    @Import\n", "    float x, y;\n", "\n", "    @SyncLocal\n", "    Vec2 vel = new Vec2();\n", "\n", "    transient float drag = 0f;\n", "\n", "    // velocity needs to be called first, as it affects delta and lastPosition\n", "    @MethodPriority(-1)\n", "    @Override\n", "    public void update() {\n", "        // do not update velocity on the client at all, unless it's non-interpolated\n", "        // velocity conflicts with interpolation.\n", "        if (!net.client() || isLocal()) {\n", "            float px = x, py = y;\n", "            move(vel.x * Time.delta, vel.y * Time.delta);\n", "            if (Mathf.equal(px, x))\n", "                vel.x = 0;\n", "            if (Mathf.equal(py, y))\n", "                vel.y = 0;\n", "            vel.scl(Math.max(1f - drag * Time.delta, 0));\n", "        }\n", "    }\n", "\n", "    /**\n", "     * @return function to use for check solid state. if null, no checking is done.\n", "     */\n", "    @Nullable\n", "    SolidPred solidity() {\n", "        return null;\n", "    }\n", "\n", "    /**\n", "     * @return whether this entity can move through a location\n", "     */\n", "    boolean canPass(int tileX, int tileY) {\n", "        SolidPred s = solidity();\n", "        return s == null || !s.solid(tileX, tileY);\n", "    }\n", "\n", "    /**\n", "     * @return whether this entity can exist on its current location\n", "     */\n", "    boolean canPassOn() {\n", "        return canPass(tileX(), tileY());\n", "    }\n", "\n", "    boolean moving() {\n", "        return !vel.isZero(0.01f);\n", "    }\n", "\n", "    void move(Vec2 v) {\n", "        move(v.x, v.y);\n", "    }\n", "\n", "    void move(float cx, float cy) {\n", "        SolidPred check = solidity();\n", "        if (check != null) {\n", "            collisions.move(self(), cx, cy, check);\n", "        } else {\n", "            x += cx;\n", "            y += cy;\n", "        }\n", "    }\n", "\n", "    void velAddNet(Vec2 v) {\n", "        vel.add(v);\n", "        if (isRemote()) {\n", "            x += v.x;\n", "            y += v.y;\n", "        }\n", "    }\n", "\n", "    void velAddNet(float vx, float vy) {\n", "        vel.add(vx, vy);\n", "        if (isRemote()) {\n", "            x += vx;\n", "            y += vy;\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("WaterMoveComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.graphics.*;\n", "import arc.graphics.g2d.*;\n", "import arc.math.*;\n", "import arc.util.*;\n", "import mindustry.ai.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.content.*;\n", "import mindustry.entities.*;\n", "import mindustry.entities.EntityCollisions.*;\n", "import mindustry.gen.*;\n", "import mindustry.graphics.*;\n", "import mindustry.type.*;\n", "import mindustry.world.*;\n", "import mindustry.world.blocks.environment.*;\n", "import static mindustry.Vars.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class WaterMoveComp implements Posc, Velc, Hitboxc, Flyingc, Unitc {\n", "\n", "    @Import\n", "    float x, y, rotation, speedMultiplier;\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    private transient Trail tleft = new Trail(1), tright = new Trail(1);\n", "\n", "    private transient Color trailColor = Blocks.water.mapColor.cpy().mul(1.5f);\n", "\n", "    @Override\n", "    public void update() {\n", "        boolean flying = isFlying();\n", "        for (int i = 0; i < 2; i++) {\n", "            Trail t = i == 0 ? tleft : tright;\n", "            t.length = type.trailLength;\n", "            int sign = i == 0 ? -1 : 1;\n", "            float cx = Angles.trnsx(rotation - 90, type.waveTrailX * sign, type.waveTrailY) + x, cy = Angles.trnsy(rotation - 90, type.waveTrailX * sign, type.waveTrailY) + y;\n", "            t.update(cx, cy, world.floorWorld(cx, cy).isLiquid && !flying ? 1 : 0);\n", "        }\n", "    }\n", "\n", "    @Override\n", "    @Replace\n", "    public int pathType() {\n", "        return Pathfinder.costNaval;\n", "    }\n", "\n", "    // don't want obnoxious splashing\n", "    @Override\n", "    @Replace\n", "    public boolean emitWalkSound() {\n", "        return false;\n", "    }\n", "\n", "    @Override\n", "    public void add() {\n", "        tleft.clear();\n", "        tright.clear();\n", "    }\n", "\n", "    @Override\n", "    public void draw() {\n", "        float z = Draw.z();\n", "        Draw.z(Layer.debris);\n", "        Floor floor = tileOn() == null ? Blocks.air.asFloor() : tileOn().floor();\n", "        Color color = Tmp.c1.set(floor.mapColor.equals(Color.black) ? Blocks.water.mapColor : floor.mapColor).mul(1.5f);\n", "        trailColor.lerp(color, Mathf.clamp(Time.delta * 0.04f));\n", "        tleft.draw(trailColor, type.trailScl);\n", "        tright.draw(trailColor, type.trailScl);\n", "        Draw.z(z);\n", "    }\n", "\n", "    @Replace\n", "    @Override\n", "    public SolidPred solidity() {\n", "        return isFlying() ? null : EntityCollisions::waterSolid;\n", "    }\n", "\n", "    @Replace\n", "    @Override\n", "    public boolean onSolid() {\n", "        return EntityCollisions.waterSolid(tileX(), tileY());\n", "    }\n", "\n", "    @Replace\n", "    public float floorSpeedMultiplier() {\n", "        Floor on = isFlying() ? Blocks.air.asFloor() : floorOn();\n", "        return (on.shallow ? 1f : 1.3f) * speedMultiplier;\n", "    }\n", "\n", "    public boolean onLiquid() {\n", "        Tile tile = tileOn();\n", "        return tile != null && tile.floor().isLiquid;\n", "    }\n", "}\n" }));
        compMap.put("WeaponsComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.math.geom.*;\n", "import arc.util.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.entities.units.*;\n", "import mindustry.gen.*;\n", "import mindustry.type.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "@Component\n", "abstract class WeaponsComp implements Teamc, Posc, Rotc, Velc, Statusc {\n", "\n", "    @Import\n", "    float x, y;\n", "\n", "    @Import\n", "    boolean disarmed;\n", "\n", "    @Import\n", "    UnitType type;\n", "\n", "    /**\n", "     * weapon mount array, never null\n", "     */\n", "    @SyncLocal\n", "    WeaponMount[] mounts = {};\n", "\n", "    @ReadOnly\n", "    transient boolean isRotate;\n", "\n", "    transient float aimX, aimY;\n", "\n", "    boolean isShooting;\n", "\n", "    float ammo;\n", "\n", "    float ammof() {\n", "        return ammo / type.ammoCapacity;\n", "    }\n", "\n", "    void setWeaponRotation(float rotation) {\n", "        for (WeaponMount mount : mounts) {\n", "            mount.rotation = rotation;\n", "        }\n", "    }\n", "\n", "    void setupWeapons(UnitType def) {\n", "        mounts = new WeaponMount[def.weapons.size];\n", "        for (int i = 0; i < mounts.length; i++) {\n", "            mounts[i] = def.weapons.get(i).mountType.get(def.weapons.get(i));\n", "        }\n", "    }\n", "\n", "    void controlWeapons(boolean rotateShoot) {\n", "        controlWeapons(rotateShoot, rotateShoot);\n", "    }\n", "\n", "    void controlWeapons(boolean rotate, boolean shoot) {\n", "        for (WeaponMount mount : mounts) {\n", "            if (mount.weapon.controllable) {\n", "                mount.rotate = rotate;\n", "                mount.shoot = shoot;\n", "            }\n", "        }\n", "        isRotate = rotate;\n", "        isShooting = shoot;\n", "    }\n", "\n", "    void aim(Position pos) {\n", "        aim(pos.getX(), pos.getY());\n", "    }\n", "\n", "    /**\n", "     * Aim at something. This will make all mounts point at it.\n", "     */\n", "    void aim(float x, float y) {\n", "        Tmp.v1.set(x, y).sub(this.x, this.y);\n", "        if (Tmp.v1.len() < type.aimDst)\n", "            Tmp.v1.setLength(type.aimDst);\n", "        x = Tmp.v1.x + this.x;\n", "        y = Tmp.v1.y + this.y;\n", "        for (WeaponMount mount : mounts) {\n", "            if (mount.weapon.controllable) {\n", "                mount.aimX = x;\n", "                mount.aimY = y;\n", "            }\n", "        }\n", "        aimX = x;\n", "        aimY = y;\n", "    }\n", "\n", "    boolean canShoot() {\n", "        return !disarmed;\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "        for (WeaponMount mount : mounts) {\n", "            if (mount.bullet != null && mount.bullet.owner == self()) {\n", "                mount.bullet.time = mount.bullet.lifetime - 10f;\n", "                mount.bullet = null;\n", "            }\n", "            if (mount.sound != null) {\n", "                mount.sound.stop();\n", "            }\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Update shooting and rotation for this unit.\n", "     */\n", "    @Override\n", "    public void update() {\n", "        for (WeaponMount mount : mounts) {\n", "            mount.weapon.update(self(), mount);\n", "        }\n", "    }\n", "}\n" }));
        compMap.put("WorldLabelComp",String.join("",new String[] { "package mma.entities.compByAnuke;\n", "\n", "import arc.graphics.*;\n", "import arc.graphics.g2d.*;\n", "import arc.scene.ui.layout.*;\n", "import arc.util.*;\n", "import arc.util.pooling.*;\n", "import mindustry.annotations.Annotations.*;\n", "import mindustry.gen.*;\n", "import mindustry.graphics.*;\n", "import mindustry.ui.*;\n", "import static mindustry.logic.LAccess.*;\n", "\n", "/**\n", " * Component/entity for labels in world space. Useful for servers. Does not save in files - create only on world load.\n", " */\n", "@mma.annotations.ModAnnotations.MindustryEntityDef(value = { WorldLabelc.class }, serialize = false)\n", "@Component(base = true)\n", "public abstract class WorldLabelComp implements Posc, Drawc, Syncc {\n", "\n", "    @Import\n", "    int id;\n", "\n", "    @Import\n", "    float x, y;\n", "\n", "    public static final byte flagBackground = 1, flagOutline = 2;\n", "\n", "    public String text = \"sample text\";\n", "\n", "    public float fontSize = 1f, z = Layer.playerName + 1;\n", "\n", "    /**\n", "     * Flags are packed into a byte for sync efficiency; see the flag static values.\n", "     */\n", "    public byte flags = flagBackground | flagOutline;\n", "\n", "    @Replace\n", "    public float clipSize() {\n", "        return text.length() * 10f * fontSize;\n", "    }\n", "\n", "    @Override\n", "    public void draw() {\n", "        drawAt(text, x, y, z, flags, fontSize);\n", "    }\n", "\n", "    public static void drawAt(String text, float x, float y, float layer, int flags, float fontSize) {\n", "        Draw.z(layer);\n", "        float z = Drawf.text();\n", "        Font font = (flags & flagOutline) != 0 ? Fonts.outline : Fonts.def;\n", "        GlyphLayout layout = Pools.obtain(GlyphLayout.class, GlyphLayout::new);\n", "        boolean ints = font.usesIntegerPositions();\n", "        font.setUseIntegerPositions(false);\n", "        font.getData().setScale(0.25f / Scl.scl(1f) * fontSize);\n", "        layout.setText(font, text);\n", "        if ((flags & flagBackground) != 0) {\n", "            Draw.color(0f, 0f, 0f, 0.3f);\n", "            Fill.rect(x, y - layout.height / 2, layout.width + 2, layout.height + 3);\n", "            Draw.color();\n", "        }\n", "        font.setColor(Color.white);\n", "        font.draw(text, x, y, 0, Align.center, false);\n", "        Draw.reset();\n", "        Pools.free(layout);\n", "        font.getData().setScale(1f);\n", "        font.setColor(Color.white);\n", "        font.setUseIntegerPositions(ints);\n", "        Draw.z(z);\n", "    }\n", "\n", "    /**\n", "     * This MUST be called instead of remove()!\n", "     */\n", "    public void hide() {\n", "        remove();\n", "        Call.removeWorldLabel(id);\n", "    }\n", "}\n" }));
        groupDefs="package mma.entities;\r\n\r\nimport mindustry.annotations.Annotations.GroupDef;\r\nimport mindustry.gen.*;\r\n\r\nclass GroupDefs<G>{\r\n    @GroupDef(value = Entityc.class) G all;\r\n    @GroupDef(value = Playerc.class, mapping = true) G player;\r\n    @GroupDef(value = Bulletc.class, spatial = true, collide = true) G bullet;\r\n    @GroupDef(value = Unitc.class, spatial = true, mapping = true) G unit;\r\n    @GroupDef(value = Buildingc.class) G build;\r\n    @GroupDef(value = Syncc.class, mapping = true) G sync;\r\n    @GroupDef(value = Drawc.class) G draw;\r\n    @GroupDef(value = Firec.class) G fire;\r\n    @GroupDef(value = Puddlec.class) G puddle;\r\n//    @GroupDef(value = WeatherStatec.class) G weather;\r\n}\r\n";
    }
}
